"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[6314],{22914(e,s,t){t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"tutorials/real-time-benchmarking-for-qubit-selection","title":"Real-time benchmarking for qubit selection","description":"Run real-time characterization experiments and update backend properties to improve qubit selection when mapping a circuit to the physical qubits on a QPU.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/tutorials/real-time-benchmarking-for-qubit-selection.mdx","sourceDirName":"tutorials","slug":"/tutorials/real-time-benchmarking-for-qubit-selection","permalink":"/tutorials/real-time-benchmarking-for-qubit-selection","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/real-time-benchmarking-for-qubit-selection.mdx","tags":[],"version":"current","frontMatter":{"title":"Real-time benchmarking for qubit selection","sidebar_label":"Real-time benchmarking for qubit selection","description":"Run real-time characterization experiments and update backend properties to improve qubit selection when mapping a circuit to the physical qubits on a QPU.","notebook_path":"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Combine error mitigation options with the Estimator primitive","permalink":"/tutorials/combine-error-mitigation-techniques"},"next":{"title":"Repetition codes","permalink":"/tutorials/repetition-codes"}}');var n=t(74848),a=t(28453);const r={title:"Real-time benchmarking for qubit selection",sidebar_label:"Real-time benchmarking for qubit selection",description:"Run real-time characterization experiments and update backend properties to improve qubit selection when mapping a circuit to the physical qubits on a QPU.",notebook_path:"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"},l=void 0,c={},o=[{value:"Background",id:"background",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Step 1: Map classical inputs to a quantum problem",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Set up backend and coupling map",id:"set-up-backend-and-coupling-map",level:3},{value:"Characterization experiments",id:"characterization-experiments",level:3},{value:"T1",id:"t1",level:4},{value:"T2",id:"t2",level:4},{value:"State preparation and measurement (SPAM) error characterization",id:"state-preparation-and-measurement-spam-error-characterization",level:4},{value:"Single-qubit and two-qubit randomized benchmarking",id:"single-qubit-and-two-qubit-randomized-benchmarking",level:4},{value:"QPU properties over time",id:"qpu-properties-over-time",level:3},{value:"Step 2: Optimize problem for quantum hardware execution",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Step 3: Execute using Qiskit primitives",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Execute a quantum circuit with default qubit selection",id:"execute-a-quantum-circuit-with-default-qubit-selection",level:3},{value:"Execute a quantum circuit with real-time qubit selection",id:"execute-a-quantum-circuit-with-real-time-qubit-selection",level:3},{value:"Step 4: Post-process and return result in desired classical format",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Tutorial survey",id:"tutorial-survey",level:2}];function m(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:i,OpenInLabBanner:r}=s;return i||d("Admonition",!0),r||d("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(r,{notebookPath:"docs/tutorials/real-time-benchmarking-for-qubit-selection.ipynb"}),"\n","\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.em,{children:"Usage estimate: 4 minutes on an Eagle r2 processor (NOTE: This is an estimate only. Your runtime might vary.)"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-experiments\n"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"# This cell is hidden from users \u2013 it disables some lint rules\n# ruff: noqa: E722\n"})}),"\n",(0,n.jsx)(s.h2,{id:"background",children:"Background"}),"\n",(0,n.jsx)(s.p,{children:"This tutorial shows how to run real-time characterization experiments and update backend properties to improve qubit selection when mapping a circuit to the physical qubits on a QPU. You will learn the basic characterization experiments that are used to determine properties of the QPU, how to do them in Qiskit, and how to update the properties saved in the backend object representing the QPU based on these experiments."}),"\n",(0,n.jsxs)(s.p,{children:["The QPU-reported properties are updated once a day, but the system may drift faster than the time between updates. This can affect the reliability of the qubit selection routines in the ",(0,n.jsx)(s.code,{children:"Layout"})," stage of the pass manager, as they'd be using reported properties that don't represent the present state of the QPU. For this reason, it may be worth devoting some QPU time to characterization experiments, which can then be used to update the QPU properties used by the ",(0,n.jsx)(s.code,{children:"Layout"})," routine."]}),"\n",(0,n.jsx)(s.h2,{id:"requirements",children:"Requirements"}),"\n",(0,n.jsx)(s.p,{children:"Before starting this tutorial, be sure you have the following installed:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Qiskit SDK v2.0 or later, with ",(0,n.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualization"})," support"]}),"\n",(0,n.jsxs)(s.li,{children:["Qiskit Runtime v0.40 or later ( ",(0,n.jsx)(s.code,{children:"pip install qiskit-ibm-runtime"})," )"]}),"\n",(0,n.jsxs)(s.li,{children:["Qiskit Experiments v0.12 or later ( ",(0,n.jsx)(s.code,{children:"pip install qiskit-experiments"})," )"]}),"\n",(0,n.jsxs)(s.li,{children:["Rustworkx graph library (",(0,n.jsx)(s.code,{children:"pip install rustworkx"}),")"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"setup",children:"Setup"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"from qiskit_ibm_runtime import SamplerV2\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit.quantum_info import hellinger_fidelity\nfrom qiskit.transpiler import InstructionProperties\n\nfrom qiskit_experiments.library import (\n    T1,\n    T2Hahn,\n    LocalReadoutError,\n    StandardRB,\n)\nfrom qiskit_experiments.framework import BatchExperiment, ParallelExperiment\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import Session\n\nfrom datetime import datetime\nfrom collections import defaultdict\nimport numpy as np\nimport rustworkx\nimport matplotlib.pyplot as plt\nimport copy\n"})}),"\n",(0,n.jsx)(s.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Map classical inputs to a quantum problem"}),"\n",(0,n.jsx)(s.p,{children:"To benchmark the difference in performance, we consider a circuit that prepares a Bell state across a linear chain of varying length. The fidelity of the Bell state at the ends of the chain is measured."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'from qiskit import QuantumCircuit\n\nideal_dist = {"00": 0.5, "11": 0.5}\n\nnum_qubits_list = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 127]\ncircuits = []\nfor num_qubits in num_qubits_list:\n    circuit = QuantumCircuit(num_qubits, 2)\n    circuit.h(0)\n    for i in range(num_qubits - 1):\n        circuit.cx(i, i + 1)\n    circuit.barrier()\n    circuit.measure(0, 0)\n    circuit.measure(num_qubits - 1, 1)\n    circuits.append(circuit)\n\ncircuits[-1].draw(output="mpl", style="clifford", fold=-1)\n'})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Output of the previous code cell",src:t(76086).A+"",width:"8510",height:"8286"})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Output of the previous code cell",src:t(70917).A+"",width:"8510",height:"8286"})}),"\n",(0,n.jsx)(s.h3,{id:"set-up-backend-and-coupling-map",children:"Set up backend and coupling map"}),"\n",(0,n.jsx)(s.p,{children:"First, select a backend"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"# To run on hardware, select the backend with the fewest number of jobs in the queue\nservice = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=127\n)\n\nqubits = list(range(backend.num_qubits))\n"})}),"\n",(0,n.jsx)(s.p,{children:"Then obtain its coupling map"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"coupling_graph = backend.coupling_map.graph.to_undirected(multigraph=False)\n\n# Get unidirectional coupling map\none_dir_coupling_map = coupling_graph.edge_list()\n"})}),"\n",(0,n.jsxs)(s.p,{children:["In order to benchmark as many two-qubit gates as possible simultaneously we separate the coupling map into a ",(0,n.jsx)(s.code,{children:"layered_coupling_map"}),". This object contains a list of layers where each layer is a list of edges on which two-qubit gates can be executed at the same time. This is also called an edge coloring of the coupling map."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"# Get layered coupling map\nedge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)\nlayered_coupling_map = defaultdict(list)\nfor edge_idx, color in edge_coloring.items():\n    layered_coupling_map[color].append(\n        coupling_graph.get_edge_endpoints_by_index(edge_idx)\n    )\nlayered_coupling_map = [\n    sorted(layered_coupling_map[i])\n    for i in sorted(layered_coupling_map.keys())\n]\n"})}),"\n",(0,n.jsx)(s.h3,{id:"characterization-experiments",children:"Characterization experiments"}),"\n",(0,n.jsxs)(s.p,{children:["A series of experiments is used to characterize the main properties of the qubits in a QPU. These are ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", readout error, and single-qubit and two-qubit gate error. We'll briefly summarize what these properties are and refer to experiments in the ",(0,n.jsx)(s.a,{href:"https://qiskit-community.github.io/qiskit-experiments/index.html",children:(0,n.jsx)(s.code,{children:"qiskit-experiments"})})," package that are used to characterize them."]}),"\n",(0,n.jsx)(s.h4,{id:"t1",children:"T1"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})," is the characteristic time it takes for an excited qubit to fall to the ground state due to amplitude-damping decoherence processes. In a ",(0,n.jsxs)(s.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/characterization/t1.html",children:[(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})," experiment"]}),", we measure an excited qubit after a delay. The larger the delay time is, the more\nlikely is the qubit to fall to the ground state. The goal of the\nexperiment is to characterize the decay rate of the qubit towards the\nground state."]}),"\n",(0,n.jsx)(s.h4,{id:"t2",children:"T2"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})," represents the amount of time required for a single qubit's Bloch\nvector projection on the XY plane to fall to approximately 37% (",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.mfrac,{children:[(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mi,{children:"e"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\frac{1}{e}"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1.1901em",verticalAlign:"-0.345em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mopen nulldelimiter"}),(0,n.jsx)(s.span,{className:"mfrac",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsxs)(s.span,{className:"vlist",style:{height:"0.8451em"},children:[(0,n.jsxs)(s.span,{style:{top:"-2.655em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",children:"e"})})})]}),(0,n.jsxs)(s.span,{style:{top:"-3.23em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"frac-line",style:{borderBottomWidth:"0.04em"}})]}),(0,n.jsxs)(s.span,{style:{top:"-3.394em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})})]})]}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.345em"},children:(0,n.jsx)(s.span,{})})})]})}),(0,n.jsx)(s.span,{className:"mclose nulldelimiter"})]})]})})]}),") of\nits initial amplitude due to dephasing decoherence processes. In a ",(0,n.jsxs)(s.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/characterization/t2hahn.html",children:[(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]})," Hahn Echo experiment"]}),", we can estimate the rate of this decay."]}),"\n",(0,n.jsx)(s.h4,{id:"state-preparation-and-measurement-spam-error-characterization",children:"State preparation and measurement (SPAM) error characterization"}),"\n",(0,n.jsxs)(s.p,{children:["In a ",(0,n.jsx)(s.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/measurement/readout_mitigation.html",children:"SPAM-error characterization experiment"})," qubit are prepared in a certain state (",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\vert 0 \\rangle"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u22230"}),(0,n.jsx)(s.span,{className:"mclose",children:"\u27e9"})]})})]})," or ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2223"}),(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\vert 1 \\rangle"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u22231"}),(0,n.jsx)(s.span,{className:"mclose",children:"\u27e9"})]})})]}),") and measured. The probability of measuring a state different than the one prepared then gives the probability of the error."]}),"\n",(0,n.jsx)(s.h4,{id:"single-qubit-and-two-qubit-randomized-benchmarking",children:"Single-qubit and two-qubit randomized benchmarking"}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.a,{href:"https://qiskit-community.github.io/qiskit-experiments/manuals/verification/randomized_benchmarking.html",children:"Randomized benchmarking (RB)"})," is a popular protocol for characterizing the error rate of\nquantum processors. An RB experiment consists of the generation of random Clifford\ncircuits on the given qubits such that the unitary computed by the circuits is the\nidentity. After running the circuits, the number of shots resulting in an error (that is, an output different from the ground state) are counted, and from this data one can infer error estimates for the quantum device, by calculating the Error Per Clifford."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"# Create T1 experiments on all qubit in parallel\nt1_exp = ParallelExperiment(\n    [\n        T1(\n            physical_qubits=[qubit],\n            delays=[1e-6, 20e-6, 40e-6, 80e-6, 200e-6, 400e-6],\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create T2-Hahn experiments on all qubit in parallel\nt2_exp = ParallelExperiment(\n    [\n        T2Hahn(\n            physical_qubits=[qubit],\n            delays=[1e-6, 20e-6, 40e-6, 80e-6, 200e-6, 400e-6],\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create readout experiments on all qubit in parallel\nreadout_exp = LocalReadoutError(qubits)\n\n# Create single-qubit RB experiments on all qubit in parallel\nsingleq_rb_exp = ParallelExperiment(\n    [\n        StandardRB(\n            physical_qubits=[qubit], lengths=[10, 100, 500], num_samples=10\n        )\n        for qubit in qubits\n    ],\n    backend,\n    analysis=None,\n)\n\n# Create two-qubit RB experiments on the three layers of disjoint edges of the heavy-hex\ntwoq_rb_exp_batched = BatchExperiment(\n    [\n        ParallelExperiment(\n            [\n                StandardRB(\n                    physical_qubits=pair,\n                    lengths=[10, 50, 100],\n                    num_samples=10,\n                )\n                for pair in layer\n            ],\n            backend,\n            analysis=None,\n        )\n        for layer in layered_coupling_map\n    ],\n    backend,\n    flatten_results=True,\n    analysis=None,\n)\n"})}),"\n",(0,n.jsx)(s.h3,{id:"qpu-properties-over-time",children:"QPU properties over time"}),"\n",(0,n.jsx)(s.p,{children:"Looking at the reported QPU properties over time (we'll consider a single week below), we see how these can fluctuate on a scale of a single day. Small fluctuations can happen even within a day. In this scenario, the reported properties (updated once per day) will not accurately capture the current status of the QPU. Moreover, if a job is transpiled locally (using current reported properties) and submitted but executed only at a later time (minutes or days), it may run the risk of having used outdated properties for qubit selection in the transpilation step. This highlights the importance of having updated information about the QPU at execution time. First, let's retrieve the properties over a certain time range."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'instruction_2q_name = "cz"  # set the name of the default 2q of the device\nerrors_list = []\nfor day_idx in range(10, 17):\n    calibrations_time = datetime(\n        year=2025, month=8, day=day_idx, hour=0, minute=0, second=0\n    )\n    targer_hist = backend.target_history(datetime=calibrations_time)\n\n    t1_dict, t2_dict = {}, {}\n    for qubit in range(targer_hist.num_qubits):\n        t1_dict[qubit] = targer_hist.qubit_properties[qubit].t1\n        t2_dict[qubit] = targer_hist.qubit_properties[qubit].t2\n\n    errors_dict = {\n        "1q": targer_hist["sx"],\n        "2q": targer_hist[f"{instruction_2q_name}"],\n        "spam": targer_hist["measure"],\n        "t1": t1_dict,\n        "t2": t2_dict,\n    }\n\n    errors_list.append(errors_dict)\n'})}),"\n",(0,n.jsx)(s.p,{children:"Then, let's plot the values"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'fig, axs = plt.subplots(5, 1, figsize=(10, 20), sharex=False)\n\n# Plot for T1 values\nfor qubit in range(targer_hist.num_qubits):\n    t1s = []\n    for errors_dict in errors_list:\n        t1_dict = errors_dict["t1"]\n        try:\n            t1s.append(t1_dict[qubit] / 1e-6)\n        except:\n            print(f"missing t1 data for qubit {qubit}")\n\n    axs[0].plot(t1s)\n\naxs[0].set_title("T1")\naxs[0].set_ylabel(r"Time ($\\mu s$)")\naxs[0].set_xlabel("Days")\n\n# Plot for T2 values\nfor qubit in range(targer_hist.num_qubits):\n    t2s = []\n    for errors_dict in errors_list:\n        t2_dict = errors_dict["t2"]\n        try:\n            t2s.append(t2_dict[qubit] / 1e-6)\n        except:\n            print(f"missing t2 data for qubit {qubit}")\n\n    axs[1].plot(t2s)\n\naxs[1].set_title("T2")\naxs[1].set_ylabel(r"Time ($\\mu s$)")\naxs[1].set_xlabel("Days")\n\n# Plot SPAM values\nfor qubit in range(targer_hist.num_qubits):\n    spams = []\n    for errors_dict in errors_list:\n        spam_dict = errors_dict["spam"]\n        spams.append(spam_dict[tuple([qubit])].error)\n\n    axs[2].plot(spams)\n\naxs[2].set_title("SPAM Errors")\naxs[2].set_ylabel("Error Rate")\naxs[2].set_xlabel("Days")\n\n# Plot 1Q Gate Errors\nfor qubit in range(targer_hist.num_qubits):\n    oneq_gates = []\n    for errors_dict in errors_list:\n        oneq_gate_dict = errors_dict["1q"]\n        oneq_gates.append(oneq_gate_dict[tuple([qubit])].error)\n\n    axs[3].plot(oneq_gates)\n\naxs[3].set_title("1Q Gate Errors")\naxs[3].set_ylabel("Error Rate")\naxs[3].set_xlabel("Days")\n\n# Plot 2Q Gate Errors\nfor pair in one_dir_coupling_map:\n    twoq_gates = []\n    for errors_dict in errors_list:\n        twoq_gate_dict = errors_dict["2q"]\n        twoq_gates.append(twoq_gate_dict[pair].error)\n\n    axs[4].plot(twoq_gates)\n\naxs[4].set_title("2Q Gate Errors")\naxs[4].set_ylabel("Error Rate")\naxs[4].set_xlabel("Days")\n\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n'})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Output of the previous code cell",src:t(70995).A+"",width:"863",height:"1625"})}),"\n",(0,n.jsx)(s.p,{children:"You can see that over several days some of the qubit properties can change considerably. This highlights the importance of having fresh information of the QPU status, to be able to select the best performing qubits for an experiment."}),"\n",(0,n.jsx)(s.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Step 2: Optimize problem for quantum hardware execution"}),"\n",(0,n.jsx)(s.p,{children:"No optimization of the circuits or operators is done in this tutorial."}),"\n",(0,n.jsx)(s.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Step 3: Execute using Qiskit primitives"}),"\n",(0,n.jsx)(s.h3,{id:"execute-a-quantum-circuit-with-default-qubit-selection",children:"Execute a quantum circuit with default qubit selection"}),"\n",(0,n.jsxs)(s.p,{children:["As a reference result of performance, we'll execute a quantum circuit on a QPU by using the default qubits, which are the qubits selected with the requested backend properties. We will use ",(0,n.jsx)(s.code,{children:"optimization_level = 3"}),".  This setting includes the most advanced transpilation optimization, and uses target properties (like operation errors) to select the best performing qubits for execution."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'pm = generate_preset_pass_manager(target=backend.target, optimization_level=3)\nisa_circuits = pm.run(circuits)\ninitial_qubits = [\n    [\n        idx\n        for idx, qb in circuit.layout.initial_layout.get_physical_bits().items()\n        if qb._register.name != "ancilla"\n    ]\n    for circuit in isa_circuits\n]\n'})}),"\n",(0,n.jsx)(s.h3,{id:"execute-a-quantum-circuit-with-real-time-qubit-selection",children:"Execute a quantum circuit with real-time qubit selection"}),"\n",(0,n.jsxs)(s.p,{children:["In this section, we'll investigate the importance of having updated information on qubit properties of the QPU for optimal results. First, we'll carry out a full suite of QPU characterization experiments (",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", SPAM, single-qubit RB and two-qubit RB), which we can then use to update the backend properties. This allows the pass manager to select qubits for the execution based on fresh information about the QPU, possibly improving execution performances. Second, we execute the Bell pair circuit and we compare the fidelity obtained after selecting the qubits with update QPU properties to the fidelity we obtained before when we use the default reported properties for qubit selection."]}),"\n",(0,n.jsx)(i,{type:"caution",children:(0,n.jsxs)(s.p,{children:["Note that some of the characterization experiments might fail when the fitting routine cannot fit a curve to the measured data. If you see warnings coming from these experiments, inspect them to understand which characterization failed on which qubits, and try adjusting the parameters of the experiment (like the times for ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"1"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_1"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"T"}),(0,n.jsx)(s.mn,{children:"2"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"T_2"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"T"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3011em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.1389em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mtight",children:"2"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]})]})})]}),", or the number lengths of RB experiments)."]})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'# Prepare characterization experiments\nbatches = [t1_exp, t2_exp, readout_exp, singleq_rb_exp, twoq_rb_exp_batched]\nbatches_exp = BatchExperiment(batches, backend)  # , analysis=None)\nrun_options = {"shots": 1e3, "dynamic": False}\n\nwith Session(backend=backend) as session:\n    sampler = SamplerV2(mode=session)\n\n    # Run characterization experiments\n    batches_exp_data = batches_exp.run(\n        sampler=sampler, **run_options\n    ).block_for_results()\n\n    EPG_sx_result_list = batches_exp_data.analysis_results("EPG_sx")\n    EPG_sx_result_q_indices = [\n        result.device_components.index for result in EPG_sx_result_list\n    ]\n    EPG_x_result_list = batches_exp_data.analysis_results("EPG_x")\n    EPG_x_result_q_indices = [\n        result.device_components.index for result in EPG_x_result_list\n    ]\n    T1_result_list = batches_exp_data.analysis_results("T1")\n    T1_result_q_indices = [\n        result.device_components.index for result in T1_result_list\n    ]\n\n    T2_result_list = batches_exp_data.analysis_results("T2")\n    T2_result_q_indices = [\n        result.device_components.index for result in T2_result_list\n    ]\n\n    Readout_result_list = batches_exp_data.analysis_results(\n        "Local Readout Mitigator"\n    )\n\n    EPG_2q_result_list = batches_exp_data.analysis_results(\n        f"EPG_{instruction_2q_name}"\n    )\n\n    # Update target properties\n    target = copy.deepcopy(backend.target)\n    for i in range(target.num_qubits - 1):\n        qarg = (i,)\n\n        if qarg in EPG_sx_result_q_indices:\n            target.update_instruction_properties(\n                instruction="sx",\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_sx_result_list[i].value.nominal_value\n                ),\n            )\n        if qarg in EPG_x_result_q_indices:\n            target.update_instruction_properties(\n                instruction="x",\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_x_result_list[i].value.nominal_value\n                ),\n            )\n\n        err_mat = Readout_result_list.value.assignment_matrix(i)\n        readout_assignment_error = (\n            err_mat[0, 1] + err_mat[1, 0]\n        ) / 2  # average readout error\n        target.update_instruction_properties(\n            instruction="measure",\n            qargs=qarg,\n            properties=InstructionProperties(error=readout_assignment_error),\n        )\n\n        if qarg in T1_result_q_indices:\n            target.qubit_properties[i].t1 = T1_result_list[\n                i\n            ].value.nominal_value\n        if qarg in T2_result_q_indices:\n            target.qubit_properties[i].t2 = T2_result_list[\n                i\n            ].value.nominal_value\n\n    for pair_idx, pair in enumerate(one_dir_coupling_map):\n        qarg = tuple(pair)\n        try:\n            target.update_instruction_properties(\n                instruction=instruction_2q_name,\n                qargs=qarg,\n                properties=InstructionProperties(\n                    error=EPG_2q_result_list[pair_idx].value.nominal_value\n                ),\n            )\n        except:\n            target.update_instruction_properties(\n                instruction=instruction_2q_name,\n                qargs=qarg[::-1],\n                properties=InstructionProperties(\n                    error=EPG_2q_result_list[pair_idx].value.nominal_value\n                ),\n            )\n\n    # transpile circuits to updated target\n    pm = generate_preset_pass_manager(target=target, optimization_level=3)\n    isa_circuit_updated = pm.run(circuits)\n    updated_qubits = [\n        [\n            idx\n            for idx, qb in circuit.layout.initial_layout.get_physical_bits().items()\n            if qb._register.name != "ancilla"\n        ]\n        for circuit in isa_circuit_updated\n    ]\n\n    n_trials = 3  # run multiple trials to see variations\n\n    # interleave circuits\n    interleaved_circuits = []\n    for original_circuit, updated_circuit in zip(\n        isa_circuits, isa_circuit_updated\n    ):\n        interleaved_circuits.append(original_circuit)\n        interleaved_circuits.append(updated_circuit)\n\n    # Run circuits\n    # Set simple error suppression/mitigation options\n    sampler.options.dynamical_decoupling.enable = True\n    sampler.options.dynamical_decoupling.sequence_type = "XY4"\n\n    job_interleaved = sampler.run(interleaved_circuits * n_trials)\n'})}),"\n",(0,n.jsx)(s.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-process and return result in desired classical format"}),"\n",(0,n.jsx)(s.p,{children:"Finally, let's compare the fidelity of the Bell state obtained in the two different settings:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"original"}),", that is with the default qubits chosen by the transpiler based on reported properties of the backend."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"updated"}),", that is with the qubits chosen based on updated properties of the backend after characterization experiments have run."]}),"\n"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"results = job_interleaved.result()\nall_fidelity_list, all_fidelity_updated_list = [], []\nfor exp_idx in range(n_trials):\n    fidelity_list, fidelity_updated_list = [], []\n\n    for idx, num_qubits in enumerate(num_qubits_list):\n        pub_result_original = results[\n            2 * exp_idx * len(num_qubits_list) + 2 * idx\n        ]\n        pub_result_updated = results[\n            2 * exp_idx * len(num_qubits_list) + 2 * idx + 1\n        ]\n\n        fid = hellinger_fidelity(\n            ideal_dist, pub_result_original.data.c.get_counts()\n        )\n        fidelity_list.append(fid)\n\n        fid_up = hellinger_fidelity(\n            ideal_dist, pub_result_updated.data.c.get_counts()\n        )\n        fidelity_updated_list.append(fid_up)\n    all_fidelity_list.append(fidelity_list)\n    all_fidelity_updated_list.append(fidelity_updated_list)\n"})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'plt.figure(figsize=(8, 6))\nplt.errorbar(\n    num_qubits_list,\n    np.mean(all_fidelity_list, axis=0),\n    yerr=np.std(all_fidelity_list, axis=0),\n    fmt="o-.",\n    label="original",\n    color="b",\n)\n# plt.plot(num_qubits_list, fidelity_list, \'-.\')\nplt.errorbar(\n    num_qubits_list,\n    np.mean(all_fidelity_updated_list, axis=0),\n    yerr=np.std(all_fidelity_updated_list, axis=0),\n    fmt="o-.",\n    label="updated",\n    color="r",\n)\n# plt.plot(num_qubits_list, fidelity_updated_list, \'-.\')\nplt.xlabel("Chain length")\nplt.xticks(num_qubits_list)\nplt.ylabel("Fidelity")\nplt.title("Bell pair fidelity at the edge of N-qubits chain")\nplt.legend()\nplt.grid(\n    alpha=0.2,\n    linestyle="-.",\n)\nplt.show()\n'})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Output of the previous code cell",src:t(24071).A+"",width:"700",height:"547"})}),"\n",(0,n.jsx)(s.p,{children:"Not all runs will show improvement in performance due to the real-time characterization - and with increasing chain length, and thus less freedom to choose physical qubits, the importance of updated device information becomes less substantial. However, it is good practice to collect fresh data on the device properties to understand its performance. Occasionally, transient two-level systems may affect the performance of some of the qubits. Real-time data can inform us when such events are happening and help us avoid experimental failures in such instances."}),"\n",(0,n.jsx)(i,{type:"note",title:"Call to action",children:(0,n.jsx)(s.p,{children:"Try to apply this method to your executions and determine how much of a benefit you get! You can also try and see how much improvements you get from different backends."})}),"\n",(0,n.jsx)(s.h2,{id:"tutorial-survey",children:"Tutorial survey"}),"\n",(0,n.jsx)(s.p,{children:"Please take this short survey to provide feedback on this tutorial. Your insights will help us improve our content offerings and user experience."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_0w6FZ9QrWkKfTQq",children:"Link to survey"})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}function d(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},76086(e,s,t){t.d(s,{A:()=>i});const i=t.p+"assets/images/64c25da9-a728-4ae4-a377-3078a1dc618d-0-f9deaef9341eae4bbdeb3f4719165675.avif"},70917(e,s,t){t.d(s,{A:()=>i});const i=t.p+"assets/images/64c25da9-a728-4ae4-a377-3078a1dc618d-1-f9deaef9341eae4bbdeb3f4719165675.avif"},24071(e,s,t){t.d(s,{A:()=>i});const i=t.p+"assets/images/656ec97a-3fd9-4635-9a98-1c5589761689-0-29407ac0caee92ba8022fb2629479197.avif"},70995(e,s,t){t.d(s,{A:()=>i});const i=t.p+"assets/images/e0ba509d-e0e0-438b-aedf-5e01919c7d4f-0-ece591eb9ccc6bc0d20ca8dfd5508559.avif"},28453(e,s,t){t.d(s,{R:()=>r,x:()=>l});var i=t(96540);const n={},a=i.createContext(n);function r(e){const s=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(a.Provider,{value:s},e.children)}}}]);