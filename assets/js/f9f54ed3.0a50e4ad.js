"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1225],{19307(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorials/spin-chain-vqe","title":"Ground state energy estimation of the Heisenberg chain with VQE","description":"Build, deploy, and run a Qiskit pattern for simulating a Heisenberg chain and estimating its ground state energy.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/tutorials/spin-chain-vqe.mdx","sourceDirName":"tutorials","slug":"/tutorials/spin-chain-vqe","permalink":"/tutorials/spin-chain-vqe","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/spin-chain-vqe.mdx","tags":[],"version":"current","frontMatter":{"title":"Ground state energy estimation of the Heisenberg chain with VQE","sidebar_label":"Ground state energy estimation of the Heisenberg chain with VQE","description":"Build, deploy, and run a Qiskit pattern for simulating a Heisenberg chain and estimating its ground state energy.","notebook_path":"docs/tutorials/spin-chain-vqe.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Nishimori phase transition","permalink":"/tutorials/nishimori-phase-transition"},"next":{"title":"Quantum kernel training","permalink":"/tutorials/quantum-kernel-training"}}');var s=t(74848),a=t(28453);const r={title:"Ground state energy estimation of the Heisenberg chain with VQE",sidebar_label:"Ground state energy estimation of the Heisenberg chain with VQE",description:"Build, deploy, and run a Qiskit pattern for simulating a Heisenberg chain and estimating its ground state energy.",notebook_path:"docs/tutorials/spin-chain-vqe.ipynb"},o="Ground-state energy estimation of the Heisenberg chain with VQE",l={},c=[{value:"Background",id:"background",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Step 1: Map classical inputs to a quantum problem",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Step 2: Optimize problem for quantum hardware execution",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Step 3: Execute using Qiskit primitives",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Step 4: Post-process and return result in desired classical format",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Deploy the Qiskit pattern to the cloud",id:"deploy-the-qiskit-pattern-to-the-cloud",level:2},{value:"Run the Qiskit pattern as a managed service",id:"run-the-qiskit-pattern-as-a-managed-service",level:3},{value:"Tutorial survey",id:"tutorial-survey",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{OpenInLabBanner:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(n.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(n.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(i,{notebookPath:"docs/tutorials/spin-chain-vqe.ipynb"}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"ground-state-energy-estimation-of-the-heisenberg-chain-with-vqe",children:"Ground-state energy estimation of the Heisenberg chain with VQE"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Usage estimate: Two minutes on an Eagle r3 processor (NOTE: This is an estimate only. Your runtime might vary.)"})}),"\n",(0,s.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(n.p,{children:["This tutorial shows how to build, deploy, and run a ",(0,s.jsx)(n.code,{children:"Qiskit pattern"})," for simulating a Heisenberg chain and estimating its ground state energy. For more information about ",(0,s.jsx)(n.code,{children:"Qiskit patterns"})," and how ",(0,s.jsx)(n.code,{children:"Qiskit Serverless"})," can be used to deploy them to the cloud for managed execution, visit our ",(0,s.jsx)(n.a,{href:"/guides/serverless",children:"docs page on IBM Quantum\xae Platform"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(n.p,{children:"Before starting this tutorial, ensure that you have the following installed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Qiskit SDK v1.2 or later, with ",(0,s.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualization"})," support"]}),"\n",(0,s.jsxs)(n.li,{children:["Qiskit Runtime v0.28 or later (",(0,s.jsx)(n.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n",(0,s.jsx)(n.li,{children:"Qiskit Serverless (pip install qiskit_serverless)"}),"\n",(0,s.jsx)(n.li,{children:"IBM Catalog (pip install qiskit-ibm-catalog)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom scipy.optimize import minimize\nfrom typing import Sequence\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.primitives.base import BaseEstimatorV2\nfrom qiskit.circuit.library import XGate\nfrom qiskit.circuit.library import efficient_su2\nfrom qiskit.transpiler import PassManager\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit.transpiler.passes.scheduling import (\n    ALAPScheduleAnalysis,\n    PadDynamicalDecoupling,\n)\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import Session, Estimator\n\nfrom qiskit_ibm_catalog import QiskitServerless, QiskitFunction\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def visualize_results(results):\n    plt.plot(results["cost_history"], lw=2)\n    plt.xlabel("Iteration")\n    plt.ylabel("Energy")\n    plt.show()\n\ndef build_callback(\n    ansatz: QuantumCircuit,\n    hamiltonian: SparsePauliOp,\n    estimator: BaseEstimatorV2,\n    callback_dict: dict,\n):\n    def callback(current_vector):\n        # Keep track of the number of iterations\n        callback_dict["iters"] += 1\n        # Set the prev_vector to the latest one\n        callback_dict["prev_vector"] = current_vector\n        # Compute the value of the cost function at the current vector\n        current_cost = (\n            estimator.run([(ansatz, hamiltonian, [current_vector])])\n            .result()[0]\n            .data.evs[0]\n        )\n        callback_dict["cost_history"].append(current_cost)\n        # Print to screen on single line\n        print(\n            "Iters. done: {} [Current cost: {}]".format(\n                callback_dict["iters"], current_cost\n            ),\n            end="\\r",\n            flush=True,\n        )\n\n    return callback\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Map classical inputs to a quantum problem"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input: Number of spins"}),"\n",(0,s.jsx)(n.li,{children:"Output: Ansatz and Hamiltonian modeling the Heisenberg chain"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Construct an ansatz and Hamiltonian which model a 10-spin Heisenberg chain. First, we import some generic packages and create a couple of helper functions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'num_spins = 10\nansatz = efficient_su2(num_qubits=num_spins, reps=3)\n\n# Remember to insert your token in the QiskitRuntimeService constructor\nservice = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, min_num_qubits=num_spins, simulator=False\n)\n\ncoupling = backend.target.build_coupling_map()\nreduced_coupling = coupling.reduce(list(range(num_spins)))\n\nedge_list = reduced_coupling.graph.edge_list()\nham_list = []\n\nfor edge in edge_list:\n    ham_list.append(("ZZ", edge, 0.5))\n    ham_list.append(("YY", edge, 0.5))\n    ham_list.append(("XX", edge, 0.5))\n\nfor qubit in reduced_coupling.physical_qubits:\n    ham_list.append(("Z", [qubit], np.random.random() * 2 - 1))\n\nhamiltonian = SparsePauliOp.from_sparse_list(ham_list, num_qubits=num_spins)\n\nansatz.draw("mpl", style="iqp")\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Output of the previous code cell",src:t(32313).A+"",width:"1464",height:"689"})}),"\n",(0,s.jsx)(n.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Step 2: Optimize problem for quantum hardware execution"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input: Abstract circuit, observable"}),"\n",(0,s.jsx)(n.li,{children:"Output: Target circuit and observable, optimized for the selected QPU"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Use the ",(0,s.jsx)(n.code,{children:"generate_preset_pass_manager"})," function from Qiskit to automatically generate an optimization routine for our circuit with respect to the selected QPU. We choose ",(0,s.jsx)(n.code,{children:"optimization_level=3"}),", which provides the highest level of optimization of the preset pass managers. We also include ",(0,s.jsx)(n.code,{children:"ALAPScheduleAnalysis"})," and ",(0,s.jsx)(n.code,{children:"PadDynamicalDecoupling"})," scheduling passes to suppress decoherence errors."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'target = backend.target\npm = generate_preset_pass_manager(optimization_level=3, backend=backend)\npm.scheduling = PassManager(\n    [\n        ALAPScheduleAnalysis(durations=target.durations()),\n        PadDynamicalDecoupling(\n            durations=target.durations(),\n            dd_sequence=[XGate(), XGate()],\n            pulse_alignment=target.pulse_alignment,\n        ),\n    ]\n)\nansatz_ibm = pm.run(ansatz)\nobservable_ibm = hamiltonian.apply_layout(ansatz_ibm.layout)\nansatz_ibm.draw("mpl", scale=0.6, style="iqp", fold=-1, idle_wires=False)\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Output of the previous code cell",src:t(43858).A+"",width:"2859",height:"434"})}),"\n",(0,s.jsx)(n.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Step 3: Execute using Qiskit primitives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input: Target circuit and observable"}),"\n",(0,s.jsx)(n.li,{children:"Output: Results of optimization"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Minimize the estimated ground state energy of the system by optimizing the circuit parameters. Use the ",(0,s.jsx)(n.code,{children:"Estimator"})," primitive from Qiskit Runtime to evaluate the cost function during optimization."]}),"\n",(0,s.jsxs)(n.p,{children:["For this demo, we will run on a QPU using ",(0,s.jsx)(n.code,{children:"qiskit-ibm-runtime"})," primitives. To run with ",(0,s.jsx)(n.code,{children:"qiskit"})," statevector-based primitives, replace the block of code using Qiskit IBM Runtime primitives with the commented block."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# SciPy minimizer routine\ndef cost_func(\n    params: Sequence,\n    ansatz: QuantumCircuit,\n    hamiltonian: SparsePauliOp,\n    estimator: BaseEstimatorV2,\n) -> float:\n    """Ground state energy evaluation."""\n    return (\n        estimator.run([(ansatz, hamiltonian, [params])])\n        .result()[0]\n        .data.evs[0]\n    )\n\nnum_params = ansatz_ibm.num_parameters\nparams = 2 * np.pi * np.random.random(num_params)\n\ncallback_dict = {\n    "prev_vector": None,\n    "iters": 0,\n    "cost_history": [],\n}\n\n# Evaluate the problem on a QPU by using Qiskit IBM Runtime\nwith Session(backend=backend) as session:\n    estimator = Estimator()\n    callback = build_callback(\n        ansatz_ibm, observable_ibm, estimator, callback_dict\n    )\n    res = minimize(\n        cost_func,\n        x0=params,\n        args=(ansatz_ibm, observable_ibm, estimator),\n        callback=callback,\n        method="cobyla",\n        options={"maxiter": 100},\n    )\n\nvisualize_results(callback_dict)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-process and return result in desired classical format"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Input: Ground state energy estimates during optimization"}),"\n",(0,s.jsx)(n.li,{children:"Output: Estimated ground state energy"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"print(f'Estimated ground state energy: {res[\"fun\"]}')\n"})}),"\n",(0,s.jsx)(n.h2,{id:"deploy-the-qiskit-pattern-to-the-cloud",children:"Deploy the Qiskit pattern to the cloud"}),"\n",(0,s.jsxs)(n.p,{children:["To do this, move the source code above to a file, ",(0,s.jsx)(n.code,{children:"./source/heisenberg.py"}),", wrap the code in a script which takes inputs and returns the final solution, and finally upload it to a remote cluster using the ",(0,s.jsx)(n.code,{children:"QiskitFunction"})," class from ",(0,s.jsx)(n.code,{children:"qiskit-ibm-catalog"}),". For guidance on specifying external dependencies, passing input arguments, and more, check out the ",(0,s.jsx)(n.a,{href:"/guides/serverless",children:"Qiskit Serverless guides"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The input to the Pattern is the number of spins in the chain. The output is an estimation of the ground state energy of the system."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Authenticate to the remote cluster and submit the pattern for remote execution\nserverless = QiskitServerless()\nheisenberg_function = QiskitFunction(\n    title="ibm_heisenberg",\n    entrypoint="heisenberg.py",\n    working_dir="./source/",\n)\nserverless.upload(heisenberg_function)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"run-the-qiskit-pattern-as-a-managed-service",children:"Run the Qiskit pattern as a managed service"}),"\n",(0,s.jsxs)(n.p,{children:["Once we have uploaded the pattern to the cloud, we can easily run it using the ",(0,s.jsx)(n.code,{children:"QiskitServerless"})," client."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Run the pattern on the remote cluster\n\nibm_heisenberg = serverless.load("ibm_heisenberg")\njob = serverless.run(ibm_heisenberg)\nsolution = job.result()\n\nprint(solution)\nprint(job.logs())\n'})}),"\n",(0,s.jsx)(n.h2,{id:"tutorial-survey",children:"Tutorial survey"}),"\n",(0,s.jsx)(n.p,{children:"Please take this short survey to provide feedback on this tutorial. Your insights will help us improve our content offerings and user experience."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_bfuBwfNeeFBxnim",children:"Link to survey"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},32313(e,n,t){t.d(n,{A:()=>i});const i=t.p+"assets/images/7e8d2f10-f1d6-4ec2-bac9-9db23499c9e1-0-f9954cab2138e804a339c51fb0fbc32c.avif"},43858(e,n,t){t.d(n,{A:()=>i});const i=t.p+"assets/images/a0a5f1c8-5c31-4d9f-ae81-37bd67271d44-0-7ea21c8c521df2de5e333683e145c990.avif"},28453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);