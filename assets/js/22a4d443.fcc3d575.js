"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1095],{40315(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guides/choose-execution-mode","title":"Choose the right execution mode","description":"Choose the right execution mode for Qiskit Runtime sessions, batch, or single jobs.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/choose-execution-mode.mdx","sourceDirName":"guides","slug":"/guides/choose-execution-mode","permalink":"/guides/choose-execution-mode","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/choose-execution-mode.mdx","tags":[],"version":"current","frontMatter":{"title":"Choose the right execution mode","description":"Choose the right execution mode for Qiskit Runtime sessions, batch, or single jobs."},"sidebar":"tutorialsSidebar","previous":{"title":"Introduction to execution modes","permalink":"/guides/execution-modes"},"next":{"title":"Run jobs in a batch","permalink":"/guides/run-jobs-batch"}}');var t=i(74848),o=i(28453);const r={title:"Choose the right execution mode",description:"Choose the right execution mode for Qiskit Runtime sessions, batch, or single jobs."},a="Choose the right execution mode",l={},c=[{value:"Recommendations and best practices",id:"recommendations-and-best-practices",level:2},{value:"Examples",id:"examples",level:2},{value:"Run a quantum variational algorithm",id:"run-a-quantum-variational-algorithm",level:3},{value:"Compare error mitigation settings",id:"compare-error-mitigation-settings",level:3},{value:"Next steps",id:"next-steps",level:2}];function h(e){const n={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Admonition:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(n.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,t.jsx)(n.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,t.jsx)("span",{id:"sessions-versus-batch-usage"}),"\n",(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"choose-the-right-execution-mode",children:"Choose the right execution mode"})}),"\n",(0,t.jsx)(n.p,{children:"Utility-scale workloads can take many hours to complete, so it is important that both the classical and quantum resources are scheduled efficiently to streamline the execution. Execution modes provide flexibility in balancing the cost and time tradeoff to use resources optimally for your workloads. There are several aspects to consider when choosing which execution mode to use, such as overall execution time (maximum time to live, or TTL) and time between jobs (interactive TTL)."}),"\n",(0,t.jsx)(n.p,{children:"The benefits of each are summarized below:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The entire batch of jobs is scheduled together and there is no additional queuing time for each."}),"\n",(0,t.jsx)(n.li,{children:"The jobs' classical computation, such as compilation, is run in parallel. Thus, running multiple jobs in a batch is significantly faster than running them serially."}),"\n",(0,t.jsx)(n.li,{children:"There is usually minimal delay between jobs, which can help avoid drift."}),"\n",(0,t.jsx)(n.li,{children:"If you partition your workload into multiple jobs and run them in batch mode, you can get results from individual jobs, which makes them more flexible to work with. For example, if a job's results don't meet your expectations, you can cancel the remaining jobs. Also, if one job fails, you can re-submit it instead of re-running the entire workload."}),"\n",(0,t.jsx)(n.li,{children:"Is generally less expensive than sessions."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Session"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["All the functionality from batch mode (but requiring increased usage; see ",(0,t.jsx)(n.a,{href:"/guides/estimate-job-run-time#usage",children:"Workload usage"})," for more details on how usage is calculated)."]}),"\n",(0,t.jsx)(n.li,{children:"Dedicated and exclusive access to the QPU during the session active window."}),"\n",(0,t.jsx)(n.li,{children:"Useful for workloads that don\u2019t have all inputs ready at the outset, for iterative workloads that require classical post-processing before the next one can run, and for experiments that need to run as tightly together as possible."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Job"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Easiest to use when running a small experiment."}),"\n",(0,t.jsx)(n.li,{children:"Might run sooner than batch mode."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("span",{id:"best-practices"}),"\n",(0,t.jsx)(n.h2,{id:"recommendations-and-best-practices",children:"Recommendations and best practices"}),"\n",(0,t.jsx)(n.p,{children:"Generally, use batch mode unless you have workloads that don\u2019t have all inputs ready at the outset."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.strong,{children:"batch"})," mode to submit multiple primitive jobs simultaneously to shorten processing time."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.strong,{children:"session"})," mode for iterative workloads, or if you need dedicated access to the QPU."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Always use ",(0,t.jsx)(n.strong,{children:"job"})," mode to submit a single primitive request."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Because ",(0,t.jsx)(n.em,{children:"sessions are generally more expensive"}),", it is recommended that you use batch whenever you don't need the additional benefits from using sessions."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Open Plan users cannot submit session jobs."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To ensure the most efficient use of the execution modes, the following practices are recommended:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["There is a fixed overhead associated with running a job. In general, if each of your jobs uses less than one minute of ",(0,t.jsx)(n.em,{children:"QPU time"}),', consider combining several into one larger job (this applies to all execution modes). "QPU time" refers to time spent by the QPU complex to process your job.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["If each of your jobs consumes more than one minute of QPU time, or if combining jobs is not practical, you can still run multiple jobs in parallel. Every job goes through both classical and quantum processing. While a QPU can process only one job at a time, up to five classical jobs can be processed in parallel. You can take advantage of this by submitting multiple jobs in ",(0,t.jsx)(n.a,{href:"/guides/run-jobs-batch#partition",children:"batch"})," or ",(0,t.jsx)(n.a,{href:"/guides/run-jobs-session#two-vqe",children:"session"})," execution mode."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The above are general guidelines, and you should tune your workload to find the optimal ratio, especially when using sessions. For example, if you are using a session to get exclusive access to a backend, consider breaking up large jobs into smaller ones and running them in parallel. This might be more cost-effective because it can reduce wall-clock time."}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"run-a-quantum-variational-algorithm",children:"Run a quantum variational algorithm"}),"\n",(0,t.jsx)(n.p,{children:"Running a quantum variational algorithm typically follows this flow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Prepare the ansatz."}),"\n",(0,t.jsx)(n.li,{children:"Evaluate the cost function on a QPU."}),"\n",(0,t.jsx)(n.li,{children:"Take the result from the previous step and run it through a classical optimizer."}),"\n",(0,t.jsx)(n.li,{children:"Adjust the parameters according to the output of (3), then go back to step (2)."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In this case, if you were using job or batch mode, each job generated by step (2) needs to go back through the queue. This drastically increases the experiment length (wall-clock time) due to the queuing time. It could also take longer to converge due to device drift.  That is, every iteration is supposed give you a better result, but device drift could make subsequent results worse."}),"\n",(0,t.jsxs)(n.p,{children:["In addition, if you use ",(0,t.jsx)(n.a,{href:"/guides/error-mitigation-and-suppression-techniques#pea",children:"PEA"})," or ",(0,t.jsx)(n.a,{href:"/guides/error-mitigation-and-suppression-techniques#pec",children:"PEC"}),", you can ",(0,t.jsx)(n.a,{href:"/guides/noise-learning",children:"learn the noise model"})," once and apply it to subsequent jobs when running in dedicated session. This usually doesn't work with batch or job mode because the noise model could become stale by the time the next job is out of the queue."]}),"\n",(0,t.jsx)(n.h3,{id:"compare-error-mitigation-settings",children:"Compare error mitigation settings"}),"\n",(0,t.jsx)(n.p,{children:"To compare the effects of the available error mitigation methods, you might follow this flow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Construct a circuit and observable."}),"\n",(0,t.jsx)(n.li,{children:"Submit primitive jobs that use different combinations of error mitigation settings."}),"\n",(0,t.jsx)(n.li,{children:"Plot the results to observe the effects of the various settings."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In this case, all jobs (which are related but independent) are available at the outset. If you use batch mode, they are scheduled collectively so you only have to wait for them to go through the queue once.  Additionally, because the goal is to compare the effects of various error mitigation methods, it's beneficial that they run as closely together as possible. Thus, batch would be a good choice.  You ",(0,t.jsx)(n.em,{children:"could"})," run these jobs in a session, but because sessions are generally more expensive, it is recommended that you use batch whenever you don't need the additional functionality sessions provides."]}),"\n",(0,t.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsx)(i,{type:"tip",title:"Recommendations",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/guides/run-jobs-batch/",children:"Run a job in batch mode."})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/guides/run-jobs-session",children:"Run a job in session mode."})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/guides/estimate-job-run-time",children:"Workload usage."})}),"\n"]})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var s=i(96540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);