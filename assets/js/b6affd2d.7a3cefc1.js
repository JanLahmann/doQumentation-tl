"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[7074],{91223(e,i,s){s.r(i),s.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/job-limits","title":"Job limits","description":"Job limits imposed by the job validation service for jobs sent to IBM QPUs.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/job-limits.mdx","sourceDirName":"guides","slug":"/guides/job-limits","permalink":"/guides/job-limits","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/job-limits.mdx","tags":[],"version":"current","frontMatter":{"title":"Job limits","description":"Job limits imposed by the job validation service for jobs sent to IBM QPUs."},"sidebar":"tutorialsSidebar","previous":{"title":"Maximum execution time for Qiskit Runtime workloads","permalink":"/guides/max-execution-time"},"next":{"title":"Organize and search by job tags","permalink":"/guides/add-job-tags"}}');var n=s(74848),r=s(28453);const a={title:"Job limits",description:"Job limits imposed by the job validation service for jobs sent to IBM QPUs."},o="Job limits",l={},c=[{value:"Maximum executions",id:"maximum-executions",level:2},{value:"Maximum number of low-level instructions per qubit",id:"maximum-number-of-low-level-instructions-per-qubit",level:2},{value:"Example",id:"example",level:3},{value:"Maximum number of single- and two-qubit gates per circuit",id:"maximum-number-of-single--and-two-qubit-gates-per-circuit",level:2}];function d(e){const i={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Admonition:s}=i;return s||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"job-limits",children:"Job limits"})}),"\n",(0,n.jsx)(i.p,{children:"When you send a job to an IBM\xae QPU, it is first sent to the job validation service.  This service tries to ensure that the job will be able to run on the QPU so you don't have to wait for it to go through the queue and then have the job fail.  These checks include enforcing the following described limits. If these limits are exceeded, that workload cannot be handled by the quantum software stack and will usually fail."}),"\n",(0,n.jsx)(s,{type:"note",title:"Notes",children:(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Certain primitive options increase the circuit size.  The described limits are checked ",(0,n.jsx)(i.em,{children:"after"})," the expected increase in circuit size. In particular, these options increase circuit size:","\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Dynamical decoupling and gate-folding ZNE introduce additional gates that are included in the instructions for the ",(0,n.jsx)(i.a,{href:"#per-qubit",children:"Maximum number of low-level instructions per qubit"})," limit."]}),"\n",(0,n.jsxs)(i.li,{children:["Gate-folding ZNE introduces additional two-qubit gates relevant to the ",(0,n.jsx)(i.a,{href:"#2-qubit-limit",children:"Maximum number of two-qubit gates per job"})," limit. The number of two-qubit gates is multiplied by the sum of noise factors requested in gate-folding ZNE."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["The limits reported by the ",(0,n.jsx)(i.code,{children:"backend.configuration()"})," fields ",(0,n.jsx)(i.code,{children:"max_shots"})," and ",(0,n.jsx)(i.code,{children:"max_experiments"})," are no longer relevant or enforced. These fields will be removed in the near future."]}),"\n",(0,n.jsx)(i.li,{children:"These limits are per job, not per Primitive Unified Bloc (PUB)."}),"\n"]})}),"\n",(0,n.jsx)("span",{id:"max-shots"}),"\n",(0,n.jsx)(i.h2,{id:"maximum-executions",children:"Maximum executions"}),"\n",(0,n.jsxs)(i.p,{children:["At most, ",(0,n.jsx)(i.strong,{children:"10 million"})," executions are allowed for Sampler jobs (Estimator jobs can be split into smaller sub-jobs, so this limit doesn't apply).  The number of executions is the number of circuits times the number of shots, where the circuits are those generated after PUB elements are broadcasted."]}),"\n",(0,n.jsxs)(i.p,{children:["For example, if you have a PUB with one circuit and parameters with shape (4, 1), this would render 4 circuits. If you requested 2,000 shots, then the total number of executions is ",(0,n.jsxs)(i.span,{className:"katex",children:[(0,n.jsx)(i.span,{className:"katex-mathml",children:(0,n.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(i.semantics,{children:[(0,n.jsxs)(i.mrow,{children:[(0,n.jsx)(i.mn,{children:"4"}),(0,n.jsx)(i.mo,{children:"\xd7"}),(0,n.jsx)(i.mn,{children:"2"}),(0,n.jsx)(i.mo,{separator:"true",children:","}),(0,n.jsx)(i.mn,{children:"000"}),(0,n.jsx)(i.mo,{children:"="}),(0,n.jsx)(i.mn,{children:"8"}),(0,n.jsx)(i.mo,{separator:"true",children:","}),(0,n.jsx)(i.mn,{children:"000"})]}),(0,n.jsx)(i.annotation,{encoding:"application/x-tex",children:"4 \\times 2,000 = 8,000"})]})})}),(0,n.jsxs)(i.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,n.jsx)(i.span,{className:"mord",children:"4"}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(i.span,{className:"mbin",children:"\xd7"}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,n.jsx)(i.span,{className:"mord",children:"2"}),(0,n.jsx)(i.span,{className:"mpunct",children:","}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(i.span,{className:"mord",children:"000"}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(i.span,{className:"mrel",children:"="}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(i.span,{className:"base",children:[(0,n.jsx)(i.span,{className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,n.jsx)(i.span,{className:"mord",children:"8"}),(0,n.jsx)(i.span,{className:"mpunct",children:","}),(0,n.jsx)(i.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(i.span,{className:"mord",children:"000"})]})]})]}),"."]}),"\n",(0,n.jsxs)(i.p,{children:["Note that if you enable Pauli-twirling in your Sampler job, the total number of shots is based on the ",(0,n.jsx)(i.code,{children:"num_randomizations"})," and ",(0,n.jsx)(i.code,{children:"shots_per_randomization"})," values. See ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-twirling-options",children:"TwirlingOptions"})," for more details."]}),"\n",(0,n.jsx)("span",{id:"per-qubit"}),"\n",(0,n.jsx)(i.h2,{id:"maximum-number-of-low-level-instructions-per-qubit",children:"Maximum number of low-level instructions per qubit"}),"\n",(0,n.jsxs)(i.p,{children:["The service permits up to ",(0,n.jsx)(i.strong,{children:"26.8 million control-system instructions per qubit"}),". This ensures that the user circuits fit within the control system's instruction memory.  The below example shows how to transpile a circuit and count how many of each instruction there are."]}),"\n",(0,n.jsx)(i.p,{children:"The following table describes how the system translates instruction set architecture (ISA) circuit instructions to control system instructions when calculating this limit."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Instruction"}),(0,n.jsx)(i.th,{children:"Count"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"rz"})}),(0,n.jsx)(i.td,{children:"1"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"delay"})}),(0,n.jsx)(i.td,{children:"1"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"sx"})}),(0,n.jsx)(i.td,{children:"2"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"x"})}),(0,n.jsx)(i.td,{children:"2"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"cx"})}),(0,n.jsx)(i.td,{children:"5"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"cz"})}),(0,n.jsx)(i.td,{children:"5"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"ecr"})}),(0,n.jsx)(i.td,{children:"5"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"measure"})}),(0,n.jsx)(i.td,{children:"10"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"reset"})}),(0,n.jsx)(i.td,{children:"17"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.code,{children:"init"})}),(0,n.jsx)(i.td,{children:"50"})]})]})]}),"\n",(0,n.jsx)(s,{type:"note",children:(0,n.jsx)(i.p,{children:"This table captures the heuristic used in validation and does not reflect the exact number of instructions used to implement an operation."})}),"\n",(0,n.jsx)(i.h3,{id:"example",children:"Example"}),"\n",(0,n.jsx)(i.p,{children:"Define circuits, transpile them, and get a count of how many gates will be run."}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from qiskit import QuantumCircuit\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\nnum_qubits = 50\nghz = QuantumCircuit(num_qubits)\nghz.h(range(num_qubits))\nghz.cx(0, range(1, num_qubits))\nop_counts = ghz.count_ops()\n\n# Choose the least busy backend\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\npm = generate_preset_pass_manager(optimization_level=3, backend=backend)\ntranspiled_ghz = pm.run(ghz)\nop_counts = transpiled_ghz.count_ops()\n\nprint(f"Post-Transpilation gates: {op_counts}")\n'})}),"\n",(0,n.jsxs)(i.p,{children:["For full details, see ",(0,n.jsx)(i.a,{href:"/guides/custom-backend#ex-count-ops",children:"Transpile against custom backends."})]}),"\n",(0,n.jsx)("span",{id:"2-qubit-limit"}),"\n",(0,n.jsx)(i.h2,{id:"maximum-number-of-single--and-two-qubit-gates-per-circuit",children:"Maximum number of single- and two-qubit gates per circuit"}),"\n",(0,n.jsx)(i.p,{children:"The maximum number of single-qubit gates are as follows:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"30 million RZ gates"}),"\n",(0,n.jsx)(i.li,{children:"20 million SX gates"}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"The maximum number of two-qubit gates per circuit is five million. This ensures that the job can be manipulated within the memory limits of the low-level software stack."})]})}function m(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},28453(e,i,s){s.d(i,{R:()=>a,x:()=>o});var t=s(96540);const n={},r=t.createContext(n);function a(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);