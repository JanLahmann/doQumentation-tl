"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[963],{81147(I,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/function-template-hamiltonian-simulation","title":"Build a Qiskit Function template for Hamiltonian simulation","description":"How to create a parallel transpilation program and deploy it to IBM Quantum Platform to use as a reusable remote service.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/function-template-hamiltonian-simulation.mdx","sourceDirName":"guides","slug":"/guides/function-template-hamiltonian-simulation","permalink":"/guides/function-template-hamiltonian-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/function-template-hamiltonian-simulation.mdx","tags":[],"version":"current","frontMatter":{"title":"Build a Qiskit Function template for Hamiltonian simulation","sidebar_label":"Build a Qiskit Function template for Hamiltonian simulation","description":"How to create a parallel transpilation program and deploy it to IBM Quantum Platform to use as a reusable remote service.","notebook_path":"docs/guides/function-template-hamiltonian-simulation.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Build a Qiskit Function for chemistry simulation","permalink":"/guides/function-template-chemistry-workflow"},"next":{"title":"Introduction to Qiskit","permalink":"/guides/tools-intro"}}');var i=t(74848),a=t(28453);const r={title:"Build a Qiskit Function template for Hamiltonian simulation",sidebar_label:"Build a Qiskit Function template for Hamiltonian simulation",description:"How to create a parallel transpilation program and deploy it to IBM Quantum Platform to use as a reusable remote service.",notebook_path:"docs/guides/function-template-hamiltonian-simulation.ipynb"},s="Build a function template for Hamiltonian simulation",o={},l=[{value:"1. Collecting input and mapping the problem",id:"1-collecting-input-and-mapping-the-problem",level:4},{value:"2. Prepare the generated circuits for execution",id:"2-prepare-the-generated-circuits-for-execution",level:4},{value:"3. Execution",id:"3-execution",level:4},{value:"Write the function template",id:"write-the-function-template",level:2},{value:"Collect and validate the inputs",id:"collect-and-validate-the-inputs",level:3},{value:"Validate the inputs",id:"validate-the-inputs",level:4},{value:"Prepare the function outputs",id:"prepare-the-function-outputs",level:4},{value:"Map the problem and pre-process the circuit with AQC",id:"map-the-problem-and-pre-process-the-circuit-with-aqc",level:3},{value:"Optimize the final circuit for execution",id:"optimize-the-final-circuit-for-execution",level:3},{value:"Exit early if using dry run mode",id:"exit-early-if-using-dry-run-mode",level:4},{value:"Execute the circuit on hardware",id:"execute-the-circuit-on-hardware",level:4},{value:"Save the output",id:"save-the-output",level:4},{value:"Deploy the function to IBM Quantum Platform",id:"deploy-the-function-to-ibm-quantum-platform",level:2},{value:"Run the function template remotely",id:"run-the-function-template-remotely",level:2},{value:"Next steps",id:"next-steps",level:2}];function u(I){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,a.R)(),...I.components},{Admonition:t,Details:n,OpenInLabBanner:r}=e;return t||m("Admonition",!0),n||m("Details",!0),r||m("OpenInLabBanner",!0),(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsx)(e.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,i.jsx)(e.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,i.jsx)(r,{notebookPath:"docs/guides/function-template-hamiltonian-simulation.ipynb"}),"\n",(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"build-a-function-template-for-hamiltonian-simulation",children:"Build a function template for Hamiltonian simulation"})}),"\n",(0,i.jsxs)(e.p,{children:["This template encapsulates a workflow to simulate the time evolution of an initial state against a user defined spin-based Hamiltonian and returns a set of specified expectation values using the ",(0,i.jsx)(e.a,{href:"./qiskit-addons-aqc",children:"AQC addon"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"This template is structured as a Qiskit pattern with the following steps:"}),"\n",(0,i.jsx)(e.h4,{id:"1-collecting-input-and-mapping-the-problem",children:"1. Collecting input and mapping the problem"}),"\n",(0,i.jsxs)(e.p,{children:["This section takes as an input the Hamiltonian to simulate, an initial state in the form of a ",(0,i.jsx)(e.code,{children:"QuantumCircuit"}),", a set of observables to estimate expectation values, and a specification of options for the AQC addon. This step validates that all required input data is present and that they are in the correct format."]}),"\n",(0,i.jsx)(e.p,{children:"The input arguments are then used to construct the relevant quantum circuits and operators for the workflow. A target circuit is created and a matrix product state representation of this circuit is found using the AQC addon. Following this, an ansatz circuit is generated and optimized using tensor network methods, producing a final circuit which executes the remainder of the time evolution."}),"\n",(0,i.jsx)(e.h4,{id:"2-prepare-the-generated-circuits-for-execution",children:"2. Prepare the generated circuits for execution"}),"\n",(0,i.jsxs)(e.p,{children:["The generated circuits from the AQC addon are then transpiled to execute on a chosen backend. An ",(0,i.jsx)(e.a,{href:"../api/qiskit-ibm-runtime/estimator-v2",children:(0,i.jsx)(e.code,{children:"EstimatorV2"})})," instance is created with a default set of error mitigation options to manage the circuit execution."]}),"\n",(0,i.jsx)(e.h4,{id:"3-execution",children:"3. Execution"}),"\n",(0,i.jsx)(e.p,{children:"Finally, the ansatz circuit is transpiled and executed on a QPU and collects estimates for all of the specified expectation values, which are returned in a serializable format for access by the user."}),"\n",(0,i.jsx)(e.h2,{id:"write-the-function-template",children:"Write the function template"}),"\n",(0,i.jsxs)(e.p,{children:["First, write a function template for Hamiltonian simulation that uses the ",(0,i.jsx)(e.a,{href:"/guides/qiskit-addons-aqc",children:"AQC-Tensor Qiskit addon"})," to map the problem description to a reduced-depth circuit for execution on hardware."]}),"\n",(0,i.jsxs)(e.p,{children:["Throughout, the code is saved to\xa0",(0,i.jsx)(e.code,{children:"./source_files/template_hamiltonian_simulation.py"}),". This file is the function template you can upload to and run remotely with Qiskit Serverless."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q mergedeep qiskit-addon-aqc-tensor qiskit-serverless quimb\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# This cell is hidden from users, it just creates a new folder\nfrom pathlib import Path\n\nPath("./source_files").mkdir(exist_ok=True)\n'})}),"\n",(0,i.jsx)(e.h3,{id:"collect-and-validate-the-inputs",children:"Collect and validate the inputs"}),"\n",(0,i.jsx)(e.p,{children:"Start by getting the inputs for the template. This example has domain-specific inputs relevant for Hamiltonian simulation (such as the Hamiltonian and observable) and capability-specific options (such as how much you want to compress the initial layers of the Trotter circuit using AQC-Tensor, or advanced options for fine-tuning error suppression and mitigation beyond the defaults that are part of this example)."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile ./source_files/template_hamiltonian_simulation.py\n\nfrom qiskit import QuantumCircuit\nfrom qiskit_serverless import get_arguments, save_result\n\n# Extract parameters from arguments\n#\n# Do this at the top of the program so it fails early if any required arguments are missing or invalid.\n\narguments = get_arguments()\n\ndry_run = arguments.get("dry_run", False)\nbackend_name = arguments["backend_name"]\n\naqc_evolution_time = arguments["aqc_evolution_time"]\naqc_ansatz_num_trotter_steps = arguments["aqc_ansatz_num_trotter_steps"]\naqc_target_num_trotter_steps = arguments["aqc_target_num_trotter_steps"]\n\nremainder_evolution_time = arguments["remainder_evolution_time"]\nremainder_num_trotter_steps = arguments["remainder_num_trotter_steps"]\n\n# Stop if this fidelity is achieved\naqc_stopping_fidelity = arguments.get("aqc_stopping_fidelity", 1.0)\n# Stop after this number of iterations, even if stopping fidelity is not achieved\naqc_max_iterations = arguments.get("aqc_max_iterations", 500)\n\nhamiltonian = arguments["hamiltonian"]\nobservable = arguments["observable"]\ninitial_state = arguments.get("initial_state", QuantumCircuit(hamiltonian.num_qubits))\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Writing ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\nimport numpy as np\nimport json\nfrom mergedeep import merge\n\n# Configure `EstimatorOptions`, to control the parameters of the hardware experiment\n#\n# Set default options\nestimator_default_options = {\n    "resilience": {\n        "measure_mitigation": True,\n        "zne_mitigation": True,\n        "zne": {\n            "amplifier": "gate_folding",\n            "noise_factors": [1, 2, 3],\n            "extrapolated_noise_factors": list(np.linspace(0, 3, 31)),\n            "extrapolator": ["exponential", "linear", "fallback"],\n        },\n        "measure_noise_learning": {\n            "num_randomizations": 512,\n            "shots_per_randomization": 512,\n        },\n    },\n    "twirling": {\n        "enable_gates": True,\n        "enable_measure": True,\n        "num_randomizations": 300,\n        "shots_per_randomization": 100,\n        "strategy": "active",\n    },\n}\n# Merge with user-provided options\nestimator_options = merge(\n    arguments.get("estimator_options", {}), estimator_default_options\n)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsxs)(e.p,{children:["When the function template is running, it is helpful to return information in the logs by using print statements, so that you can better evaluate the workload's progress. Following is a simple example of printing the ",(0,i.jsx)(e.code,{children:"estimator_options"})," so  there is a record of the actual Estimator options used. There are many more similar examples throughout the program to report progress during execution, including the value of the objective function during the iterative component of AQC-Tensor, and the two-qubit depth of the final instruction set architecture (ISA) circuit intended for execution on hardware."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\nprint("estimator_options =", json.dumps(estimator_options, indent=4))\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h4,{id:"validate-the-inputs",children:"Validate the inputs"}),"\n",(0,i.jsx)(e.p,{children:"An important aspect of ensuring that the template can be reused across a range of inputs is input validation. The following code is an example of verifying that the stopping fidelity during AQC-Tensor has been specified appropriately and if not, returning an informative error message for how to fix the error."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\n# Perform parameter validation\n\nif not 0.0 < aqc_stopping_fidelity <= 1.0:\n    raise ValueError(\n        f"Invalid stopping fidelity: {aqc_stopping_fidelity}.  It must be a positive float no greater than 1."\n    )\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h4,{id:"prepare-the-function-outputs",children:"Prepare the function outputs"}),"\n",(0,i.jsx)(e.p,{children:"First, prepare a dictionary to hold all of the function template outputs. Keys will be added to this dictionary throughout the workflow, and it is returned at the end of the program."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\noutput = {}\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h3,{id:"map-the-problem-and-pre-process-the-circuit-with-aqc",children:"Map the problem and pre-process the circuit with AQC"}),"\n",(0,i.jsx)(e.p,{children:"The AQC-Tensor optimization happens in step 1 of a Qiskit pattern.  First, a target state is constructed.  In this example, it is constructed from a target circuit that evolves the same Hamiltonian for the same time period as the AQC portion.  Then, an ansatz is generated from an equivalent circuit but with fewer Trotter steps.  In the main portion of the AQC algorithm, that ansatz is iteratively brought closer to the target state.  Finally, the result is combined with the remainder of the Trotter steps needed to reach the desired evolution time."}),"\n",(0,i.jsx)(e.p,{children:"Note the additional examples of logging incorporated in the following code."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\nimport os\nos.environ["NUMBA_CACHE_DIR"] = "/data"\n\nimport datetime\nimport quimb.tensor\nfrom scipy.optimize import OptimizeResult, minimize\nfrom qiskit.synthesis import SuzukiTrotter\nfrom qiskit_addon_utils.problem_generators import generate_time_evolution_circuit\nfrom qiskit_addon_aqc_tensor.ansatz_generation import (\n    generate_ansatz_from_circuit,\n    AnsatzBlock,\n)\nfrom qiskit_addon_aqc_tensor.simulation import (\n    tensornetwork_from_circuit,\n    compute_overlap,\n)\nfrom qiskit_addon_aqc_tensor.simulation.quimb import QuimbSimulator\nfrom qiskit_addon_aqc_tensor.objective import OneMinusFidelity\n\nprint("Hamiltonian:", hamiltonian)\nprint("Observable:", observable)\nsimulator_settings = QuimbSimulator(quimb.tensor.CircuitMPS, autodiff_backend="jax")\n\n# Construct the AQC target circuit\naqc_target_circuit = initial_state.copy()\nif aqc_evolution_time:\n    aqc_target_circuit.compose(\n        generate_time_evolution_circuit(\n            hamiltonian,\n            synthesis=SuzukiTrotter(reps=aqc_target_num_trotter_steps),\n            time=aqc_evolution_time,\n        ),\n        inplace=True,\n    )\n\n# Construct matrix-product state representation of the AQC target state\naqc_target_mps = tensornetwork_from_circuit(aqc_target_circuit, simulator_settings)\nprint("Target MPS maximum bond dimension:", aqc_target_mps.psi.max_bond())\noutput["target_bond_dimension"] = aqc_target_mps.psi.max_bond()\n\n# Generate an ansatz and initial parameters from a Trotter circuit with fewer steps\naqc_good_circuit = initial_state.copy()\nif aqc_evolution_time:\n    aqc_good_circuit.compose(\n        generate_time_evolution_circuit(\n            hamiltonian,\n            synthesis=SuzukiTrotter(reps=aqc_ansatz_num_trotter_steps),\n            time=aqc_evolution_time,\n        ),\n        inplace=True,\n    )\naqc_ansatz, aqc_initial_parameters = generate_ansatz_from_circuit(aqc_good_circuit)\nprint("Number of AQC parameters:", len(aqc_initial_parameters))\noutput["num_aqc_parameters"] = len(aqc_initial_parameters)\n\n# Calculate the fidelity of ansatz circuit vs. the target state, before optimization\ngood_mps = tensornetwork_from_circuit(aqc_good_circuit, simulator_settings)\nstarting_fidelity = abs(compute_overlap(good_mps, aqc_target_mps)) ** 2\nprint("Starting fidelity of AQC portion:", starting_fidelity)\noutput["aqc_starting_fidelity"] = starting_fidelity\n\n# Optimize the ansatz parameters by using MPS calculations\ndef callback(intermediate_result: OptimizeResult):\n    fidelity = 1 - intermediate_result.fun\n    print(f"{datetime.datetime.now()} Intermediate result: Fidelity {fidelity:.8f}")\n    if intermediate_result.fun < stopping_point:\n        raise StopIteration\n\nobjective = OneMinusFidelity(aqc_target_mps, aqc_ansatz, simulator_settings)\nstopping_point = 1.0 - aqc_stopping_fidelity\n\nresult = minimize(\n    objective,\n    aqc_initial_parameters,\n    method="L-BFGS-B",\n    jac=True,\n    options={"maxiter": aqc_max_iterations},\n    callback=callback,\n)\nif result.status not in (\n    0,\n    1,\n    99,\n):  # 0 => success; 1 => max iterations reached; 99 => early termination via StopIteration\n    raise RuntimeError(\n        f"Optimization failed: {result.message} (status={result.status})"\n    )\nprint(f"Done after {result.nit} iterations.")\noutput["num_iterations"] = result.nit\naqc_final_parameters = result.x\noutput["aqc_final_parameters"] = list(aqc_final_parameters)\n\n# Construct an optimized circuit for initial portion of time evolution\naqc_final_circuit = aqc_ansatz.assign_parameters(aqc_final_parameters)\n\n# Calculate fidelity after optimization\naqc_final_mps = tensornetwork_from_circuit(aqc_final_circuit, simulator_settings)\naqc_fidelity = abs(compute_overlap(aqc_final_mps, aqc_target_mps)) ** 2\nprint("Fidelity of AQC portion:", aqc_fidelity)\noutput["aqc_fidelity"] = aqc_fidelity\n\n# Construct final circuit, with remainder of time evolution\nfinal_circuit = aqc_final_circuit.copy()\nif remainder_evolution_time:\n    remainder_circuit = generate_time_evolution_circuit(\n        hamiltonian,\n        synthesis=SuzukiTrotter(reps=remainder_num_trotter_steps),\n        time=remainder_evolution_time,\n    )\n    final_circuit.compose(remainder_circuit, inplace=True)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h3,{id:"optimize-the-final-circuit-for-execution",children:"Optimize the final circuit for execution"}),"\n",(0,i.jsxs)(e.p,{children:["After the AQC portion of the workflow, the ",(0,i.jsx)(e.code,{children:"final_circuit"})," is ",(0,i.jsx)(e.a,{href:"/guides/transpile#instruction-set-architecture",children:"transpiled for the hardware"})," as usual."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit.transpiler import generate_preset_pass_manager\n\nservice = QiskitRuntimeService()\nbackend = service.backend(backend_name)\n\n# Transpile PUBs (circuits and observables) to match ISA\npass_manager = generate_preset_pass_manager(backend=backend, optimization_level=3)\nisa_circuit = pass_manager.run(final_circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\n\nisa_2qubit_depth = isa_circuit.depth(lambda x: x.operation.num_qubits == 2)\nprint("ISA circuit two-qubit depth:", isa_2qubit_depth)\noutput["twoqubit_depth"] = isa_2qubit_depth\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h4,{id:"exit-early-if-using-dry-run-mode",children:"Exit early if using dry run mode"}),"\n",(0,i.jsx)(e.p,{children:"If dry run mode has been selected, then the program is stopped before executing on hardware. This can be useful if, for example, you want first to inspect the two-qubit depth of the ISA circuit before deciding to execute on hardware."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\n# Exit now if dry run; don\'t execute on hardware\nif dry_run:\n    import sys\n\n    print("Exiting before hardware execution since `dry_run` is True.")\n    save_result(output)\n    sys.exit(0)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h4,{id:"execute-the-circuit-on-hardware",children:"Execute the circuit on hardware"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\n# ## Step 3: Execute quantum experiments on backend\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nestimator = Estimator(backend, options=estimator_options)\n\n# Submit the underlying Estimator job. Note that this is not the\n# actual function job.\njob = estimator.run([(isa_circuit, isa_observable)])\nprint("Job ID:", job.job_id())\noutput["job_id"] = job.job_id()\n\n# Wait until job is complete\nhw_results = job.result()\nhw_results_dicts = [pub_result.data.__dict__ for pub_result in hw_results]\n\n# Save hardware results to serverless output dictionary\noutput["hw_results"] = hw_results_dicts\n\n# Reorganize expectation values\nhw_expvals = [pub_result_data["evs"].tolist() for pub_result_data in hw_results_dicts]\n\n# Save expectation values to Qiskit Serverless\nprint("Hardware expectation values", hw_expvals)\noutput["hw_expvals"] = hw_expvals[0]\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h4,{id:"save-the-output",children:"Save the output"}),"\n",(0,i.jsx)(e.p,{children:"This function template returns the relevant domain-level output for this Hamiltonian simulation workflow (expectation values) in addition to important metadata generated along the way."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"%%writefile --append ./source_files/template_hamiltonian_simulation.py\n\nsave_result(output)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Appending to ./source_files/template_hamiltonian_simulation.py\n"})}),"\n",(0,i.jsx)(e.h2,{id:"deploy-the-function-to-ibm-quantum-platform",children:"Deploy the function to IBM Quantum Platform"}),"\n",(0,i.jsx)(e.p,{children:"The previous section created a program to be run remotely. The code in this section uploads that program to Qiskit Serverless."}),"\n",(0,i.jsxs)(e.p,{children:["Use ",(0,i.jsx)(e.code,{children:"qiskit-ibm-catalog"})," to authenticate to ",(0,i.jsx)(e.code,{children:"QiskitServerless"})," with your API key, which you can find on the ",(0,i.jsx)(e.a,{href:"https://quantum.cloud.ibm.com",children:"IBM Quantum Platform"})," dashboard, and upload the program."]}),"\n",(0,i.jsxs)(e.p,{children:["You can optionally use ",(0,i.jsx)(e.code,{children:"save_account()"})," to save your credentials (see the ",(0,i.jsx)(e.a,{href:"/guides/cloud-setup#cloud-save",children:"Set up your IBM Cloud account"})," guide). Note that this writes your credentials to the same file as ",(0,i.jsxs)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/qiskit-runtime-service#save_account",children:[(0,i.jsx)(e.code,{children:"QiskitRuntimeService.save_account()"}),"."]})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from qiskit_ibm_catalog import QiskitServerless, QiskitFunction\n\n# Authenticate to the remote cluster and submit the pattern for remote execution\nserverless = QiskitServerless()\n"})}),"\n",(0,i.jsxs)(e.p,{children:["This program has custom ",(0,i.jsx)(e.code,{children:"pip"})," dependencies.  Add them to a ",(0,i.jsx)(e.code,{children:"dependencies"})," array when constructing the ",(0,i.jsx)(e.code,{children:"QiskitFunction"})," instance:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'template = QiskitFunction(\n    title="template_hamiltonian_simulation",\n    entrypoint="template_hamiltonian_simulation.py",\n    working_dir="./source_files/",\n    dependencies=[\n        "qiskit-addon-utils~=0.1.0",\n        "qiskit-addon-aqc-tensor[quimb-jax]~=0.1.2",\n        "mergedeep==1.3.4",\n    ],\n)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"serverless.upload(template)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"QiskitFunction(template_hamiltonian_simulation)\n"})}),"\n",(0,i.jsxs)(e.p,{children:["Finally, check if the program successfully uploaded, use ",(0,i.jsx)(e.code,{children:"serverless.list()"}),":"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"serverless.list()\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"QiskitFunction(template_hamiltonian_simulation),\n"})}),"\n",(0,i.jsx)(e.h2,{id:"run-the-function-template-remotely",children:"Run the function template remotely"}),"\n",(0,i.jsx)(e.p,{children:"The function template has been uploaded, so you can run it remotely with Qiskit Serverless. First, load the template by name:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'template = serverless.load("template_hamiltonian_simulation")\n'})}),"\n",(0,i.jsx)(e.p,{children:"Next, run the template with the domain-level inputs for Hamiltonian simulation. This example specifies a 50-qubit XXZ model with random couplings, and an initial state and observable."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'from itertools import chain\nimport numpy as np\nfrom qiskit.quantum_info import SparsePauliOp\n\nL = 50\n\n# Generate the edge list for this spin-chain\nedges = [(i, i + 1) for i in range(L - 1)]\n# Generate an edge-coloring so we can make hw-efficient circuits\nedges = edges[::2] + edges[1::2]\n\n# Generate random coefficients for our XXZ Hamiltonian\nnp.random.seed(0)\nJs = np.random.rand(L - 1) + 0.5 * np.ones(L - 1)\n\nhamiltonian = SparsePauliOp.from_sparse_list(\n    chain.from_iterable(\n        [\n            [\n                ("XX", (i, j), Js[i] / 2),\n                ("YY", (i, j), Js[i] / 2),\n                ("ZZ", (i, j), Js[i]),\n            ]\n            for i, j in edges\n        ]\n    ),\n    num_qubits=L,\n)\nobservable = SparsePauliOp.from_sparse_list(\n    [("ZZ", (L // 2 - 1, L // 2), 1.0)], num_qubits=L\n)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"from qiskit import QuantumCircuit\n\ninitial_state = QuantumCircuit(L)\nfor i in range(L):\n    if i % 2:\n        initial_state.x(i)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'job = template.run(\n    dry_run=True,\n    initial_state=initial_state,\n    hamiltonian=hamiltonian,\n    observable=observable,\n    backend_name="ibm_fez",\n    estimator_options={},\n    aqc_evolution_time=0.2,\n    aqc_ansatz_num_trotter_steps=1,\n    aqc_target_num_trotter_steps=32,\n    remainder_evolution_time=0.2,\n    remainder_num_trotter_steps=4,\n    aqc_max_iterations=300,\n)\nprint(job.job_id)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"853b0edb-d63f-4629-be71-398b6dcf33cb\n"})}),"\n",(0,i.jsx)(e.p,{children:"Check the status of the job:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"job.status()\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"'QUEUED'\n"})}),"\n",(0,i.jsxs)(e.p,{children:["After the job is running, you can fetch logs created from the ",(0,i.jsx)(e.code,{children:"print()"})," outputs. These can provide actionable information about the progress of the Hamiltonian simulation workflow. For example, the value of the objective function during the iterative component of AQC, or the two-qubit depth of the final ISA circuit intended for execution on hardware."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"print(job.logs())\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"No logs yet.\n"})}),"\n",(0,i.jsx)(e.p,{children:"Block the rest of the program until a result is available. After the job is done, you can retrieve the results. These include the domain-level output of Hamiltonian simulation (expectation value) and useful metadata."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'result = job.result()\n\ndel result[\n    "aqc_final_parameters"\n]  # the list is too long to conveniently display here\nresult\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"{'target_bond_dimension': 5,\n 'num_aqc_parameters': 816,\n 'aqc_starting_fidelity': 0.9914382555614002,\n 'num_iterations': 72,\n 'aqc_fidelity': 0.9998108844412502,\n 'twoqubit_depth': 33}\n"})}),"\n",(0,i.jsx)(e.p,{children:"After the job completes, the entire logging output will be available."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"print(job.logs())\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"2024-12-17 14:50:15,580\tINFO job_manager.py:531 -- Runtime env is setting up.\nestimator_options = {\n    \"resilience\": {\n        \"measure_mitigation\": true,\n        \"zne_mitigation\": true,\n        \"zne\": {\n            \"amplifier\": \"gate_folding\",\n            \"noise_factors\": [\n                1,\n                2,\n                3\n            ],\n            \"extrapolated_noise_factors\": [\n                0.0,\n                0.1,\n                0.2,\n                0.30000000000000004,\n                0.4,\n                0.5,\n                0.6000000000000001,\n                0.7000000000000001,\n                0.8,\n                0.9,\n                1.0,\n                1.1,\n                1.2000000000000002,\n                1.3,\n                1.4000000000000001,\n                1.5,\n                1.6,\n                1.7000000000000002,\n                1.8,\n                1.9000000000000001,\n                2.0,\n                2.1,\n                2.2,\n                2.3000000000000003,\n                2.4000000000000004,\n                2.5,\n                2.6,\n                2.7,\n                2.8000000000000003,\n                2.9000000000000004,\n                3.0\n            ],\n            \"extrapolator\": [\n                \"exponential\",\n                \"linear\",\n                \"fallback\"\n            ]\n        },\n        \"measure_noise_learning\": {\n            \"num_randomizations\": 512,\n            \"shots_per_randomization\": 512\n        }\n    },\n    \"twirling\": {\n        \"enable_gates\": true,\n        \"enable_measure\": true,\n        \"num_randomizations\": 300,\n        \"shots_per_randomization\": 100,\n        \"strategy\": \"active\"\n    }\n}\nHamiltonian: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXX', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYY', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZ', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'XXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'YYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'ZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXI', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYI', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZI', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IIIZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IXXIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IYYIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII', 'IZZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],\n              coeffs=[0.52440675+0.j, 0.52440675+0.j, 1.0488135 +0.j, 0.55138169+0.j,\n 0.55138169+0.j, 1.10276338+0.j, 0.4618274 +0.j, 0.4618274 +0.j,\n 0.9236548 +0.j, 0.46879361+0.j, 0.46879361+0.j, 0.93758721+0.j,\n 0.73183138+0.j, 0.73183138+0.j, 1.46366276+0.j, 0.64586252+0.j,\n 0.64586252+0.j, 1.29172504+0.j, 0.53402228+0.j, 0.53402228+0.j,\n 1.06804456+0.j, 0.28551803+0.j, 0.28551803+0.j, 0.57103606+0.j,\n 0.2601092 +0.j, 0.2601092 +0.j, 0.5202184 +0.j, 0.63907838+0.j,\n 0.63907838+0.j, 1.27815675+0.j, 0.73930917+0.j, 0.73930917+0.j,\n 1.47861834+0.j, 0.48073968+0.j, 0.48073968+0.j, 0.96147936+0.j,\n 0.30913721+0.j, 0.30913721+0.j, 0.61827443+0.j, 0.32167664+0.j,\n 0.32167664+0.j, 0.64335329+0.j, 0.51092416+0.j, 0.51092416+0.j,\n 1.02184832+0.j, 0.38227781+0.j, 0.38227781+0.j, 0.76455561+0.j,\n 0.47807517+0.j, 0.47807517+0.j, 0.95615033+0.j, 0.2593949 +0.j,\n 0.2593949 +0.j, 0.5187898 +0.j, 0.55604786+0.j, 0.55604786+0.j,\n 1.11209572+0.j, 0.72187404+0.j, 0.72187404+0.j, 1.44374808+0.j,\n 0.42975395+0.j, 0.42975395+0.j, 0.8595079 +0.j, 0.5988156 +0.j,\n 0.5988156 +0.j, 1.1976312 +0.j, 0.58338336+0.j, 0.58338336+0.j,\n 1.16676672+0.j, 0.35519128+0.j, 0.35519128+0.j, 0.71038256+0.j,\n 0.40771418+0.j, 0.40771418+0.j, 0.81542835+0.j, 0.60759468+0.j,\n 0.60759468+0.j, 1.21518937+0.j, 0.52244159+0.j, 0.52244159+0.j,\n 1.04488318+0.j, 0.57294706+0.j, 0.57294706+0.j, 1.14589411+0.j,\n 0.6958865 +0.j, 0.6958865 +0.j, 1.391773  +0.j, 0.44172076+0.j,\n 0.44172076+0.j, 0.88344152+0.j, 0.51444746+0.j, 0.51444746+0.j,\n 1.02889492+0.j, 0.71279832+0.j, 0.71279832+0.j, 1.42559664+0.j,\n 0.29356465+0.j, 0.29356465+0.j, 0.5871293 +0.j, 0.66630992+0.j,\n 0.66630992+0.j, 1.33261985+0.j, 0.68500607+0.j, 0.68500607+0.j,\n 1.37001215+0.j, 0.64957928+0.j, 0.64957928+0.j, 1.29915856+0.j,\n 0.64026459+0.j, 0.64026459+0.j, 1.28052918+0.j, 0.56996051+0.j,\n 0.56996051+0.j, 1.13992102+0.j, 0.72233446+0.j, 0.72233446+0.j,\n 1.44466892+0.j, 0.45733097+0.j, 0.45733097+0.j, 0.91466194+0.j,\n 0.63711684+0.j, 0.63711684+0.j, 1.27423369+0.j, 0.53421697+0.j,\n 0.53421697+0.j, 1.06843395+0.j, 0.55881775+0.j, 0.55881775+0.j,\n 1.1176355 +0.j, 0.558467  +0.j, 0.558467  +0.j, 1.116934  +0.j,\n 0.59091015+0.j, 0.59091015+0.j, 1.1818203 +0.j, 0.46851598+0.j,\n 0.46851598+0.j, 0.93703195+0.j, 0.28011274+0.j, 0.28011274+0.j,\n 0.56022547+0.j, 0.58531893+0.j, 0.58531893+0.j, 1.17063787+0.j,\n 0.31446315+0.j, 0.31446315+0.j, 0.6289263 +0.j])\nObservable: SparsePauliOp(['IIIIIIIIIIIIIIIIIIIIIIIIZZIIIIIIIIIIIIIIIIIIIIIIII'],\n              coeffs=[1.+0.j])\nTarget MPS maximum bond dimension: 5\nNumber of AQC parameters: 816\nStarting fidelity of AQC portion: 0.9914382555614002\n2024-12-17 14:52:23.400028 Intermediate result: Fidelity 0.99764093\n2024-12-17 14:52:23.429669 Intermediate result: Fidelity 0.99788003\n2024-12-17 14:52:23.459674 Intermediate result: Fidelity 0.99795970\n2024-12-17 14:52:23.489666 Intermediate result: Fidelity 0.99799067\n2024-12-17 14:52:23.518545 Intermediate result: Fidelity 0.99803401\n2024-12-17 14:52:23.546952 Intermediate result: Fidelity 0.99809821\n2024-12-17 14:52:23.575271 Intermediate result: Fidelity 0.99824660\n2024-12-17 14:52:23.604049 Intermediate result: Fidelity 0.99845326\n2024-12-17 14:52:23.632709 Intermediate result: Fidelity 0.99870497\n2024-12-17 14:52:23.660527 Intermediate result: Fidelity 0.99891442\n2024-12-17 14:52:23.688273 Intermediate result: Fidelity 0.99904488\n2024-12-17 14:52:23.716105 Intermediate result: Fidelity 0.99914438\n2024-12-17 14:52:23.744336 Intermediate result: Fidelity 0.99922827\n2024-12-17 14:52:23.773399 Intermediate result: Fidelity 0.99929071\n2024-12-17 14:52:23.801482 Intermediate result: Fidelity 0.99932432\n2024-12-17 14:52:23.830466 Intermediate result: Fidelity 0.99936460\n2024-12-17 14:52:23.860738 Intermediate result: Fidelity 0.99938891\n2024-12-17 14:52:23.889958 Intermediate result: Fidelity 0.99940607\n2024-12-17 14:52:23.918703 Intermediate result: Fidelity 0.99941965\n2024-12-17 14:52:23.949744 Intermediate result: Fidelity 0.99944337\n2024-12-17 14:52:23.980871 Intermediate result: Fidelity 0.99946875\n2024-12-17 14:52:24.012124 Intermediate result: Fidelity 0.99949009\n2024-12-17 14:52:24.044359 Intermediate result: Fidelity 0.99952191\n2024-12-17 14:52:24.075840 Intermediate result: Fidelity 0.99953669\n2024-12-17 14:52:24.106303 Intermediate result: Fidelity 0.99955242\n2024-12-17 14:52:24.139329 Intermediate result: Fidelity 0.99958412\n2024-12-17 14:52:24.169725 Intermediate result: Fidelity 0.99960176\n2024-12-17 14:52:24.198749 Intermediate result: Fidelity 0.99961606\n2024-12-17 14:52:24.227874 Intermediate result: Fidelity 0.99963811\n2024-12-17 14:52:24.256818 Intermediate result: Fidelity 0.99964383\n2024-12-17 14:52:24.285889 Intermediate result: Fidelity 0.99964717\n2024-12-17 14:52:24.315228 Intermediate result: Fidelity 0.99966064\n2024-12-17 14:52:24.345322 Intermediate result: Fidelity 0.99966517\n2024-12-17 14:52:24.374921 Intermediate result: Fidelity 0.99967089\n2024-12-17 14:52:24.404309 Intermediate result: Fidelity 0.99968305\n2024-12-17 14:52:24.432664 Intermediate result: Fidelity 0.99968889\n2024-12-17 14:52:24.461639 Intermediate result: Fidelity 0.99969997\n2024-12-17 14:52:24.491244 Intermediate result: Fidelity 0.99971666\n2024-12-17 14:52:24.520354 Intermediate result: Fidelity 0.99972441\n2024-12-17 14:52:24.549965 Intermediate result: Fidelity 0.99973561\n2024-12-17 14:52:24.583464 Intermediate result: Fidelity 0.99973811\n2024-12-17 14:52:24.617537 Intermediate result: Fidelity 0.99974074\n2024-12-17 14:52:24.652247 Intermediate result: Fidelity 0.99974467\n2024-12-17 14:52:24.686831 Intermediate result: Fidelity 0.99974991\n2024-12-17 14:52:24.725476 Intermediate result: Fidelity 0.99975230\n2024-12-17 14:52:24.764637 Intermediate result: Fidelity 0.99975373\n2024-12-17 14:52:24.802499 Intermediate result: Fidelity 0.99975552\n2024-12-17 14:52:24.839960 Intermediate result: Fidelity 0.99975885\n2024-12-17 14:52:24.877472 Intermediate result: Fidelity 0.99976469\n2024-12-17 14:52:24.916233 Intermediate result: Fidelity 0.99976517\n2024-12-17 14:52:24.993750 Intermediate result: Fidelity 0.99976875\n2024-12-17 14:52:25.034953 Intermediate result: Fidelity 0.99976887\n2024-12-17 14:52:25.076197 Intermediate result: Fidelity 0.99977244\n2024-12-17 14:52:25.112340 Intermediate result: Fidelity 0.99977638\n2024-12-17 14:52:25.149947 Intermediate result: Fidelity 0.99977828\n2024-12-17 14:52:25.190049 Intermediate result: Fidelity 0.99978174\n2024-12-17 14:52:25.310903 Intermediate result: Fidelity 0.99978222\n2024-12-17 14:52:25.347512 Intermediate result: Fidelity 0.99978508\n2024-12-17 14:52:25.385201 Intermediate result: Fidelity 0.99978543\n2024-12-17 14:52:25.457436 Intermediate result: Fidelity 0.99978770\n2024-12-17 14:52:25.497133 Intermediate result: Fidelity 0.99978818\n2024-12-17 14:52:25.541179 Intermediate result: Fidelity 0.99978913\n2024-12-17 14:52:25.584791 Intermediate result: Fidelity 0.99978937\n2024-12-17 14:52:25.621484 Intermediate result: Fidelity 0.99979068\n2024-12-17 14:52:25.655847 Intermediate result: Fidelity 0.99979211\n2024-12-17 14:52:25.691710 Intermediate result: Fidelity 0.99979700\n2024-12-17 14:52:25.767711 Intermediate result: Fidelity 0.99979759\n2024-12-17 14:52:25.804517 Intermediate result: Fidelity 0.99979807\n2024-12-17 14:52:25.839394 Intermediate result: Fidelity 0.99980236\n2024-12-17 14:52:25.874438 Intermediate result: Fidelity 0.99980296\n2024-12-17 14:52:25.909900 Intermediate result: Fidelity 0.99980320\n2024-12-17 14:52:26.713044 Intermediate result: Fidelity 0.99980320\nDone after 72 iterations.\nFidelity of AQC portion: 0.9998108844412502\nISA circuit two-qubit depth: 33\nExiting before hardware execution since `dry_run` is True.\n"})}),"\n",(0,i.jsx)(e.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsx)(t,{type:"info",title:"Recommendations",children:(0,i.jsxs)(e.p,{children:["For a deeper dive into the AQC-Tensor Qiskit addon, check out the ",(0,i.jsx)(e.a,{href:"/tutorials/approximate-quantum-compilation-for-time-evolution",children:"Improved Trotterized Time Evolution with Approximate Quantum Compilation"})," tutorial or the ",(0,i.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-aqc-tensor",children:"qiskit-addon-aqc-tensor repository"}),"."]})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'%%writefile ./source_files/template_hamiltonian_simulation_full.py\n\nfrom qiskit import QuantumCircuit\nfrom qiskit_serverless import get_arguments, save_result\n\n# Extract parameters from arguments\n#\n# Do this at the top of the program so it fails early if any required arguments are missing or invalid.\n\narguments = get_arguments()\n\ndry_run = arguments.get("dry_run", False)\nbackend_name = arguments["backend_name"]\n\naqc_evolution_time = arguments["aqc_evolution_time"]\naqc_ansatz_num_trotter_steps = arguments["aqc_ansatz_num_trotter_steps"]\naqc_target_num_trotter_steps = arguments["aqc_target_num_trotter_steps"]\n\nremainder_evolution_time = arguments["remainder_evolution_time"]\nremainder_num_trotter_steps = arguments["remainder_num_trotter_steps"]\n\n# Stop if this fidelity is achieved\naqc_stopping_fidelity = arguments.get("aqc_stopping_fidelity", 1.0)\n# Stop after this number of iterations, even if stopping fidelity is not achieved\naqc_max_iterations = arguments.get("aqc_max_iterations", 500)\n\nhamiltonian = arguments["hamiltonian"]\nobservable = arguments["observable"]\ninitial_state = arguments.get("initial_state", QuantumCircuit(hamiltonian.num_qubits))\n\nimport numpy as np\nimport json\nfrom mergedeep import merge\n\n# Configure `EstimatorOptions`, to control the parameters of the hardware experiment\n#\n# Set default options\nestimator_default_options = {\n    "resilience": {\n        "measure_mitigation": True,\n        "zne_mitigation": True,\n        "zne": {\n            "amplifier": "gate_folding",\n            "noise_factors": [1, 2, 3],\n            "extrapolated_noise_factors": list(np.linspace(0, 3, 31)),\n            "extrapolator": ["exponential", "linear", "fallback"],\n        },\n        "measure_noise_learning": {\n            "num_randomizations": 512,\n            "shots_per_randomization": 512,\n        },\n    },\n    "twirling": {\n        "enable_gates": True,\n        "enable_measure": True,\n        "num_randomizations": 300,\n        "shots_per_randomization": 100,\n        "strategy": "active",\n    },\n}\n# Merge with user-provided options\nestimator_options = merge(\n    arguments.get("estimator_options", {}), estimator_default_options\n)\n\nprint("estimator_options =", json.dumps(estimator_options, indent=4))\n\n# Perform parameter validation\n\nif not 0.0 < aqc_stopping_fidelity <= 1.0:\n    raise ValueError(\n        f"Invalid stopping fidelity: {aqc_stopping_fidelity}.  It must be a positive float no greater than 1."\n    )\n\noutput = {}\n\nimport os\nos.environ["NUMBA_CACHE_DIR"] = "/data"\n\nimport datetime\nimport quimb.tensor\nfrom scipy.optimize import OptimizeResult, minimize\nfrom qiskit.synthesis import SuzukiTrotter\nfrom qiskit_addon_utils.problem_generators import generate_time_evolution_circuit\nfrom qiskit_addon_aqc_tensor.ansatz_generation import (\n    generate_ansatz_from_circuit,\n    AnsatzBlock,\n)\nfrom qiskit_addon_aqc_tensor.simulation import (\n    tensornetwork_from_circuit,\n    compute_overlap,\n)\nfrom qiskit_addon_aqc_tensor.simulation.quimb import QuimbSimulator\nfrom qiskit_addon_aqc_tensor.objective import OneMinusFidelity\n\nprint("Hamiltonian:", hamiltonian)\nprint("Observable:", observable)\nsimulator_settings = QuimbSimulator(quimb.tensor.CircuitMPS, autodiff_backend="jax")\n\n# Construct the AQC target circuit\naqc_target_circuit = initial_state.copy()\nif aqc_evolution_time:\n    aqc_target_circuit.compose(\n        generate_time_evolution_circuit(\n            hamiltonian,\n            synthesis=SuzukiTrotter(reps=aqc_target_num_trotter_steps),\n            time=aqc_evolution_time,\n        ),\n        inplace=True,\n    )\n\n# Construct matrix-product state representation of the AQC target state\naqc_target_mps = tensornetwork_from_circuit(aqc_target_circuit, simulator_settings)\nprint("Target MPS maximum bond dimension:", aqc_target_mps.psi.max_bond())\noutput["target_bond_dimension"] = aqc_target_mps.psi.max_bond()\n\n# Generate an ansatz and initial parameters from a Trotter circuit with fewer steps\naqc_good_circuit = initial_state.copy()\nif aqc_evolution_time:\n    aqc_good_circuit.compose(\n        generate_time_evolution_circuit(\n            hamiltonian,\n            synthesis=SuzukiTrotter(reps=aqc_ansatz_num_trotter_steps),\n            time=aqc_evolution_time,\n        ),\n        inplace=True,\n    )\naqc_ansatz, aqc_initial_parameters = generate_ansatz_from_circuit(aqc_good_circuit)\nprint("Number of AQC parameters:", len(aqc_initial_parameters))\noutput["num_aqc_parameters"] = len(aqc_initial_parameters)\n\n# Calculate the fidelity of ansatz circuit vs. the target state, before optimization\ngood_mps = tensornetwork_from_circuit(aqc_good_circuit, simulator_settings)\nstarting_fidelity = abs(compute_overlap(good_mps, aqc_target_mps)) ** 2\nprint("Starting fidelity of AQC portion:", starting_fidelity)\noutput["aqc_starting_fidelity"] = starting_fidelity\n\n# Optimize the ansatz parameters by using MPS calculations\ndef callback(intermediate_result: OptimizeResult):\n    fidelity = 1 - intermediate_result.fun\n    print(f"{datetime.datetime.now()} Intermediate result: Fidelity {fidelity:.8f}")\n    if intermediate_result.fun < stopping_point:\n        raise StopIteration\n\nobjective = OneMinusFidelity(aqc_target_mps, aqc_ansatz, simulator_settings)\nstopping_point = 1.0 - aqc_stopping_fidelity\n\nresult = minimize(\n    objective,\n    aqc_initial_parameters,\n    method="L-BFGS-B",\n    jac=True,\n    options={"maxiter": aqc_max_iterations},\n    callback=callback,\n)\nif result.status not in (\n    0,\n    1,\n    99,\n):  # 0 => success; 1 => max iterations reached; 99 => early termination via StopIteration\n    raise RuntimeError(\n        f"Optimization failed: {result.message} (status={result.status})"\n    )\nprint(f"Done after {result.nit} iterations.")\noutput["num_iterations"] = result.nit\naqc_final_parameters = result.x\noutput["aqc_final_parameters"] = list(aqc_final_parameters)\n\n# Construct an optimized circuit for initial portion of time evolution\naqc_final_circuit = aqc_ansatz.assign_parameters(aqc_final_parameters)\n\n# Calculate fidelity after optimization\naqc_final_mps = tensornetwork_from_circuit(aqc_final_circuit, simulator_settings)\naqc_fidelity = abs(compute_overlap(aqc_final_mps, aqc_target_mps)) ** 2\nprint("Fidelity of AQC portion:", aqc_fidelity)\noutput["aqc_fidelity"] = aqc_fidelity\n\n# Construct final circuit, with remainder of time evolution\nfinal_circuit = aqc_final_circuit.copy()\nif remainder_evolution_time:\n    remainder_circuit = generate_time_evolution_circuit(\n        hamiltonian,\n        synthesis=SuzukiTrotter(reps=remainder_num_trotter_steps),\n        time=remainder_evolution_time,\n    )\n    final_circuit.compose(remainder_circuit, inplace=True)\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit.transpiler import generate_preset_pass_manager\n\nservice = QiskitRuntimeService()\nbackend = service.backend(backend_name)\n\n# Transpile PUBs (circuits and observables) to match ISA\npass_manager = generate_preset_pass_manager(backend=backend, optimization_level=3)\nisa_circuit = pass_manager.run(final_circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\n\nisa_2qubit_depth = isa_circuit.depth(lambda x: x.operation.num_qubits == 2)\nprint("ISA circuit two-qubit depth:", isa_2qubit_depth)\noutput["twoqubit_depth"] = isa_2qubit_depth\n\n# Exit now if dry run; don\'t execute on hardware\nif dry_run:\n    import sys\n\n    print("Exiting before hardware execution since `dry_run` is True.")\n    save_result(output)\n    sys.exit(0)\n\n# ## Step 3: Execute quantum experiments on backend\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nestimator = Estimator(backend, options=estimator_options)\n\n# Submit the underlying Estimator job. Note that this is not the\n# actual function job.\njob = estimator.run([(isa_circuit, isa_observable)])\nprint("Job ID:", job.job_id())\noutput["job_id"] = job.job_id()\n\n# Wait until job is complete\nhw_results = job.result()\nhw_results_dicts = [pub_result.data.__dict__ for pub_result in hw_results]\n\n# Save hardware results to serverless output dictionary\noutput["hw_results"] = hw_results_dicts\n\n# Reorganize expectation values\nhw_expvals = [pub_result_data["evs"].tolist() for pub_result_data in hw_results_dicts]\n\n# Save expectation values to Qiskit Serverless\noutput["hw_expvals"] = hw_expvals[0]\n\nsave_result(output)\n'})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-text",children:"Overwriting ./source_files/template_hamiltonian_simulation_full.py\n"})}),"\n",(0,i.jsxs)(n,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)("b",{children:"Full program source code"})}),(0,i.jsxs)(e.p,{children:["Here is the entire source of ",(0,i.jsx)(e.code,{children:"./source_files/template_hamiltonian_simulation.py"})," as one code block."]})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'# This cell is hidden from users.  It verifies both source listings are identical then deletes the working folder we created\nimport shutil\n\nwith open("./source_files/template_hamiltonian_simulation.py") as f1:\n    with open("./source_files/template_hamiltonian_simulation_full.py") as f2:\n        assert f1.read() == f2.read()\n\nshutil.rmtree("./source_files/")\n'})})]})}function c(I={}){const{wrapper:e}={...(0,a.R)(),...I.components};return e?(0,i.jsx)(e,{...I,children:(0,i.jsx)(u,{...I})}):u(I)}function m(I,e){throw new Error("Expected "+(e?"component":"object")+" `"+I+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(I,e,t){t.d(e,{R:()=>r,x:()=>s});var n=t(96540);const i={},a=n.createContext(i);function r(I){const e=n.useContext(a);return n.useMemo(function(){return"function"==typeof I?I(e):{...e,...I}},[e,I])}function s(I){let e;return e=I.disableParentContext?"function"==typeof I.components?I.components(i):I.components||i:r(I.components),n.createElement(a.Provider,{value:e},I.children)}}}]);