"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[8383],{898(e,i,t){t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/directed-execution-model","title":"Directed execution model (beta)","description":"Use this composable, explicit execution model with your utility-scale experiments to fine-tune error mitigation and other techniques.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/directed-execution-model.mdx","sourceDirName":"guides","slug":"/guides/directed-execution-model","permalink":"/guides/directed-execution-model","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/directed-execution-model.mdx","tags":[],"version":"current","frontMatter":{"title":"Directed execution model (beta)","description":"Use this composable, explicit execution model with your utility-scale experiments to fine-tune error mitigation and other techniques."},"sidebar":"tutorialsSidebar","previous":{"title":"Noise learning helper","permalink":"/guides/noise-learning"},"next":{"title":"Introduction to options","permalink":"/guides/runtime-options-overview"}}');var o=t(74848),r=t(28453);const s={title:"Directed execution model (beta)",description:"Use this composable, explicit execution model with your utility-scale experiments to fine-tune error mitigation and other techniques."},a="Directed execution model (beta)",c={},l=[{value:"Workflow",id:"workflow",level:2},{value:"Tools for the directed execution model",id:"tools-for-the-directed-execution-model",level:2},{value:"Samplomatic",id:"samplomatic",level:3},{value:"Executor primitive",id:"executor-primitive",level:3},{value:"NoiseLearnerV3",id:"noiselearnerv3",level:3},{value:"Next steps",id:"next-steps",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Admonition:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,o.jsxs)(o.Fragment,{children:["\n",(0,o.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,o.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"directed-execution-model-beta",children:"Directed execution model (beta)"})}),"\n",(0,o.jsx)(n,{type:"note",title:"Beta release",children:(0,o.jsxs)(i.p,{children:["All components in the directed execution model are currently in beta and might not be stable. You are invited to test them and provide feedback by opening an issue in the ",(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/samplomatic/issues",children:"Samplomatic"})," or ",(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/qiskit-ibm-runtime/issues",children:"Qiskit Runtime"})," GitHub repositories."]})}),"\n",(0,o.jsxs)(i.p,{children:["The Sampler and Estimator primitive interfaces provide a higher-level abstraction for algorithm developers to focus more on innovation and less on data conversion. However, they are less suitable for quantum information scientists, who require more control and flexibility for their utility-scale experiments. The ",(0,o.jsx)(i.strong,{children:"directed execution model"}),", currently in beta release, addresses this need. This execution model provides the ingredients to capture design intents on the client side, and shifts the costly generation of circuit variants to the server side, so that you can fine-tune error mitigation and other techniques without sacrificing performance. This explicit and composable model makes it easier to experiment with new techniques, reproduce results, and share methods."]}),"\n",(0,o.jsx)(i.p,{children:"In its beta release, the directed execution model focuses on giving you control over techniques that are built into the existing Sampler and Estimator, including Pauli twirling, noise model learning and injection, and basis changes. Support for other capabilities will be added gradually over time."}),"\n",(0,o.jsx)(i.h2,{id:"workflow",children:"Workflow"}),"\n",(0,o.jsx)(i.p,{children:"One main goal of the directed execution model is to provide a modular way to apply error mitigation methods. For example, you can define which layers in the circuit to mitigate, or adjust the noise rates being injected into the circuit."}),"\n",(0,o.jsxs)(i.p,{children:["To apply error mitigation to a circuit under the framework, your workflow will typically involve the following steps (the tools mentioned here are described more fully in the ",(0,o.jsx)(i.a,{href:"#samplomatic-tools",children:"next section"}),"):"]}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Group instructions into boxes and apply annotations to them. The annotations capture the intended transformation without actually generating the circuit variants."}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:["Learn the noise models of the unique layers, if needed, using the new ",(0,o.jsx)(i.a,{href:"#noiselearnerv3",children:"NoiseLearnerV3"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Build the template circuit and samplex from the boxed circuit."}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsxs)(i.p,{children:["Run the template circuit and samplex with the ",(0,o.jsx)(i.a,{href:"#executor-primitive",children:"Executor"})," primitive, which will generate and execute the circuit variants as instructed."]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:["\n",(0,o.jsx)(i.p,{children:"Post-process execution results. For example, you can apply post-selection, or extrapolate mitigated expectation values from the execution results."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)("span",{id:"samplomatic-tools"}),"\n",(0,o.jsx)(i.h2,{id:"tools-for-the-directed-execution-model",children:"Tools for the directed execution model"}),"\n",(0,o.jsx)(i.p,{children:"The following tools can be used together to implement an error mitigation technique in the directed execution model."}),"\n",(0,o.jsx)(i.h3,{id:"samplomatic",children:"Samplomatic"}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/samplomatic/",children:"Samplomatic"})," is a new open-source library that supports customized sampling randomizations. It uses the ",(0,o.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.QuantumCircuit#box",children:"box"})," construct to reason about collections of circuit operations that should be treated as having a stable noise context, and uses annotations on boxes to allow you to declare and configure intents. For example, you can stratify your circuit into boxes, add a twirling annotation to each box, and specify which twirling group to use, as shown in the following figure:"]}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.img,{alt:"Example of using boxes and twirling annotations",src:t(34561).A+"",width:"1024",height:"338"})}),"\n",(0,o.jsxs)(i.p,{children:["A circuit with annotated boxes can then be used to generate a ",(0,o.jsx)(i.em,{children:"template circuit"})," and a ",(0,o.jsx)(i.em,{children:"samplex"}),". The output template circuit is a parameterized circuit that will be executed without further alteration (other than having different parameter values assigned to it). The samplex, which is the core type of the Samplomatic library, represents a parametric probability distribution over the parameters of the template circuit and other array-valued fields. These fields can be used to post-process data collected from executing the bound template circuit. In other words, the template circuit and samplex pair tells the Executor primitive (described below) exactly what parameters to generate and what bound circuits to run. Because these two constructs are created on the client side, you can do local inspection and sampling to verify the outputs prior to sending it for hardware execution."]}),"\n",(0,o.jsx)(i.p,{children:"To simplify the process of generating annotated boxes, the Samplomatic library also provides transpiler passes that automatically group circuit instructions into annotated boxes, based on the strategies you provide."}),"\n",(0,o.jsxs)(i.p,{children:["To learn more about Samplomatic, visit the ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/samplomatic/guides/index.html",children:"guides"})," and ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/samplomatic/",children:"API reference"})," documentation. Feel free to submit feedback and report bugs in its ",(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/samplomatic",children:"GitHub"})," repository."]}),"\n",(0,o.jsx)(i.h3,{id:"executor-primitive",children:"Executor primitive"}),"\n",(0,o.jsx)(i.p,{children:"Executor is a new Qiskit Runtime primitive that takes the template circuit and samplex pair as the input, generates and binds parameter values according to the samplex, executes the bound circuits on the hardware, and returns the execution results and metadata. It follows the directives of the input pair and does not make any implicit decisions for you, so that the process is transparent yet performant."}),"\n",(0,o.jsxs)(i.p,{children:["To access ",(0,o.jsx)(i.code,{children:"Executor"}),", install the ",(0,o.jsx)(i.code,{children:"executor_preview"})," branch from ",(0,o.jsx)(i.code,{children:"qiskit-ibm-runtime"}),":"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"pip install -U git+https://github.com/Qiskit/qiskit-ibm-runtime.git@executor_preview\n"})}),"\n",(0,o.jsxs)(i.p,{children:["The inputs and output of the Executor primitive are very different from those of Sampler and Estimator. Refer to the ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-ibm-runtime/stubs/qiskit_ibm_runtime.Executor.html",children:"Executor API reference"})," for more information. In addition, the ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-ibm-runtime/guides/executor_basic.html",children:"Executor quickstart guide"})," provides an overview and code examples."]}),"\n",(0,o.jsx)(i.h3,{id:"noiselearnerv3",children:"NoiseLearnerV3"}),"\n",(0,o.jsxs)(i.p,{children:["Similar to the current ",(0,o.jsx)(i.a,{href:"/guides/noise-learning",children:(0,o.jsx)(i.code,{children:"NoiseLearner"})}),", this Qiskit Runtime helper program returns the sparse ",(0,o.jsx)(i.a,{href:"https://arxiv.org/abs/2201.09866",children:"Pauli-Lindblad noise model"})," that is used in many error mitigation methods, including ",(0,o.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques#probabilistic-error-cancellation-pec",children:"PEC"}),", ",(0,o.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea",children:"PEA"}),", and ",(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/qiskit-addon-pna/tree/main",children:"PNA"}),". In the original ",(0,o.jsx)(i.code,{children:"NoiseLearner"}),", you pass in a list of circuits, and the program stratifies the circuits into layers and returns the noise model for each unique layer. ",(0,o.jsx)(i.code,{children:"NoiseLearnerV3"}),", on the other hand, gives you control over how to stratify your circuits, and the program simply takes a list of boxed circuit instructions (for example, unique layers) as the inputs."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"NoiseLearnerV3"})," also supports measurement noise learning. For each instruction set in the input list, it runs the Pauli-Lindblad learning protocol if the set contains one- and two-qubit gates, and the ",(0,o.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques#twirled-readout-error-extinction-trex",children:"TREX"})," protocol if the set contains measurements.\nTo access ",(0,o.jsx)(i.code,{children:"NoiseLearnerV3"}),", install the ",(0,o.jsx)(i.code,{children:"executor_preview"})," branch from ",(0,o.jsx)(i.code,{children:"qiskit-ibm-runtime"}),":"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"pip install -U git+https://github.com/Qiskit/qiskit-ibm-runtime.git@executor_preview\n"})}),"\n",(0,o.jsxs)(i.p,{children:["To learn more about NoiseLearnerV3, refer to its ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-ibm-runtime/apidocs/noise_learner_v3.html",children:"API reference"})," documentation."]}),"\n",(0,o.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,o.jsx)(n,{type:"tip",title:"Recommendations",children:(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Check out two Qiskit addons, ",(0,o.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-addon-slc/",children:"Shaded lightcones"})," and ",(0,o.jsx)(i.a,{href:"https://github.com/Qiskit/qiskit-addon-pna",children:"Propagated noise absorption"}),", which are built on top of this execution model."]}),"\n"]})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},34561(e,i,t){t.d(i,{A:()=>n});const n=t.p+"assets/images/execution-model-3f6abccbb019cdb57baf809a7c1ce82a.avif"},28453(e,i,t){t.d(i,{R:()=>s,x:()=>a});var n=t(96540);const o={},r=n.createContext(o);function s(e){const i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);