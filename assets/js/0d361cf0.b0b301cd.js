"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[658],{18609(e,i,n){n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"guides/debug-qiskit-runtime-jobs","title":"Debug Qiskit Runtime jobs","description":"Use the Qiskit Runtime Debugging tools module and `Neat` class to debug and analyze jobs.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/debug-qiskit-runtime-jobs.mdx","sourceDirName":"guides","slug":"/guides/debug-qiskit-runtime-jobs","permalink":"/guides/debug-qiskit-runtime-jobs","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/debug-qiskit-runtime-jobs.mdx","tags":[],"version":"current","frontMatter":{"title":"Debug Qiskit Runtime jobs","sidebar_label":"Debug Qiskit Runtime jobs","description":"Use the Qiskit Runtime Debugging tools module and `Neat` class to debug and analyze jobs.","notebook_path":"docs/guides/debug-qiskit-runtime-jobs.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Qiskit Runtime local testing mode","permalink":"/guides/local-testing-mode"},"next":{"title":"Building noise models","permalink":"/guides/build-noise-models"}}');var t=n(74848),r=n(28453);const a={title:"Debug Qiskit Runtime jobs",sidebar_label:"Debug Qiskit Runtime jobs",description:"Use the Qiskit Runtime Debugging tools module and `Neat` class to debug and analyze jobs.",notebook_path:"docs/guides/debug-qiskit-runtime-jobs.ipynb"},o=void 0,l={},c=[{value:"Prepare the environment",id:"prepare-the-environment",level:2},{value:"Initialize a target circuit",id:"initialize-a-target-circuit",level:2},{value:"Cliffordize the circuits",id:"cliffordize-the-circuits",level:2},{value:"Application 1: Analyze the impact of noise on the circuit outputs",id:"application-1-analyze-the-impact-of-noise-on-the-circuit-outputs",level:2},{value:"Application 2: Benchmark different strategies",id:"application-2-benchmark-different-strategies",level:2},{value:"Next steps",id:"next-steps",level:2}];function u(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Admonition:s,Details:a,OpenInLabBanner:o}=i;return s||h("Admonition",!0),a||h("Details",!0),o||h("OpenInLabBanner",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,t.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,t.jsx)(o,{notebookPath:"docs/guides/debug-qiskit-runtime-jobs.ipynb"}),"\n","\n","\n",(0,t.jsxs)(a,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("b",{children:"Package versions"})}),(0,t.jsx)(i.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\nqiskit-aer~=0.17\n"})})]}),"\n",(0,t.jsxs)(i.p,{children:["Before submitting a resource-intensive Qiskit Runtime workload to execute on hardware, you can use the Qiskit Runtime ",(0,t.jsxs)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools-neat#neat",children:[(0,t.jsx)(i.code,{children:"Neat"})," (Noisy Estimator Analyzer Tool)"]})," class to verify that your Estimator workload is set up correctly, is likely to return  accurate results, uses the most appropriate options for the specified problem, and more."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"Neat"})," Cliffordizes the input circuits for efficient simulation, while retaining its structure and depth. Clifford circuits suffer similar levels of noise and are a good proxy for studying the original circuit of interest."]}),"\n",(0,t.jsxs)(i.p,{children:["The following examples illustrate situations where ",(0,t.jsx)(i.code,{children:"Neat"})," can be a useful resource.\nFirst, import the relevant packages and ",(0,t.jsx)(i.a,{href:"/guides/cloud-setup",children:"authenticate to the Qiskit Runtime service."})]}),"\n",(0,t.jsx)(i.h2,{id:"prepare-the-environment",children:"Prepare the environment"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"import numpy as np\nimport random\n\nfrom qiskit.circuit import QuantumCircuit\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit.quantum_info import SparsePauliOp\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService, EstimatorV2 as Estimator\nfrom qiskit_ibm_runtime.debug_tools import Neat\n\nfrom qiskit_aer.noise import NoiseModel, depolarizing_error\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"# Choose the least busy backend\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Generate a preset pass manager\n# This will be used to convert the abstract circuit to an equivalent Instruction Set Architecture (ISA) circuit.\npm = generate_preset_pass_manager(backend=backend, optimization_level=0)\n\n# Set the random seed\nrandom.seed(10)\n"})}),"\n",(0,t.jsx)(i.h2,{id:"initialize-a-target-circuit",children:"Initialize a target circuit"}),"\n",(0,t.jsx)(i.p,{children:"Consider a six-qubit circuit that has the following properties:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Alternates between random ",(0,t.jsx)(i.code,{children:"RZ"})," rotations and layers of ",(0,t.jsx)(i.code,{children:"CNOT"})," gates."]}),"\n",(0,t.jsxs)(i.li,{children:["Has a mirror structure, that is, it applies a unitary ",(0,t.jsx)(i.code,{children:"U"})," followed by its inverse."]}),"\n"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'def generate_circuit(n_qubits, n_layers):\n    r"""\n    A function to generate a pseudo-random a circuit with ``n_qubits`` qubits and\n    ``2*n_layers`` entangling layers of the type used in this notebook.\n    """\n    # An array of random angles\n    angles = [\n        [random.random() for q in range(n_qubits)] for s in range(n_layers)\n    ]\n\n    qc = QuantumCircuit(n_qubits)\n    qubits = list(range(n_qubits))\n\n    # do random circuit\n    for layer in range(n_layers):\n        # rotations\n        for q_idx, qubit in enumerate(qubits):\n            qc.rz(angles[layer][q_idx], qubit)\n\n        # cx gates\n        control_qubits = (\n            qubits[::2] if layer % 2 == 0 else qubits[1 : n_qubits - 1 : 2]\n        )\n        for qubit in control_qubits:\n            qc.cx(qubit, qubit + 1)\n\n    # undo random circuit\n    for layer in range(n_layers)[::-1]:\n        # cx gates\n        control_qubits = (\n            qubits[::2] if layer % 2 == 0 else qubits[1 : n_qubits - 1 : 2]\n        )\n        for qubit in control_qubits:\n            qc.cx(qubit, qubit + 1)\n\n        # rotations\n        for q_idx, qubit in enumerate(qubits):\n            qc.rz(-angles[layer][q_idx], qubit)\n\n    return qc\n\n# Generate a random circuit\nqc = generate_circuit(6, 3)\n# Convert the abstract circuit to an equivalent ISA circuit.\nisa_qc = pm.run(qc)\n\nqc.draw("mpl", idle_wires=0)\n'})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Output of the previous code cell",src:n(78311).A+"",width:"850",height:"415"})}),"\n",(0,t.jsxs)(i.p,{children:["Choose single-Pauli ",(0,t.jsx)(i.code,{children:"Z"})," operators as observables and use them to initialize the primitive unified blocs (PUBs)."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Initialize the observables\nobs = ["ZIIIII", "IZIIII", "IIZIII", "IIIZII", "IIIIZI", "IIIIIZ"]\nprint(f"Observables: {obs}")\n\n# Map the observables to the backend\'s layout\nisa_obs = [SparsePauliOp(o).apply_layout(isa_qc.layout) for o in obs]\n\n# Initialize the PUBs, which consist of six-qubit circuits with `n_layers` 1, ..., 6\nall_n_layers = [1, 2, 3, 4, 5, 6]\n\npubs = [(pm.run(generate_circuit(6, n)), isa_obs) for n in all_n_layers]\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Observables: ['ZIIIII', 'IZIIII', 'IIZIII', 'IIIZII', 'IIIIZI', 'IIIIIZ']\n"})}),"\n",(0,t.jsx)(i.h2,{id:"cliffordize-the-circuits",children:"Cliffordize the circuits"}),"\n",(0,t.jsxs)(i.p,{children:["The previously defined PUB circuits are not Clifford, which makes them difficult to simulate classically. However, you can use the ",(0,t.jsx)(i.code,{children:"Neat"})," ",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools-neat#to_clifford",children:(0,t.jsx)(i.code,{children:"to_clifford"})})," method to map them to Clifford circuits for more efficient simulation.  The ",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools-neat#to_clifford",children:(0,t.jsx)(i.code,{children:"to_clifford"})})," method is a wrapper around the ",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/transpiler-passes-convert-isa-to-clifford",children:(0,t.jsx)(i.code,{children:"ConvertISAToClifford"})})," transpiler pass, which can also be used independently. In particular, it replaces non-Clifford single-qubit gates in the original circuit with Clifford single-qubit gates, but it does not mutate the two-qubit gates, number of qubits, or circuit depth."]}),"\n",(0,t.jsxs)(i.p,{children:["See ",(0,t.jsx)(i.a,{href:"/guides/simulate-stabilizer-circuits",children:"Efficient simulation of stabilizer circuits with Qiskit Aer primitives"})," for more information about Clifford circuit simulation.\nFirst, initialize ",(0,t.jsx)(i.code,{children:"Neat"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"# You could specify a custom `NoiseModel` here. If `None`, `Neat`\n# pulls the noise model from the given backend\nnoise_model = None\n\n# Initialize `Neat`\nanalyzer = Neat(backend, noise_model)\n"})}),"\n",(0,t.jsx)(i.p,{children:"Next, Cliffordize the PUBs."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'clifford_pubs = analyzer.to_clifford(pubs)\n\nclifford_pubs[0].circuit.draw("mpl", idle_wires=0)\n'})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Output of the previous code cell",src:n(64026).A+"",width:"1097",height:"425"})}),"\n",(0,t.jsx)(i.h2,{id:"application-1-analyze-the-impact-of-noise-on-the-circuit-outputs",children:"Application 1: Analyze the impact of noise on the circuit outputs"}),"\n",(0,t.jsxs)(i.p,{children:["This example shows how to use ",(0,t.jsx)(i.code,{children:"Neat"})," to study the impact of different noise models on PUBs as a function of circuit depth by running simulations in both ideal (",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools-neat#ideal_sim",children:(0,t.jsx)(i.code,{children:"ideal_sim"})}),") and noisy (",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools-neat#noisy_sim",children:(0,t.jsx)(i.code,{children:"noisy_sim"})}),") conditions. This can be useful to set up expectations on the quality of the experimental results before running a job on a QPU. To learn more about noise models, see ",(0,t.jsx)(i.a,{href:"/guides/simulate-with-qiskit-aer#exact-and-noisy-simulation-with-qiskit-aer-primitives",children:"Exact and noisy simulation with Qiskit Aer primitives."})]}),"\n",(0,t.jsx)(i.p,{children:"The simulated results support mathematical operations, and can therefore be compared with each other (or with experimental results) to calculate figures of merit."}),"\n",(0,t.jsxs)(s,{type:"caution",children:[(0,t.jsx)(i.p,{children:"A QPU can be affected by different kinds of noise. The Qiskit Aer noise model used here only simulates some of them and therefore is likely to be less severe than the noise on a real QPU."}),(0,t.jsxs)(i.p,{children:["For details on what errors are included when initializing a noise model from a QPU, see the Aer ",(0,t.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-aer/stubs/qiskit_aer.noise.NoiseModel.html#qiskit_aer.noise.NoiseModel.from_backend",children:(0,t.jsx)(i.code,{children:"NoiseModel"})})," API reference."]})]}),"\n",(0,t.jsx)(i.p,{children:"Begin by performing ideal and noisy classical simulations."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Perform a noiseless simulation\nideal_results = analyzer.ideal_sim(clifford_pubs)\nprint(f"Ideal results:\\n {ideal_results}\\n")\n\n# Perform a noisy simulation with the backend\'s noise model\nnoisy_results = analyzer.noisy_sim(clifford_pubs)\nprint(f"Noisy results:\\n {noisy_results}\\n")\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Ideal results:\n NeatResult([NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.])), NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.])), NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.])), NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.])), NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.])), NeatPubResult(vals=array([1., 1., 1., 1., 1., 1.]))])\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Noisy results:\n NeatResult([NeatPubResult(vals=array([0.99023438, 0.99609375, 0.9921875 , 0.99023438, 0.99414062,\n       0.99414062])), NeatPubResult(vals=array([0.984375  , 0.99414062, 0.98242188, 0.98828125, 0.98632812,\n       0.99414062])), NeatPubResult(vals=array([0.96679688, 0.97070312, 0.95898438, 0.97851562, 0.98046875,\n       0.98828125])), NeatPubResult(vals=array([0.9453125 , 0.953125  , 0.97070312, 0.96875   , 0.98242188,\n       0.99023438])), NeatPubResult(vals=array([0.93164062, 0.9375    , 0.953125  , 0.96875   , 0.96484375,\n       0.98046875])), NeatPubResult(vals=array([0.92578125, 0.921875  , 0.93359375, 0.953125  , 0.95898438,\n       0.9765625 ]))])\n"})}),"\n",(0,t.jsx)(i.p,{children:"Next, apply mathematical operations to compute the absolute difference. The remainder of the guide uses the absolute difference as a figure of merit to compare ideal results with noisy or experimental results, but similar figures of merit can be set up."}),"\n",(0,t.jsx)(i.p,{children:"The absolute difference shows that the impact of noise grows with the circuits' sizes."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Figure of merit: Absolute difference\ndef rdiff(res1, re2):\n    r"""The absolute difference between `res1` and re2`.\n\n    --\x3e The closer to `0`, the better.\n    """\n    d = abs(res1 - re2)\n    return np.round(d.vals * 100, 2)\n\nfor idx, (ideal_res, noisy_res) in enumerate(\n    zip(ideal_results, noisy_results)\n):\n    vals = rdiff(ideal_res, noisy_res)\n\n    # Print the mean absolute difference for the observables\n    mean_vals = np.round(np.mean(vals), 2)\n    print(\n        f"Mean absolute difference between ideal and noisy results for circuits with {all_n_layers[idx]} layers:\\n  {mean_vals}%\\n"\n    )\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Mean absolute difference between ideal and noisy results for circuits with 1 layers:\n  0.72%\n\nMean absolute difference between ideal and noisy results for circuits with 2 layers:\n  1.17%\n\nMean absolute difference between ideal and noisy results for circuits with 3 layers:\n  2.6%\n\nMean absolute difference between ideal and noisy results for circuits with 4 layers:\n  3.16%\n\nMean absolute difference between ideal and noisy results for circuits with 5 layers:\n  4.4%\n\nMean absolute difference between ideal and noisy results for circuits with 6 layers:\n  5.5%\n"})}),"\n",(0,t.jsx)(i.p,{children:"You can follow these rough and simplified guidelines to improve circuits of this type:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"If the mean absolute difference is greater than 90%, mitigation will likely not help."}),"\n",(0,t.jsxs)(i.li,{children:["If the mean absolute difference is less than 90%, ",(0,t.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques#probabilistic-error-amplification-pea",children:"Probabilistic Error Amplification (PEA)"})," will likely be able to improve the results."]}),"\n",(0,t.jsxs)(i.li,{children:["If the mean absolute difference is less than 80%, ",(0,t.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques#zero-noise-extrapolation-zne",children:"ZNE with gate folding"})," will also likely be able to improve the results."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Because all of the absolute differences above are less than 90%, applying PEA to the original circuit will hopefully improve the quality of its results.\nYou can specify different noise models in the analyzer. The following example performs the same test but adds a custom noise model."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Set up a noise model with strength 0.02 on every two-qubit gate\nnoise_model = NoiseModel()\nfor qubits in backend.coupling_map:\n    noise_model.add_quantum_error(\n        depolarizing_error(0.02, 2), ["ecr", "cx"], qubits\n    )\n\n# Update the analyzer\'s noise model\nanalyzer.noise_model = noise_model\n\n# Perform a noiseless simulation\nideal_results = analyzer.ideal_sim(clifford_pubs)\n\n# Perform a noisy simulation with the backend\'s noise model\nnoisy_results = analyzer.noisy_sim(clifford_pubs)\n\n# Compare the results\nfor idx, (ideal_res, noisy_res) in enumerate(\n    zip(ideal_results, noisy_results)\n):\n    values = rdiff(ideal_res, noisy_res)\n\n    # Print the mean absolute difference for the observables\n    mean_values = np.round(np.mean(values), 2)\n    print(\n        f"Mean absolute difference between ideal and noisy results for circuits with {all_n_layers[idx]} layers:\\n  {mean_values}%\\n"\n    )\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Mean absolute difference between ideal and noisy results for circuits with 1 layers:\n  0.0%\n\nMean absolute difference between ideal and noisy results for circuits with 2 layers:\n  0.0%\n\nMean absolute difference between ideal and noisy results for circuits with 3 layers:\n  0.0%\n\nMean absolute difference between ideal and noisy results for circuits with 4 layers:\n  0.0%\n\nMean absolute difference between ideal and noisy results for circuits with 5 layers:\n  0.0%\n\nMean absolute difference between ideal and noisy results for circuits with 6 layers:\n  0.0%\n"})}),"\n",(0,t.jsx)(i.p,{children:"As shown, given a noise model, you can try to quantify the impact of noise on the (Cliffordized version of the) PUBs of interest before running them on a QPU."}),"\n",(0,t.jsx)(i.h2,{id:"application-2-benchmark-different-strategies",children:"Application 2: Benchmark different strategies"}),"\n",(0,t.jsxs)(i.p,{children:["This example uses ",(0,t.jsx)(i.code,{children:"Neat"})," to help identify the best options for your PUBs. To do so, consider running an estimation problem with PEA, which cannot be simulated with ",(0,t.jsx)(i.code,{children:"qiskit_aer"}),". You can use ",(0,t.jsx)(i.code,{children:"Neat"})," to help determine which noise amplification factors will work best, then use those factors when running the original experiment on a QPU."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"# Generate a circuit with six qubits and six layers\nisa_qc = pm.run(generate_circuit(6, 3))\n\n# Use the same observables as previously\npubs = [(isa_qc, isa_obs)]\nclifford_pubs = analyzer.to_clifford(pubs)\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"noise_factors = [\n    [1, 1.1],\n    [1, 1.1, 1.2],\n    [1, 1.5, 2],\n    [1, 1.5, 2, 2.5, 3],\n    [1, 4],\n]\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Run the PUBs on a QPU\nestimator = Estimator(backend)\nestimator.options.default_shots = 100000\nestimator.options.twirling.enable_gates = True\nestimator.options.twirling.enable_measure = True\nestimator.options.twirling.shots_per_randomization = 100\nestimator.options.resilience.measure_mitigation = True\nestimator.options.resilience.zne_mitigation = True\nestimator.options.resilience.zne.amplifier = "pea"\n\njobs = []\nfor factors in noise_factors:\n    estimator.options.resilience.zne.noise_factors = factors\n    jobs.append(estimator.run(clifford_pubs))\n\nresults = [job.result() for job in jobs]\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:"# Perform a noiseless simulation\nideal_results = analyzer.ideal_sim(clifford_pubs)\n"})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'# Look at the mean absolute difference to quickly tell the best choice for your options\nfor factors, res in zip(noise_factors, results):\n    d = rdiff(ideal_results[0], res[0])\n    print(\n        f"Mean absolute difference for factors {factors}:\\n  {np.round(np.mean(d), 2)}%\\n"\n    )\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"Mean absolute difference for factors [1, 1.1]:\n  6.83%\n\nMean absolute difference for factors [1, 1.1, 1.2]:\n  8.76%\n\nMean absolute difference for factors [1, 1.5, 2]:\n  8.03%\n\nMean absolute difference for factors [1, 1.5, 2, 2.5, 3]:\n  10.17%\n\nMean absolute difference for factors [1, 4]:\n  8.02%\n"})}),"\n",(0,t.jsx)(i.p,{children:"The result with the smallest difference suggests which options to choose."}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsx)(s,{type:"tip",title:"Recommendations",children:(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Learn about ",(0,t.jsx)(i.a,{href:"/guides/simulate-with-qiskit-aer",children:"Exact and noisy simulation with Qiskit Aer primitives."})]}),"\n",(0,t.jsxs)(i.li,{children:["Learn about ",(0,t.jsx)(i.a,{href:"/guides/runtime-options-overview",children:"available Qiskit Runtime options."})]}),"\n",(0,t.jsxs)(i.li,{children:["Learn about ",(0,t.jsx)(i.a,{href:"/guides/error-mitigation-and-suppression-techniques",children:"Error mitigation and suppression techniques."})]}),"\n",(0,t.jsxs)(i.li,{children:["Visit the ",(0,t.jsx)(i.a,{href:"transpile-with-pass-managers",children:"Transpile with pass managers"})," topic."]}),"\n",(0,t.jsxs)(i.li,{children:["Learn ",(0,t.jsx)(i.a,{href:"/guides/circuit-transpilation-settings#compare-transpiler-settings",children:"how to transpile circuits"})," as part of Qiskit patterns workflows using Qiskit Runtime."]}),"\n",(0,t.jsxs)(i.li,{children:["Review the ",(0,t.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/debug-tools",children:"Debugging tools API documentation."})]}),"\n"]})})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}function h(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},64026(e,i,n){n.d(i,{A:()=>s});const s=n.p+"assets/images/3ad78f41-a2f8-4381-826a-ae728e081ad6-0-2294a963a509c8d62d72b1d22509b7a2.svg"},78311(e,i,n){n.d(i,{A:()=>s});const s=n.p+"assets/images/df19af55-897d-4b1f-baf8-fac2641ae87d-0-4a39e8119d73bf82acdcff3f48bd55f6.svg"},28453(e,i,n){n.d(i,{R:()=>a,x:()=>o});var s=n(96540);const t={},r=s.createContext(t);function a(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);