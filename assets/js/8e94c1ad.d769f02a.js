"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[8490],{57476(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"guides/custom-backend","title":"Create and transpile against custom backends","description":"Learn how to create your own custom backends and transpile circuits against them","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/custom-backend.mdx","sourceDirName":"guides","slug":"/guides/custom-backend","permalink":"/guides/custom-backend","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/custom-backend.mdx","tags":[],"version":"current","frontMatter":{"title":"Create and transpile against custom backends","sidebar_label":"Create and transpile against custom backends","description":"Learn how to create your own custom backends and transpile circuits against them","notebook_path":"docs/guides/custom-backend.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Write your own transpiler pass","permalink":"/guides/custom-transpiler-pass"},"next":{"title":"Install and use transpiler plugins","permalink":"/guides/transpiler-plugins"}}');var i=t(74848),s=t(28453);const r={title:"Create and transpile against custom backends",sidebar_label:"Create and transpile against custom backends",description:"Learn how to create your own custom backends and transpile circuits against them",notebook_path:"docs/guides/custom-backend.ipynb"},o=void 0,c={},d=[{value:"Visualize backends",id:"visualize-backends",level:3},{value:"Transpile against custom backends",id:"transpile-against-custom-backends",level:2},{value:"Create unique backends",id:"create-unique-backends",level:2}];function l(e){const n={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h2:"h2",h3:"h3",img:"img",math:"math",mn:"mn",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,s.R)(),...e.components},{OpenInLabBanner:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsx)(n.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,i.jsx)(n.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,i.jsx)(a,{notebookPath:"docs/guides/custom-backend.ipynb"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Don't use SVGs for this file because the images are too large,\n# and the SVGs are much larger than their PNGs equivalents.\n%config InlineBackend.figure_format='png'\n```json\n\n{/* cspell:ignore multichip interchip Lasciate ogne speranza voi ch'intrate */}\n{/*\n  DO NOT EDIT THIS CELL!!!\n  This cell's content is generated automatically by a script. Anything you add\n  here will be removed next time the notebook is run. To add new content, create\n  a new cell before or after this one.\n*/}\n\n<details>\n<summary><b>Package versions</b></summary>\n\nThe code on this page was developed using the following requirements.\nWe recommend using these versions or newer.\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"qiskit[all]~=2.3.0"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'</details>\n{/* cspell:ignore LOCC */}\n\nOne of the more powerful features of Qiskit is the ability to support unique device configurations.  Qiskit is built to be agnostic to the provider of the quantum hardware you use, and providers can configure the `BackendV2` object to their own unique device properties.  This topic demonstrates how to configure your own backend and transpile quantum circuits against them.\n\nYou can create unique `BackendV2` objects with different geometries or basis gates and transpile your circuits with those configurations in mind.  The example below covers a backend with a disjoint qubit lattice, whose basis gates are different along the edges from within the bulk.\n## Understand the Provider, BackendV2, and Target interfaces\n\nBefore beginning, it is helpful to understand the usage and purpose of the [`Provider`](../api/qiskit/providers), [`BackendV2`](../api/qiskit/qiskit.providers.BackendV2), and [`Target`](../api/qiskit/qiskit.transpiler.Target) objects.\n\n- If you have a quantum device or simulator that you want to integrate into the Qiskit SDK, you need to write your own `Provider` class. This class serves a single purpose: to get backend objects that you provide. This is where any required credential and/or authentication tasks are handled. Once instantiated, the provider object will then provide a list of backends as well as the ability to acquire/instantiate backends.\n\n- Next, the backend classes provide the interface between the Qiskit SDK and the hardware or simulator that will execute circuits. They include all necessary information to describe a backend to the transpiler so that it can optimize any circuit according to its constraints. A `BackendV2` is built of four main parts:\n  - A [`Target`](../api/qiskit/qiskit.transpiler.Target) property, which contains a description of the constraints of the backend and provides a model of the backend for the transpiler\n  - A `max_circuits` property that defines a limit on the number of circuits a backend can execute in a single job\n  - A `run()` method that accept job submissions\n  - A set of `_default_options` to define the user configurable options and their default values\n## Create a custom BackendV2\n\nThe `BackendV2` object is an abstract class used for all backend objects created by a provider (either within `qiskit.providers` or another library such as [`qiskit_ibm_runtime.IBMBackend`](../api/qiskit-ibm-runtime/ibm-backend)).  As mentioned above, these objects contain several attributes, including a [`Target`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.Target). The `Target` contains information that specifies the backend\'s attributes - such as the [`Coupling Map`](https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.CouplingMap), list of [`Instructions`](https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.Instruction), and others - to the transpiler.  In addition to the `Target`, one can also define pulse-level details such as the [`DriveChannel`](https://docs.quantum.ibm.com/api/qiskit/1.4/qiskit.pulse.channels.DriveChannel) or [`ControlChannel`](https://docs.quantum.ibm.com/api/qiskit/1.4/qiskit.pulse.channels.ControlChannel).\n\nThe following example demonstrates this customization by creating a simulated multi-chip backend, where each chip possesses a heavy-hex connectivity.  The example specifies the backend\'s two-qubit gate set to be [`CZGates`](../api/qiskit/qiskit.circuit.library.CZGate) within each chip and [`CXGates`](../api/qiskit/qiskit.circuit.library.ECRGate) between chips.  First, create your own `BackendV2` and customize its `Target` with single and two-qubit gates according to the previously described constraints.\n\n<Admonition type="tip" title="graphviz library">\nPlotting a coupling map requires the [`graphviz`](https://graphviz.org/) library to be installed.\n</Admonition>\n\n```python\nimport numpy as np\nimport rustworkx as rx\n\nfrom qiskit.providers import BackendV2, Options\nfrom qiskit.transpiler import Target, InstructionProperties\nfrom qiskit.circuit.library import XGate, SXGate, RZGate, CZGate, ECRGate\nfrom qiskit.circuit import Measure, Delay, Parameter, Reset\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit.visualization import plot_gate_map\n\nclass FakeLOCCBackend(BackendV2):\n    """Fake multi chip backend."""\n\n    def __init__(self, distance=3, number_of_chips=3):\n        """Instantiate a new fake multi chip backend.\n\n        Args:\n            distance (int): The heavy hex code distance to use for each chips\'\n                coupling map. This number **must** be odd. The distance relates\n                to the number of qubits by:\n                :math:`n = \\\\frac{5d^2 - 2d - 1}{2}` where :math:`n` is the\n                number of qubits and :math:`d` is the ``distance``\n            number_of_chips (int): The number of chips to have in the multichip backend\n                each chip will be a heavy hex graph of ``distance`` code distance.\n        """\n        super().__init__(name="Fake LOCC backend")\n        # Create a heavy-hex graph using the rustworkx library, then instantiate a new target\n        self._graph = rx.generators.directed_heavy_hex_graph(\n            distance, bidirectional=False\n        )\n        num_qubits = len(self._graph) * number_of_chips\n        self._target = Target(\n            "Fake multi-chip backend", num_qubits=num_qubits\n        )\n\n        # Generate instruction properties for single qubit gates and a measurement, delay,\n        #  and reset operation to every qubit in the backend.\n        rng = np.random.default_rng(seed=12345678942)\n        rz_props = {}\n        x_props = {}\n        sx_props = {}\n        measure_props = {}\n        delay_props = {}\n\n        # Add 1q gates. Globally use virtual rz, x, sx, and measure\n        for i in range(num_qubits):\n            qarg = (i,)\n            rz_props[qarg] = InstructionProperties(error=0.0, duration=0.0)\n            x_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-6, 1e-4),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            sx_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-6, 1e-4),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            measure_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-3, 1e-1),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            delay_props[qarg] = None\n        self._target.add_instruction(XGate(), x_props)\n        self._target.add_instruction(SXGate(), sx_props)\n        self._target.add_instruction(RZGate(Parameter("theta")), rz_props)\n        self._target.add_instruction(Measure(), measure_props)\n        self._target.add_instruction(Reset(), measure_props)\n\n        self._target.add_instruction(Delay(Parameter("t")), delay_props)\n        # Add chip local 2q gate which is CZ\n        cz_props = {}\n        for i in range(number_of_chips):\n            for root_edge in self._graph.edge_list():\n                offset = i * len(self._graph)\n                edge = (root_edge[0] + offset, root_edge[1] + offset)\n                cz_props[edge] = InstructionProperties(\n                    error=rng.uniform(7e-4, 5e-3),\n                    duration=rng.uniform(1e-8, 9e-7),\n                )\n        self._target.add_instruction(CZGate(), cz_props)\n\n        cx_props = {}\n        # Add interchip 2q gates which are ecr (effectively CX)\n        # First determine which nodes to connect\n        node_indices = self._graph.node_indices()\n        edge_list = self._graph.edge_list()\n        inter_chip_nodes = {}\n        for node in node_indices:\n            count = 0\n            for edge in edge_list:\n                if node == edge[0]:\n                    count += 1\n            if count == 1:\n                inter_chip_nodes[node] = count\n        # Create inter-chip ecr props\n        cx_props = {}\n        inter_chip_edges = list(inter_chip_nodes.keys())\n        for i in range(1, number_of_chips):\n            offset = i * len(self._graph)\n            edge = (\n                inter_chip_edges[1] + (len(self._graph) * (i - 1)),\n                inter_chip_edges[0] + offset,\n            )\n            cx_props[edge] = InstructionProperties(\n                error=rng.uniform(7e-4, 5e-3),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n\n        self._target.add_instruction(ECRGate(), cx_props)\n\n    @property\n    def target(self):\n        return self._target\n\n    @property\n    def max_circuits(self):\n        return None\n\n    @property\n    def graph(self):\n        return self._graph\n\n    @classmethod\n    def _default_options(cls):\n        return Options(shots=1024)\n\n    def run(self, circuit, **kwargs):\n        raise NotImplementedError(\n            "This backend does not contain a run method"\n        )\n'})}),"\n",(0,i.jsx)(n.h3,{id:"visualize-backends",children:"Visualize backends"}),"\n",(0,i.jsxs)(n.p,{children:["You can view the connectivity graph of this new class with the ",(0,i.jsx)(n.a,{href:"../api/qiskit/qiskit.visualization.plot_gate_map",children:(0,i.jsx)(n.code,{children:"plot_gate_map()"})})," method from the ",(0,i.jsx)(n.code,{children:"qiskit.visualization"})," module.  This method, along with ",(0,i.jsx)(n.a,{href:"../api/qiskit/qiskit.visualization.plot_coupling_map",children:(0,i.jsx)(n.code,{children:"plot_coupling_map()"})})," and ",(0,i.jsx)(n.a,{href:"../api/qiskit/qiskit.visualization.plot_circuit_layout",children:(0,i.jsx)(n.code,{children:"plot_circuit_layout()"})}),", are helpful tools for visualizing the qubit arrangement of a backend, as well as how a circuit is laid out across the qubits of a backend.  This example creates a backend containing three small heavy-hex chips. It specifies a set of coordinates to arrange the qubits, as well as a set of custom colors for the differing two-qubit gates."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'backend = FakeLOCCBackend(3, 3)\n\ntarget = backend.target\ncoupling_map_backend = target.build_coupling_map()\n\ncoordinates = [\n    (3, 1),\n    (3, -1),\n    (2, -2),\n    (1, 1),\n    (0, 0),\n    (-1, -1),\n    (-2, 2),\n    (-3, 1),\n    (-3, -1),\n    (2, 1),\n    (1, -1),\n    (-1, 1),\n    (-2, -1),\n    (3, 0),\n    (2, -1),\n    (0, 1),\n    (0, -1),\n    (-2, 1),\n    (-3, 0),\n]\n\nsingle_qubit_coordinates = []\ntotal_qubit_coordinates = []\n\nfor coordinate in coordinates:\n    total_qubit_coordinates.append(coordinate)\n\nfor coordinate in coordinates:\n    total_qubit_coordinates.append(\n        (-1 * coordinate[0] + 1, coordinate[1] + 4)\n    )\n\nfor coordinate in coordinates:\n    total_qubit_coordinates.append((coordinate[0], coordinate[1] + 8))\n\nline_colors = ["#adaaab" for edge in coupling_map_backend.get_edges()]\necr_edges = []\n\n# Get tuples for the edges which have an ecr instruction attached\nfor instruction in target.instructions:\n    if instruction[0].name == "ecr":\n        ecr_edges.append(instruction[1])\n\nfor i, edge in enumerate(coupling_map_backend.get_edges()):\n    if edge in ecr_edges:\n        line_colors[i] = "#000000"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"print(backend.name)\nplot_gate_map(\n    backend,\n    plot_directed=True,\n    qubit_coordinates=total_qubit_coordinates,\n    line_color=line_colors,\n)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Fake LOCC backend\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:t(5265).A+"",width:"1079",height:"654"})}),"\n",(0,i.jsxs)(n.p,{children:["Each qubit is labeled, and colored arrows represent the two-qubit gates.  Gray arrows are the CZ gates and the black arrows are the inter-chip CX gates (these connect qubits ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"6"}),(0,i.jsx)(n.mo,{children:"\u2192"}),(0,i.jsx)(n.mn,{children:"21"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"6 \\rightarrow 21"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"6"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"\u2192"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"21"})]})]})]})," and ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mn,{children:"25"}),(0,i.jsx)(n.mo,{children:"\u2192"}),(0,i.jsx)(n.mn,{children:"40"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"25 \\rightarrow 40"})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"25"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"\u2192"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6444em"}}),(0,i.jsx)(n.span,{className:"mord",children:"40"})]})]})]}),").  The direction of the arrow indicates the default direction in which these gates are executed; they specify which qubits are control/targets by default for each two-qubit channel."]}),"\n",(0,i.jsx)("span",{id:"ex-count-ops"}),"\n",(0,i.jsx)(n.h2,{id:"transpile-against-custom-backends",children:"Transpile against custom backends"}),"\n",(0,i.jsxs)(n.p,{children:["Now that a custom backend with its own unique ",(0,i.jsx)(n.a,{href:"../api/qiskit/qiskit.transpiler.Target",children:(0,i.jsx)(n.code,{children:"Target"})})," has been defined, it is straightforward to transpile quantum circuits against this backend, since all the relevant constraints (basis gates, qubit connectivity, and so forth) needed for transpiler passes are contained within this attribute. The next example builds a circuit that creates a large GHZ state and transpiles it against the backend constructed above."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from qiskit.transpiler import generate_preset_pass_manager\n\nnum_qubits = 50\nghz = QuantumCircuit(num_qubits)\nghz.h(range(num_qubits))\nghz.cx(0, range(1, num_qubits))\nop_counts = ghz.count_ops()\n\nprint("Pre-Transpilation: ")\nprint(f"CX gates: {op_counts[\'cx\']}")\nprint(f"H gates: {op_counts[\'h\']}")\nprint("\\n", 30 * "#", "\\n")\n\npm = generate_preset_pass_manager(optimization_level=3, backend=backend)\ntranspiled_ghz = pm.run(ghz)\nop_counts = transpiled_ghz.count_ops()\n\nprint("Post-Transpilation: ")\nprint(f"CZ gates: {op_counts[\'cz\']}")\nprint(f"ECR gates: {op_counts[\'ecr\']}")\nprint(f"SX gates: {op_counts[\'sx\']}")\nprint(f"RZ gates: {op_counts[\'rz\']}")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pre-Transpilation: \nCX gates: 49\nH gates: 50\n\n ##############################\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Post-Transpilation: \nCZ gates: 151\nECR gates: 6\nSX gates: 295\nRZ gates: 216\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The transpiled circuit now contains a mixture of ",(0,i.jsx)(n.code,{children:"CZ"})," and ",(0,i.jsx)(n.code,{children:"ECR"})," gates, which we specified as the basis gates in the backend's ",(0,i.jsx)(n.code,{children:"Target"}),".  There are also quite a few more gates than you started with because of the need to insert SWAP instructions after choosing a layout.  Below, the ",(0,i.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.visualization.plot_circuit_layout",children:(0,i.jsx)(n.code,{children:"plot_circuit_layout()"})})," visualization tool is used to specify which qubits and two-qubit channels were used in this circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from qiskit.visualization import plot_circuit_layout\n\nplot_circuit_layout(\n    transpiled_ghz, backend, qubit_coordinates=total_qubit_coordinates\n)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:t(25647).A+"",width:"1079",height:"654"})}),"\n",(0,i.jsx)(n.h2,{id:"create-unique-backends",children:"Create unique backends"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://www.rustworkx.org/",children:"rustworkx"})," package contains a large library of different graphs and enables the creation of custom graphs.  The visually interesting code below creates a backend inspired by the toric code. You can then visualize the backend using the functions from the ",(0,i.jsx)(n.a,{href:"#visualize-backends",children:"Visualize backends"})," section."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class FakeTorusBackend(BackendV2):\n    """Fake multi chip backend."""\n\n    def __init__(self):\n        """Instantiate a new backend that is inspired by a toric code"""\n        super().__init__(name="Fake LOCC backend")\n        graph = rx.generators.directed_grid_graph(20, 20)\n        for column in range(20):\n            graph.add_edge(column, 19 * 20 + column, None)\n        for row in range(20):\n            graph.add_edge(row * 20, row * 20 + 19, None)\n        num_qubits = len(graph)\n        rng = np.random.default_rng(seed=12345678942)\n        rz_props = {}\n        x_props = {}\n        sx_props = {}\n        measure_props = {}\n        delay_props = {}\n        self._target = Target("Fake Kookaburra", num_qubits=num_qubits)\n        # Add 1q gates. Globally use virtual rz, x, sx, and measure\n        for i in range(num_qubits):\n            qarg = (i,)\n            rz_props[qarg] = InstructionProperties(error=0.0, duration=0.0)\n            x_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-6, 1e-4),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            sx_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-6, 1e-4),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            measure_props[qarg] = InstructionProperties(\n                error=rng.uniform(1e-3, 1e-1),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n            delay_props[qarg] = None\n        self._target.add_instruction(XGate(), x_props)\n        self._target.add_instruction(SXGate(), sx_props)\n        self._target.add_instruction(RZGate(Parameter("theta")), rz_props)\n        self._target.add_instruction(Measure(), measure_props)\n        self._target.add_instruction(Reset(), measure_props)\n        self._target.add_instruction(Delay(Parameter("t")), delay_props)\n        cz_props = {}\n        for edge in graph.edge_list():\n            cz_props[edge] = InstructionProperties(\n                error=rng.uniform(7e-4, 5e-3),\n                duration=rng.uniform(1e-8, 9e-7),\n            )\n        self._target.add_instruction(CZGate(), cz_props)\n\n    @property\n    def target(self):\n        return self._target\n\n    @property\n    def max_circuits(self):\n        return None\n\n    @classmethod\n    def _default_options(cls):\n        return Options(shots=1024)\n\n    def run(self, circuit, **kwargs):\n        raise NotImplementedError("Lasciate ogne speranza, voi ch\'intrate")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"backend = FakeTorusBackend()\n# We set `figsize` to a smaller size to make the documentation website faster\n# to load. Normally, you do not need to set the argument.\nplot_gate_map(backend, figsize=(4, 4))\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:t(57928).A+"",width:"330",height:"327"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"num_qubits = int(backend.num_qubits / 2)\nfull_device_bv = QuantumCircuit(num_qubits, num_qubits - 1)\nfull_device_bv.x(num_qubits - 1)\nfull_device_bv.h(range(num_qubits))\nfull_device_bv.cx(range(num_qubits - 1), num_qubits - 1)\nfull_device_bv.h(range(num_qubits))\nfull_device_bv.measure(range(num_qubits - 1), range(num_qubits - 1))\ntqc = transpile(full_device_bv, backend, optimization_level=3)\nop_counts = tqc.count_ops()\nprint(f\"CZ gates: {op_counts['cz']}\")\nprint(f\"X gates: {op_counts['x']}\")\nprint(f\"SX gates: {op_counts['sx']}\")\nprint(f\"RZ gates: {op_counts['rz']}\")\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"CZ gates: 867\nX gates: 18\nSX gates: 1630\nRZ gates: 1174\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},57928(e,n,t){t.d(n,{A:()=>a});const a=t.p+"assets/images/1d40864a-7695-438b-95bf-7724c34d92b4-0-3c97774e0f303b4630a50301d69cc627.avif"},5265(e,n,t){t.d(n,{A:()=>a});const a=t.p+"assets/images/6dc04d04-7afb-46f2-8ee6-ac961e4583f5-1-f55eccdf84741627d22a47d4ea2394c6.avif"},25647(e,n,t){t.d(n,{A:()=>a});const a=t.p+"assets/images/b51657ed-bb37-4e1a-9dea-8189b4229d24-0-da9efc135ded308507e6f921a0203f2d.avif"},28453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var a=t(96540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);