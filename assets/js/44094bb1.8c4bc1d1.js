"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1407],{9876(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/operators-overview","title":"Operators module overview","description":"Use the Qiskit quantum information module to construct and manipulate operators","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/operators-overview.mdx","sourceDirName":"guides","slug":"/guides/operators-overview","permalink":"/guides/operators-overview","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/operators-overview.mdx","tags":[],"version":"current","frontMatter":{"title":"Operators module overview","sidebar_label":"Operators module overview","description":"Use the Qiskit quantum information module to construct and manipulate operators","notebook_path":"docs/guides/operators-overview.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Save and retrieve Qiskit objects","permalink":"/guides/save-circuits"},"next":{"title":"Specify observables in the Pauli basis","permalink":"/guides/specify-observables-pauli"}}');var a=n(74848),t=n(28453);const r={title:"Operators module overview",sidebar_label:"Operators module overview",description:"Use the Qiskit quantum information module to construct and manipulate operators",notebook_path:"docs/guides/operators-overview.ipynb"},o="Overview of operator classes",l={},c=[{value:"SparsePauliOp",id:"sparsepauliop",level:2},{value:"Pauli",id:"pauli",level:2},{value:"Operator",id:"operator",level:2},{value:"Next steps",id:"next-steps",level:2}];function p(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",mtext:"mtext",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,t.R)(),...e.components},{Admonition:n,Details:i,OpenInLabBanner:r}=s;return n||m("Admonition",!0),i||m("Details",!0),r||m("OpenInLabBanner",!0),(0,a.jsxs)(a.Fragment,{children:["\n",(0,a.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,a.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,a.jsx)(r,{notebookPath:"docs/guides/operators-overview.ipynb"}),"\n",(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"overview-of-operator-classes",children:"Overview of operator classes"})}),"\n","\n",(0,a.jsxs)(i,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Package versions"})}),(0,a.jsx)(s.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"qiskit[all]~=2.3.0\n"})})]}),"\n",(0,a.jsxs)(s.p,{children:["In Qiskit, quantum operators are represented using classes from the ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/quantum_info",children:(0,a.jsx)(s.code,{children:"quantum_info"})})," module. The most important operator class is ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp",children:(0,a.jsx)(s.code,{children:"SparsePauliOp"})}),", which represents a general quantum operator as a linear combination of Pauli strings. ",(0,a.jsx)(s.code,{children:"SparsePauliOp"})," is the class most commonly used to represent quantum observables. The rest of this page explains how to use ",(0,a.jsx)(s.code,{children:"SparsePauliOp"})," and other operator classes."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"import numpy as np\nfrom qiskit.quantum_info.operators import Operator, Pauli, SparsePauliOp\n"})}),"\n",(0,a.jsx)(s.h2,{id:"sparsepauliop",children:"SparsePauliOp"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp",children:(0,a.jsx)(s.code,{children:"SparsePauliOp"})})," class represents a linear combination of Pauli strings. There are several ways to initialize a ",(0,a.jsx)(s.code,{children:"SparsePauliOp"}),", but the most flexible way is to use the ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.SparsePauliOp#from_sparse_list",children:(0,a.jsx)(s.code,{children:"from_sparse_list"})})," method, as demonstrated in the following code cell. The ",(0,a.jsx)(s.code,{children:"from_sparse_list"})," accepts a list of ",(0,a.jsx)(s.code,{children:"(pauli_string, qubit_indices, coefficient)"})," triplets."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'op1 = SparsePauliOp.from_sparse_list(\n    [("ZX", [1, 4], 1.0), ("YY", [0, 3], -1 + 1j)], num_qubits=5\n)\nop1\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"SparsePauliOp(['XIIZI', 'IYIIY'],\n              coeffs=[ 1.+0.j, -1.+1.j])\n"})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"SparsePauliOp"})," supports arithmetic operations, as demonstrated in the following code cell."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'op2 = SparsePauliOp.from_sparse_list(\n    [("XXZ", [0, 1, 4], 1 + 2j), ("ZZ", [1, 2], -1 + 1j)], num_qubits=5\n)\n\n# Addition\nprint("op1 + op2:")\nprint(op1 + op2)\nprint()\n# Multiplication by a scalar\nprint("2 * op1:")\nprint(2 * op1)\nprint()\n# Operator multiplication (composition)\nprint("op1 @ op2:")\nprint(op1 @ op2)\nprint()\n# Tensor product\nprint("op1.tensor(op2):")\nprint(op1.tensor(op2))\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"op1 + op2:\nSparsePauliOp(['XIIZI', 'IYIIY', 'ZIIXX', 'IIZZI'],\n              coeffs=[ 1.+0.j, -1.+1.j,  1.+2.j, -1.+1.j])\n\n2 * op1:\nSparsePauliOp(['XIIZI', 'IYIIY'],\n              coeffs=[ 2.+0.j, -2.+2.j])\n\nop1 @ op2:\nSparsePauliOp(['YIIYX', 'XIZII', 'ZYIXZ', 'IYZZY'],\n              coeffs=[ 1.+2.j, -1.+1.j, -1.+3.j,  0.-2.j])\n\nop1.tensor(op2):\nSparsePauliOp(['XIIZIZIIXX', 'XIIZIIIZZI', 'IYIIYZIIXX', 'IYIIYIIZZI'],\n              coeffs=[ 1.+2.j, -1.+1.j, -3.-1.j,  0.-2.j])\n"})}),"\n",(0,a.jsx)(s.h2,{id:"pauli",children:"Pauli"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Pauli",children:(0,a.jsx)(s.code,{children:"Pauli"})})," class represents a single Pauli string with an optional phase coefficient from the set ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mo,{stretchy:"false",children:"{"}),(0,a.jsx)(s.mtext,{children:"\u2009"}),(0,a.jsx)(s.mo,{children:"+"}),(0,a.jsx)(s.mn,{children:"1"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mi,{children:"i"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mo,{children:"\u2212"}),(0,a.jsx)(s.mn,{children:"1"}),(0,a.jsx)(s.mo,{separator:"true",children:","}),(0,a.jsx)(s.mo,{children:"\u2212"}),(0,a.jsx)(s.mi,{children:"i"}),(0,a.jsx)(s.mtext,{children:"\u2009"}),(0,a.jsx)(s.mo,{stretchy:"false",children:"}"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\set{+1, i, -1, -i}"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(s.span,{className:"mopen",children:"{"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord",children:"+"}),(0,a.jsx)(s.span,{className:"mord",children:"1"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"i"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord",children:"\u2212"}),(0,a.jsx)(s.span,{className:"mord",children:"1"}),(0,a.jsx)(s.span,{className:"mpunct",children:","}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mord",children:"\u2212"}),(0,a.jsx)(s.span,{className:"mord mathnormal",children:"i"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,a.jsx)(s.span,{className:"mclose",children:"}"})]})})]}),". A ",(0,a.jsx)(s.code,{children:"Pauli"})," can be initialized by passing a string of characters from the set ",(0,a.jsx)(s.code,{children:'{"I", "X", "Y", "Z"}'}),", optionally prefixed by one of ",(0,a.jsx)(s.code,{children:'{"", "i", "-", "-i"}'})," to represent the phase coefficient."]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'op1 = Pauli("iXX")\nop1\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Pauli('iXX')\n"})}),"\n",(0,a.jsx)(s.p,{children:"The following code cell demonstrates the use of some attributes and methods."}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'print(f"Dimension of {op1}: {op1.dim}")\nprint(f"Phase of {op1}: {op1.phase}")\nprint(f"Matrix representation of {op1}: \\n {op1.to_matrix()}")\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Dimension of iXX: (4, 4)\nPhase of iXX: 3\nMatrix representation of iXX: \n [[0.+0.j 0.+0.j 0.+0.j 0.+1.j]\n [0.+0.j 0.+0.j 0.+1.j 0.+0.j]\n [0.+0.j 0.+1.j 0.+0.j 0.+0.j]\n [0.+1.j 0.+0.j 0.+0.j 0.+0.j]]\n"})}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.code,{children:"Pauli"})," objects possess a number of other methods to manipulate the operators such as determining its adjoint, whether it (anti)commutes with another ",(0,a.jsx)(s.code,{children:"Pauli"}),", and computing the dot product with another ",(0,a.jsx)(s.code,{children:"Pauli"}),". Refer to the ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Pauli",children:"API documentation"})," for more info."]}),"\n",(0,a.jsx)(s.h2,{id:"operator",children:"Operator"}),"\n",(0,a.jsxs)(s.p,{children:["The ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Operator",children:(0,a.jsx)(s.code,{children:"Operator"})})," class represents a general linear operator. Unlike ",(0,a.jsx)(s.code,{children:"SparsePauliOp"}),", ",(0,a.jsx)(s.code,{children:"Operator"})," stores the linear operator as a dense matrix. Because the memory required to store a dense matrix scales exponentially with the number of qubits, the ",(0,a.jsx)(s.code,{children:"Operator"})," class is only suitable for use with a small number of qubits."]}),"\n",(0,a.jsxs)(s.p,{children:["You can initialize an ",(0,a.jsx)(s.code,{children:"Operator"})," by directly passing a Numpy array storing the matrix of the operator. For example, the following code cell creates a two-qubit Pauli XX operator:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"XX = Operator(\n    np.array(\n        [\n            [0, 0, 0, 1],\n            [0, 0, 1, 0],\n            [0, 1, 0, 0],\n            [1, 0, 0, 0],\n        ]\n    )\n)\nXX\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Operator([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n          [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n          [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n          [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]],\n         input_dims=(2, 2), output_dims=(2, 2))\n"})}),"\n",(0,a.jsx)(s.p,{children:"The operator object stores the underlying matrix, and the input and output dimension of subsystems."}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"data"}),": To access the underlying Numpy array, you can use the ",(0,a.jsx)(s.code,{children:"Operator.data"})," property."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.code,{children:"dims"}),": To return the total input and output dimension of the operator, you can use the ",(0,a.jsx)(s.code,{children:"Operator.dim"})," property. ",(0,a.jsx)(s.em,{children:"Note: the output is returned as a tuple"})," ",(0,a.jsx)(s.code,{children:"(input_dim, output_dim)"}),", ",(0,a.jsx)(s.em,{children:"which is the reverse of the shape of the underlying matrix."})]}),"\n"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"XX.data\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"array([[0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n       [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"input_dim, output_dim = XX.dim\ninput_dim, output_dim\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"(4, 4)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["The operator class also keeps track of subsystem dimensions, which can be used for composing operators together. These can be accessed using the ",(0,a.jsx)(s.code,{children:"input_dims"})," and ",(0,a.jsx)(s.code,{children:"output_dims"})," functions."]}),"\n",(0,a.jsxs)(s.p,{children:["For ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mn,{children:"2"}),(0,a.jsx)(s.mi,{children:"N"})]})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"2^N"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8413em"}}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord",children:"2"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"N"})})]})})})})})]})]})})]})," by ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsx)(s.mrow,{children:(0,a.jsxs)(s.msup,{children:[(0,a.jsx)(s.mn,{children:"2"}),(0,a.jsx)(s.mi,{children:"M"})]})}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"2^M"})]})})}),(0,a.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.8413em"}}),(0,a.jsxs)(s.span,{className:"mord",children:[(0,a.jsx)(s.span,{className:"mord",children:"2"}),(0,a.jsx)(s.span,{className:"msupsub",children:(0,a.jsx)(s.span,{className:"vlist-t",children:(0,a.jsx)(s.span,{className:"vlist-r",children:(0,a.jsx)(s.span,{className:"vlist",style:{height:"0.8413em"},children:(0,a.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,a.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"M"})})]})})})})})]})]})})]})," operators, the input and output dimensions are automatically assumed to be M-qubit and N-qubit:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'op = Operator(np.random.rand(2**1, 2**2))\nprint("Input dimensions:", op.input_dims())\nprint("Output dimensions:", op.output_dims())\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Input dimensions: (2, 2)\nOutput dimensions: (2,)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["If the input matrix is not divisible into qubit subsystems, then it will be stored as a single-qubit operator. For example, for a ",(0,a.jsxs)(s.span,{className:"katex",children:[(0,a.jsx)(s.span,{className:"katex-mathml",children:(0,a.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(s.semantics,{children:[(0,a.jsxs)(s.mrow,{children:[(0,a.jsx)(s.mn,{children:"6"}),(0,a.jsx)(s.mo,{children:"\xd7"}),(0,a.jsx)(s.mn,{children:"6"})]}),(0,a.jsx)(s.annotation,{encoding:"application/x-tex",children:"6\\times6"})]})})}),(0,a.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.7278em",verticalAlign:"-0.0833em"}}),(0,a.jsx)(s.span,{className:"mord",children:"6"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(s.span,{className:"mbin",children:"\xd7"}),(0,a.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(s.span,{className:"base",children:[(0,a.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,a.jsx)(s.span,{className:"mord",children:"6"})]})]})]})," matrix:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'op = Operator(np.random.rand(6, 6))\nprint("Input dimensions:", op.input_dims())\nprint("Output dimensions:", op.output_dims())\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Input dimensions: (6,)\nOutput dimensions: (6,)\n"})}),"\n",(0,a.jsx)(s.p,{children:"The input and output dimension can also be manually specified when initializing a new operator:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'# Force input dimension to be (4,) rather than (2, 2)\nop = Operator(np.random.rand(2**1, 2**2), input_dims=[4])\nprint("Input dimensions:", op.input_dims())\nprint("Output dimensions:", op.output_dims())\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Input dimensions: (4,)\nOutput dimensions: (2,)\n"})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'# Specify system is a qubit and qutrit\nop = Operator(np.random.rand(6, 6), input_dims=[2, 3], output_dims=[2, 3])\nprint("Input dimensions:", op.input_dims())\nprint("Output dimensions:", op.output_dims())\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Input dimensions: (2, 3)\nOutput dimensions: (2, 3)\n"})}),"\n",(0,a.jsxs)(s.p,{children:["You can also extract just the input or output dimensions of a subset of subsystems using the ",(0,a.jsx)(s.code,{children:"input_dims"})," and ",(0,a.jsx)(s.code,{children:"output_dims"})," functions:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:'print("Dimension of input system 0:", op.input_dims([0]))\nprint("Dimension of input system 1:", op.input_dims([1]))\n'})}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-text",children:"Dimension of input system 0: (2,)\nDimension of input system 1: (3,)\n"})}),"\n",(0,a.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(n,{type:"tip",title:"Recommendations",children:(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Learn how to ",(0,a.jsx)(s.a,{href:"./specify-observables-pauli",children:"specify observables in the Pauli basis"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["See an example of using operators in the ",(0,a.jsx)(s.a,{href:"/tutorials/combine-error-mitigation-techniques",children:"Combine error mitigation options with the Estimator primitive"})," tutorial."]}),"\n",(0,a.jsxs)(s.li,{children:["Read more ",(0,a.jsx)(s.a,{href:"./operator-class",children:"in-depth coverage of the Operator class"}),"."]}),"\n",(0,a.jsxs)(s.li,{children:["Explore the ",(0,a.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.Operator#operator",children:"Operator API"})," reference."]}),"\n"]})})]})}function d(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}function m(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,s,n){n.d(s,{R:()=>r,x:()=>o});var i=n(96540);const a={},t=i.createContext(a);function r(e){const s=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(t.Provider,{value:s},e.children)}}}]);