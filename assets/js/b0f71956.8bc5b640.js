"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[507],{35526(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"guides/run-jobs-session","title":"Run jobs in a session","description":"How to run a quantum computing job in a Qiskit Runtime session.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/run-jobs-session.mdx","sourceDirName":"guides","slug":"/guides/run-jobs-session","permalink":"/guides/run-jobs-session","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/run-jobs-session.mdx","tags":[],"version":"current","frontMatter":{"title":"Run jobs in a session","sidebar_label":"Run jobs in a session","description":"How to run a quantum computing job in a Qiskit Runtime session.","notebook_path":"docs/guides/run-jobs-session.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Run jobs in a batch","permalink":"/guides/run-jobs-batch"},"next":{"title":"Execution modes using REST API","permalink":"/guides/execution-modes-rest-api"}}');var t=n(74848),o=n(28453);const a={title:"Run jobs in a session",sidebar_label:"Run jobs in a session",description:"How to run a quantum computing job in a Qiskit Runtime session.",notebook_path:"docs/guides/run-jobs-session.ipynb"},r=void 0,l={},c=[{value:"Set up to use sessions",id:"set-up-to-use-sessions",level:2},{value:"Open a session",id:"open-a-session",level:2},{value:"Session length",id:"session-length",level:2},{value:"End a session",id:"end-a-session",level:2},{value:"Close a session",id:"close-a-session",level:3},{value:"Check session status",id:"check-session-status",level:2},{value:"Determine session details",id:"determine-session-details",level:2},{value:"Usage patterns",id:"usage-patterns",level:2},{value:"Run two VQE algorithms in a session by using threading",id:"run-two-vqe-algorithms-in-a-session-by-using-threading",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components},{Admonition:n,Details:i,OpenInLabBanner:a}=s;return n||m("Admonition",!0),i||m("Details",!0),a||m("OpenInLabBanner",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,t.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,t.jsx)(a,{notebookPath:"docs/guides/run-jobs-session.ipynb"}),"\n","\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("b",{children:"Package versions"})}),(0,t.jsx)(s.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\nscipy~=1.16.3\n"})})]}),"\n",(0,t.jsx)(n,{type:"note",title:"Note",children:(0,t.jsxs)(s.p,{children:["Open Plan users cannot submit session jobs. Workloads must be run in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.p,{children:"Use sessions when you need dedicated and exclusive access to the QPU."}),"\n",(0,t.jsx)(s.h2,{id:"set-up-to-use-sessions",children:"Set up to use sessions"}),"\n",(0,t.jsxs)(s.p,{children:["Before starting a session, you must ",(0,t.jsx)(s.a,{href:"./install-qiskit",children:"set up Qiskit Runtime"})," and initialize it as a service:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    QiskitRuntimeService,\n    Session,\n    SamplerV2 as Sampler,\n    EstimatorV2 as Estimator,\n)\n\nservice = QiskitRuntimeService()\n"})}),"\n",(0,t.jsx)(s.h2,{id:"open-a-session",children:"Open a session"}),"\n",(0,t.jsxs)(s.p,{children:["You can open a runtime session by using the context manager ",(0,t.jsx)(s.code,{children:"with Session(...)"})," or by initializing the ",(0,t.jsx)(s.code,{children:"Session"}),"\nclass. When you start a session,  you must specify a QPU by passing a ",(0,t.jsx)(s.code,{children:"backend"})," object. The session starts when its first job begins execution."]}),"\n",(0,t.jsx)(n,{type:"note",children:(0,t.jsx)(s.p,{children:"If you open a session but do not submit any jobs to it for 30 minutes, the session automatically closes."})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Session class"})}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"backend = service.least_busy(operational=True, simulator=False)\nsession = Session(backend=backend)\nestimator = Estimator(mode=session)\nsampler = Sampler(mode=session)\n# Close the session because no context manager was used.\nsession.close()\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Context manager"})}),"\n",(0,t.jsx)(s.p,{children:"The context manager automatically opens and closes the session."}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    Session,\n    SamplerV2 as Sampler,\n    EstimatorV2 as Estimator,\n)\n\nbackend = service.least_busy(operational=True, simulator=False)\nwith Session(backend=backend):\n    estimator = Estimator()\n    sampler = Sampler()\n"})}),"\n",(0,t.jsx)("span",{id:"specify-length"}),"\n",(0,t.jsx)(s.h2,{id:"session-length",children:"Session length"}),"\n",(0,t.jsxs)(s.p,{children:["The maximum session time to live (TTL) determines how long a session can run.  You can set this value with the ",(0,t.jsx)(s.code,{children:"max_time"})," parameter. This should exceed the longest job's execution time."]}),"\n",(0,t.jsx)(s.p,{children:"This timer starts when the session starts.  When the value is reached, the session is closed.  Any jobs that are running will finish, but jobs still queued are failed."}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'with Session(backend=backend, max_time="25m"):\n  ...\n'})}),"\n",(0,t.jsx)(s.p,{children:"There is also an interactive time to live (interactive TTL) value that cannot be configured.  If no session jobs are queued within that window, the session is temporarily deactivated."}),"\n",(0,t.jsx)(s.p,{children:"Default values:"}),"\n",(0,t.jsxs)(s.table,{children:[(0,t.jsx)(s.thead,{children:(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.th,{children:"Instance type (Open or Premium Plan)"}),(0,t.jsx)(s.th,{children:"Interactive TTL"}),(0,t.jsx)(s.th,{children:"Maximum TTL"})]})}),(0,t.jsxs)(s.tbody,{children:[(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:"Premium Plan"}),(0,t.jsx)(s.td,{children:"60 sec*"}),(0,t.jsx)(s.td,{children:"8 h*"})]}),(0,t.jsxs)(s.tr,{children:[(0,t.jsx)(s.td,{children:(0,t.jsx)(s.em,{children:"* Certain Premium Plan instances might be configured to have a different value."})}),(0,t.jsx)(s.td,{}),(0,t.jsx)(s.td,{})]})]})]}),"\n",(0,t.jsxs)(s.p,{children:["To determine a session's max TTL or  interactive TTL, follow the instructions in ",(0,t.jsx)(s.a,{href:"#session-details",children:"Determine session details"})," and look for the ",(0,t.jsx)(s.code,{children:"max_time"}),"or ",(0,t.jsx)(s.code,{children:"interactive_timeout"})," value, respectively."]}),"\n",(0,t.jsx)("span",{id:"ends"}),"\n",(0,t.jsx)(s.h2,{id:"end-a-session",children:"End a session"}),"\n",(0,t.jsx)(s.p,{children:"A session ends in the following circumstances:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The maximum timeout (TTL) value is reached, resulting in the cancellation of all queued jobs."}),"\n",(0,t.jsx)(s.li,{children:"The session is manually canceled, resulting in the cancellation of all queued jobs."}),"\n",(0,t.jsx)(s.li,{children:"The session is manually closed.  The session stops accepting new jobs but continues to run queued jobs with priority."}),"\n",(0,t.jsxs)(s.li,{children:["If you use Session as a context manager, that is,  ",(0,t.jsx)(s.code,{children:"with Session()"}),", the session is automatically closed when the context ends (the same behavior as using ",(0,t.jsx)(s.code,{children:"session.close()"}),")."]}),"\n"]}),"\n",(0,t.jsx)("span",{id:"close"}),"\n",(0,t.jsx)(s.h3,{id:"close-a-session",children:"Close a session"}),"\n",(0,t.jsx)(s.p,{children:'A session automatically closes when it exits the context manager. When the session context manager is exited, the session is put into "In progress, not accepting new jobs" status. This means that the session finishes processing all running or queued jobs until the maximum timeout value is reached. After all jobs are completed, the session is immediately closed. This allows the scheduler to run the next job without waiting for the session interactive timeout, thereby reducing the average job queuing time. You cannot submit jobs to a closed session.'}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'from qiskit.quantum_info import SparsePauliOp\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.transpiler import generate_preset_pass_manager\nimport numpy as np\n\n# This cell is hidden from users\nservice = QiskitRuntimeService()\nbackend = service.least_busy()\n\n# Define two circuits, each with one parameter with two parameters.\ncircuit = QuantumCircuit(2)\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.ry(Parameter("a"), 0)\ncircuit.cx(0, 1)\ncircuit.h(0)\ncircuit.measure_all()\n\npm = generate_preset_pass_manager(optimization_level=1, backend=backend)\ntranspiled_circuit = pm.run(circuit)\ntranspiled_circuit_sampler = transpiled_circuit\ntranspiled_circuit_sampler.measure_all()\n\n# Create parameters and mapped observables to submit\nparams = np.random.uniform(size=(2, 3)).T\nobservables = [\n    SparsePauliOp(["XX", "IY"], [0.5, 0.5]),\n    SparsePauliOp("XX"),\n    SparsePauliOp("IY"),\n]\nmapped_observables = [\n    [observable.apply_layout(transpiled_circuit.layout)]\n    for observable in observables\n]\n\nsampler_pub = (transpiled_circuit_sampler, params)\nestimator_pub = (transpiled_circuit_sampler, mapped_observables, params)\n'})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"with Session(backend=backend) as session:\n    estimator = Estimator()\n    sampler = Sampler()\n    job1 = estimator.run([estimator_pub])\n    job2 = sampler.run([sampler_pub])\n\n# The session is no longer accepting jobs but the submitted job will run to completion.\nresult = job1.result()\nresult2 = job2.result()\n"})}),"\n",(0,t.jsx)(n,{type:"tip",children:(0,t.jsxs)(s.p,{children:["If you are not using a context manager, manually close the session to avoid unwanted cost. You can close a session as soon as you are done submitting jobs to it. When a session is closed with ",(0,t.jsx)(s.code,{children:"session.close()"}),", it no longer accepts new jobs, but the already submitted jobs will still run until completion and their results can be retrieved."]})}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'session = Session(backend=backend)\n\n# If using qiskit-ibm-runtime earlier than 0.24.0, change `mode=` to `session=`\nestimator = Estimator(mode=session)\nsampler = Sampler(mode=session)\njob1 = estimator.run([estimator_pub])\njob2 = sampler.run([sampler_pub])\nprint(f"Result1: {job1.result()}")\nprint(f"Result2: {job2.result()}")\n\n# Manually close the session. Running and queued jobs will run to completion.\nsession.close()\n'})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-text",children:"Result1: PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(3, 2), dtype=float64>), stds=np.ndarray(<shape=(3, 2), dtype=float64>), ensemble_standard_error=np.ndarray(<shape=(3, 2), dtype=float64>), shape=(3, 2)), metadata={'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': False, 'enable_measure': True, 'num_randomizations': 'auto', 'shots_per_randomization': 'auto', 'interleave_randomizations': True, 'strategy': 'active-accum'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': False, 'pec_mitigation': False}, 'version': 2})\n"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-text",children:"Result2: PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(3, 2), num_shots=4096, num_bits=2>), meas0=BitArray(<shape=(3, 2), num_shots=4096, num_bits=133>), shape=(3, 2)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([DoubleSliceSpan(<start='2026-01-15 07:53:15', stop='2026-01-15 07:53:21', size=24576>)])}, 'version': 2})\n"})}),"\n",(0,t.jsx)("span",{id:"session-status"}),"\n",(0,t.jsx)(s.h2,{id:"check-session-status",children:"Check session status"}),"\n",(0,t.jsxs)(s.p,{children:["You can query a session's status to understand its current state by using  ",(0,t.jsx)(s.code,{children:"session.status()"})," or by viewing the ",(0,t.jsx)(s.a,{href:"https://quantum.cloud.ibm.com/workloads",children:"Workloads"})," page."]}),"\n",(0,t.jsx)(s.p,{children:"Session status can be one of the following:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Pending"}),": The session has not started or has been deactivated. The next session job needs to wait in the queue like other jobs."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"In progress, accepting new jobs"}),": The session is active and accepting new jobs."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"In progress, not accepting new jobs"}),": The session is active but not accepting new jobs. Job submission to the session is rejected, but outstanding session jobs will run to completion. The session is automatically closed once all jobs finish."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Closed"}),": The session's maximum timeout value has been reached or the session was explicitly closed."]}),"\n"]}),"\n",(0,t.jsx)("span",{id:"session-details"}),"\n",(0,t.jsx)(s.h2,{id:"determine-session-details",children:"Determine session details"}),"\n",(0,t.jsxs)(s.p,{children:["For a comprehensive overview of a session's configuration and status, use the  ",(0,t.jsx)(s.code,{children:"session.details() method"}),"."]}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    QiskitRuntimeService,\n    Session,\n    EstimatorV2 as Estimator,\n)\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\nwith Session(backend=backend) as session:\n    print(session.details())\n"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-text",children:"{'id': 'be84569d-86b5-4a7f-be5e-7d33e80dc220', 'backend_name': 'ibm_torino', 'interactive_timeout': 60, 'max_time': 28800, 'active_timeout': 28800, 'state': 'open', 'accepting_jobs': True, 'last_job_started': None, 'last_job_completed': None, 'started_at': None, 'closed_at': None, 'activated_at': None, 'mode': 'dedicated', 'usage_time': None}\n"})}),"\n",(0,t.jsx)(s.h2,{id:"usage-patterns",children:"Usage patterns"}),"\n",(0,t.jsx)(s.p,{children:"Sessions are especially useful for algorithms that require frequent communication between classical and quantum resources."}),"\n",(0,t.jsx)(s.p,{children:"Example: Run an iterative workload that uses the classical SciPy optimizer to minimize a cost function. In this model, SciPy uses the output of the cost function to calculate its next input."}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'from scipy.optimize import minimize\nfrom qiskit.circuit.library import efficient_su2\n\ndef cost_func(params, ansatz, hamiltonian, estimator):\n    # Return estimate of energy from estimator\n\n    energy = sum(\n        estimator.run([(ansatz, hamiltonian, params)]).result()[0].data.evs\n    )\n    return energy\n\nhamiltonian = SparsePauliOp.from_list(\n    [("YZ", 0.3980), ("ZI", -0.3980), ("ZZ", -0.0113), ("XX", 0.1810)]\n)\nsu2_ansatz = efficient_su2(hamiltonian.num_qubits)\npm = generate_preset_pass_manager(backend=backend, optimization_level=3)\nansatz = pm.run(su2_ansatz)\nmapped_hamiltonian = [\n    operator.apply_layout(ansatz.layout) for operator in hamiltonian\n]\n\nnum_params = ansatz.num_parameters\nx0 = 2 * np.pi * np.random.random(num_params)\n\nsession = Session(backend=backend)\n\n# If using qiskit-ibm-runtime earlier than 0.24.0, change `mode=` to `session=`\nestimator = Estimator(mode=session, options={"default_shots": int(1e4)})\nres = minimize(\n    cost_func,\n    x0,\n    args=(ansatz, mapped_hamiltonian, estimator),\n    method="cobyla",\n    options={"maxiter": 25},\n)\n\n# Close the session because no context manager was used.\nsession.close()\n'})}),"\n",(0,t.jsx)("span",{id:"two-vqe"}),"\n",(0,t.jsx)(s.h2,{id:"run-two-vqe-algorithms-in-a-session-by-using-threading",children:"Run two VQE algorithms in a session by using threading"}),"\n",(0,t.jsx)(s.p,{children:"You can get more out of a session by running multiple workloads simultaneously. The following example shows how you can run two VQE algorithms, each using a different classical optimizer, simultaneously inside a single session. Job tags are also used to differentiate jobs from each workload."}),"\n",(0,t.jsx)(n,{type:"caution",children:(0,t.jsxs)(s.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,t.jsx)(s.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-python",children:'from concurrent.futures import ThreadPoolExecutor\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\ndef minimize_thread(estimator, method):\n    return minimize(\n        cost_func,\n        x0,\n        args=(ansatz, mapped_hamiltonian, estimator),\n        method=method,\n        options={"maxiter": 25},\n    )\n\nwith Session(backend=backend), ThreadPoolExecutor() as executor:\n    estimator1 = Estimator()\n    estimator2 = Estimator()\n\n    # Use different tags to differentiate the jobs.\n    estimator1.options.environment.job_tags = ["cobyla"]\n    estimator2.options.environment.job_tags = ["nelder-mead"]\n\n    # Submit the two workloads.\n    cobyla_future = executor.submit(minimize_thread, estimator1, "cobyla")\n    nelder_mead_future = executor.submit(\n        minimize_thread, estimator2, "nelder-mead"\n    )\n\n    # Get workload results.\n    cobyla_result = cobyla_future.result()\n    nelder_mead_result = nelder_mead_future.result()\n'})}),"\n",(0,t.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,t.jsx)(n,{type:"tip",title:"Recommendations",children:(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Try an example in the ",(0,t.jsx)(s.a,{href:"/tutorials/quantum-approximate-optimization-algorithm",children:"Quantum approximate optimization algorithm (QAOA)"})," tutorial."]}),"\n",(0,t.jsxs)(s.li,{children:["Review the ",(0,t.jsx)(s.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/session",children:"Session API"})," reference."]}),"\n",(0,t.jsxs)(s.li,{children:["Understand the ",(0,t.jsx)(s.a,{href:"/guides/job-limits",children:"Job limits"})," when sending a job to an IBM\xae QPU."]}),"\n",(0,t.jsxs)(s.li,{children:["Review ",(0,t.jsx)(s.a,{href:"/guides/execution-modes-faq",children:"execution modes FAQs."})]}),"\n"]})})]})}function u(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}function m(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,s,n){n.d(s,{R:()=>a,x:()=>r});var i=n(96540);const t={},o=i.createContext(t);function a(e){const s=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);