"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1497],{12181(e,i,n){n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/specify-runtime-options","title":"Specify options","description":"Specify options when building with Qiskit Runtime primitives.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/specify-runtime-options.mdx","sourceDirName":"guides","slug":"/guides/specify-runtime-options","permalink":"/guides/specify-runtime-options","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/specify-runtime-options.mdx","tags":[],"version":"current","frontMatter":{"title":"Specify options","sidebar_label":"Specify options","description":"Specify options when building with Qiskit Runtime primitives.","notebook_path":"docs/guides/specify-runtime-options.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Introduction to options","permalink":"/guides/runtime-options-overview"},"next":{"title":"Error mitigation and suppression techniques","permalink":"/guides/error-mitigation-and-suppression-techniques"}}');var s=n(74848),o=n(28453);const r={title:"Specify options",sidebar_label:"Specify options",description:"Specify options when building with Qiskit Runtime primitives.",notebook_path:"docs/guides/specify-runtime-options.ipynb"},a=void 0,l={},c=[{value:"Set primitive options",id:"set-primitive-options",level:2},{value:"Primitive initialization",id:"primitive-initialization",level:3},{value:"Options class",id:"options-class",level:4},{value:"Dictionary",id:"dictionary",level:4},{value:"Update options after initialization",id:"update-options-after-initialization",level:3},{value:"Run() method",id:"run-method",level:3},{value:"Special cases",id:"special-cases",level:3},{value:"Resilience level (Estimator only)",id:"resilience-level-estimator-only",level:4},{value:"Shots (Sampler only)",id:"shots-sampler-only",level:4},{value:"Precision (Estimator only)",id:"precision-estimator-only",level:4},{value:"Commonly used options",id:"commonly-used-options",level:2},{value:"Shots",id:"shots",level:3},{value:"Maximum execution time",id:"maximum-execution-time",level:3},{value:"Turn off all error mitigation and error suppression",id:"turn-off-all-error-mitigation-and-error-suppression",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components},{Admonition:n,Details:t,OpenInLabBanner:r}=i;return n||h("Admonition",!0),t||h("Details",!0),r||h("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(r,{notebookPath:"docs/guides/specify-runtime-options.ipynb"}),"\n","\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Package versions"})}),(0,s.jsx)(i.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,s.jsxs)(i.p,{children:["You can use options to customize the Estimator and Sampler primitives. This section focuses on how to specify Qiskit Runtime primitive options. While the interface of the primitives' ",(0,s.jsx)(i.code,{children:"run()"}),"  method is common across all implementations, their options are not. Consult the corresponding API references for information about the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/primitives#primitives",children:(0,s.jsx)(i.code,{children:"qiskit.primitives"})})," and ",(0,s.jsx)(i.a,{href:"https://qiskit.github.io/qiskit-aer/apidocs/aer_primitives.html",children:(0,s.jsx)(i.code,{children:"qiskit_aer.primitives"})})," options."]}),"\n",(0,s.jsx)(i.p,{children:"Notes about specifying options in the primitives:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"SamplerV2"})," and ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," have separate options classes. You can see the available options and update option values during or after primitive initialization."]}),"\n",(0,s.jsxs)(i.li,{children:["Use the ",(0,s.jsx)(i.code,{children:"update()"})," method to apply changes to the ",(0,s.jsx)(i.code,{children:"options"})," attribute."]}),"\n",(0,s.jsxs)(i.li,{children:["If you do not specify a value for an option, it is given a special value of ",(0,s.jsx)(i.code,{children:"Unset"})," and the server defaults are used."]}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"options"})," attribute is the ",(0,s.jsx)(i.code,{children:"dataclass"})," Python type.  You can use the built-in ",(0,s.jsx)(i.code,{children:"asdict"})," method to convert it to a dictionary."]}),"\n"]}),"\n",(0,s.jsx)("span",{id:"pass-options"}),"\n",(0,s.jsx)(i.h2,{id:"set-primitive-options",children:"Set primitive options"}),"\n",(0,s.jsxs)(i.p,{children:["You can set options when initializing the primitive, after initializing the primitive, or in the ",(0,s.jsx)(i.code,{children:"run()"})," method. See the ",(0,s.jsx)(i.a,{href:"runtime-options-overview#options-precedence",children:"precedence rules"})," section to understand what happens when the same option is specified in multiple places."]}),"\n",(0,s.jsx)(i.h3,{id:"primitive-initialization",children:"Primitive initialization"}),"\n",(0,s.jsx)(i.p,{children:"You can pass in an instance of the options class or a dictionary when initializing a primitive, which then makes a copy of those options. Thus, changing the original dictionary or options instance doesn't affect the options owned by the primitives."}),"\n",(0,s.jsx)(i.h4,{id:"options-class",children:"Options class"}),"\n",(0,s.jsxs)(i.p,{children:["When creating an instance of the ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," or ",(0,s.jsx)(i.code,{children:"SamplerV2"})," class, you can pass in an instance of the options class. Those options will then be applied when you use ",(0,s.jsx)(i.code,{children:"run()"})," to perform the calculation.  Specify the options in this format:  ",(0,s.jsx)(i.code,{children:"options.option.sub-option.sub-sub-option = choice"}),".  For example: ",(0,s.jsx)(i.code,{children:"options.dynamical_decoupling.enable = True"})]}),"\n",(0,s.jsx)(i.p,{children:"Example:"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"SamplerV2"})," and ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," have separate options classes (",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-estimator-options",children:(0,s.jsx)(i.code,{children:"EstimatorOptions"})})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-sampler-options",children:(0,s.jsx)(i.code,{children:"SamplerOptions"})}),")."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\nfrom qiskit_ibm_runtime.options import EstimatorOptions\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\noptions = EstimatorOptions(\n    resilience_level=2,\n    resilience={"zne_mitigation": True, "zne": {"noise_factors": [1, 3, 5]}},\n)\n\n# or...\noptions = EstimatorOptions()\noptions.resilience_level = 2\noptions.resilience.zne_mitigation = True\noptions.resilience.zne.noise_factors = [1, 3, 5]\n\nestimator = Estimator(mode=backend, options=options)\n'})}),"\n",(0,s.jsx)(i.h4,{id:"dictionary",children:"Dictionary"}),"\n",(0,s.jsx)(i.p,{children:"You can specify options as a dictionary when initializing the primitive."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\nestimator = Estimator(\n    backend,\n    options={\n        "resilience_level": 2,\n        "resilience": {\n            "zne_mitigation": True,\n            "zne": {"noise_factors": [1, 3, 5]},\n        },\n    },\n)\n'})}),"\n",(0,s.jsx)(i.h3,{id:"update-options-after-initialization",children:"Update options after initialization"}),"\n",(0,s.jsxs)(i.p,{children:["You can specify the options in this format: ",(0,s.jsx)(i.code,{children:"primitive.options.option.sub-option.sub-sub-option = choice"})," to take advantage of auto-complete, or use the ",(0,s.jsx)(i.code,{children:"update()"})," method to make bulk updates."]}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"SamplerV2"})," and ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," options classes (",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-estimator-options",children:(0,s.jsx)(i.code,{children:"EstimatorOptions"})})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-sampler-options",children:(0,s.jsx)(i.code,{children:"SamplerOptions"})}),") do not need to be instantiated if you are setting options after initializing the primitive."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\nestimator = Estimator(mode=backend)\n\n# Setting options after primitive initialization\n# This uses auto-complete.\nestimator.options.default_shots = 4000\n# This does bulk update.\nestimator.options.update(\n    default_shots=4000, resilience={"zne_mitigation": True}\n)\n'})}),"\n",(0,s.jsx)("span",{id:"run-method"}),"\n",(0,s.jsx)(i.h3,{id:"run-method",children:"Run() method"}),"\n",(0,s.jsxs)(i.p,{children:["The only values you can pass to ",(0,s.jsx)(i.code,{children:"run()"})," are those defined in the interface.  That is, ",(0,s.jsx)(i.code,{children:"shots"})," for Sampler and ",(0,s.jsx)(i.code,{children:"precision"})," for Estimator. This overwrites any value set for ",(0,s.jsx)(i.code,{children:"default_shots"})," or ",(0,s.jsx)(i.code,{children:"default_precision"})," for the current run."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler\nfrom qiskit.circuit.library import random_iqp\nfrom qiskit.transpiler import generate_preset_pass_manager\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\ncircuit1 = random_iqp(3)\ncircuit1.measure_all()\ncircuit2 = random_iqp(3)\ncircuit2.measure_all()\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=3, backend=backend\n)\n\ntranspiled1 = pass_manager.run(circuit1)\ntranspiled2 = pass_manager.run(circuit2)\n\nsampler = Sampler(mode=backend)\n# Default shots to use if not specified in run()\nsampler.options.default_shots = 500\n# Sample two circuits at 128 shots each.\nsampler.run([transpiled1, transpiled2], shots=128)\n\n# Sample two circuits with different numbers of shots.\n# 100 shots is used for transpiled1 and 200 for transpiled.\nsampler.run([(transpiled1, None, 100), (transpiled2, None, 200)])\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:"<RuntimeJobV2('d5k96cn853es738djikg', 'sampler')>\n"})}),"\n",(0,s.jsx)(i.h3,{id:"special-cases",children:"Special cases"}),"\n",(0,s.jsx)(i.h4,{id:"resilience-level-estimator-only",children:"Resilience level (Estimator only)"}),"\n",(0,s.jsx)(i.p,{children:"The resilience level is not actually an option that directly impacts the primitive query, but specifies a base set of curated options to build off of. In general, level 0 turns off all error mitigation, level 1 turns on options for measurement error mitigation, and level 2 turns on options for gate and measurement error mitigation."}),"\n",(0,s.jsx)(i.p,{children:"Any options you manually specify in addition to the resilience level are applied on top of the base set of options defined by the resilience level. Therefore, in principle, you could set the resilience level to 1, but then turn off measurement mitigation, although this is not advised."}),"\n",(0,s.jsxs)(i.p,{children:["In the following example, setting the resilience level to 0 initially turns off ",(0,s.jsx)(i.code,{children:"zne_mitigation"}),", but ",(0,s.jsx)(i.code,{children:"estimator.options.resilience.zne_mitigation = True"})," overrides the relevant setup from ",(0,s.jsx)(i.code,{children:"estimator.options.resilience_level = 0"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import EstimatorV2, QiskitRuntimeService\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\nestimator = EstimatorV2(backend)\n\nestimator.options.default_shots = 100\nestimator.options.resilience_level = 0\nestimator.options.resilience.zne_mitigation = True\n"})}),"\n",(0,s.jsx)(i.h4,{id:"shots-sampler-only",children:"Shots (Sampler only)"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"SamplerV2.run"})," method accepts two arguments: a list of PUBs, each of which can specify a PUB-specific value for shots, and a shots keyword argument. These shot values are a part of the Sampler execution interface, and are independent of the Runtime Sampler's options.  They take precedence over any values specified as options in order to comply with the Sampler abstraction."]}),"\n",(0,s.jsxs)(i.p,{children:["However, if ",(0,s.jsx)(i.code,{children:"shots"})," is not specified by any PUB or in the run keyword argument (or if they are all ",(0,s.jsx)(i.code,{children:"None"}),"), then the shots value from the options is used, most notably ",(0,s.jsx)(i.code,{children:"default_shots"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"To summarize, this is the order of precedence for specifying shots in the Sampler, for any particular PUB:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"If the PUB specifies shots, use that value."}),"\n",(0,s.jsxs)(i.li,{children:["If the ",(0,s.jsx)(i.code,{children:"shots"})," keyword argument is specified in ",(0,s.jsx)(i.code,{children:"run"}),", use that value."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"num_randomizations"})," and ",(0,s.jsx)(i.code,{children:"shots_per_randomization"})," are specified as ",(0,s.jsx)(i.code,{children:"twirling"})," options, shots are the product of those values."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"sampler.options.default_shots"})," is specified, use that value."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Thus, if shots are specified in all possible places, the one with highest precedence (shots specified in the PUB) is used."}),"\n",(0,s.jsx)(i.h4,{id:"precision-estimator-only",children:"Precision (Estimator only)"}),"\n",(0,s.jsxs)(i.p,{children:["Precision is analogous to shots, described in the previous section, except that the Estimator options contain both ",(0,s.jsx)(i.code,{children:"default_shots"})," and ",(0,s.jsx)(i.code,{children:"default_precision"}),". In addition, because gate-twirling is enabled by default, the product of ",(0,s.jsx)(i.code,{children:"num_randomizations"})," and ",(0,s.jsx)(i.code,{children:"shots_per_randomization"})," takes precedence over those two options."]}),"\n",(0,s.jsx)(i.p,{children:"Specifically, for any particular Estimator PUB:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"If the PUB specifies precision, use that value."}),"\n",(0,s.jsxs)(i.li,{children:["If the precision keyword argument is specified in ",(0,s.jsx)(i.code,{children:"run"}),", use that value."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"num_randomizations"})," and ",(0,s.jsx)(i.code,{children:"shots_per_randomization"})," are specified as ",(0,s.jsxs)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-twirling-options",children:[(0,s.jsx)(i.code,{children:"twirling"})," options"]})," (enabled by default), use their product to control the amount of data."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"estimator.options.default_shots"})," is specified, use that value to control the amount of data."]}),"\n",(0,s.jsxs)(i.li,{children:["If ",(0,s.jsx)(i.code,{children:"estimator.options.default_precision"})," is specified, use that value."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"For example, if precision is specified in all four places, the one with highest precedence (precision specified in the PUB) is used."}),"\n",(0,s.jsx)(n,{type:"note",children:(0,s.jsx)(i.p,{children:"Precision scales inversely with usage.  That is, the lower the precision, the more QPU time it takes to run."})}),"\n",(0,s.jsx)(i.h2,{id:"commonly-used-options",children:"Commonly used options"}),"\n",(0,s.jsx)(i.p,{children:"There are many available options, but the following are the most commonly used:"}),"\n",(0,s.jsx)("span",{id:"shots"}),"\n",(0,s.jsx)(i.h3,{id:"shots",children:"Shots"}),"\n",(0,s.jsx)(i.p,{children:"For some algorithms, setting a specific number of shots is a core part of their routines.  Shots (or precision) can be specified in multiple places.  They are prioritized as follows:"}),"\n",(0,s.jsx)(i.p,{children:"For any Sampler PUB:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Integer-valued shots contained in the PUB"}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"run(...,shots=val)"})," value"]}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"options.default_shots"})," value"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"For any Estimator PUB:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Float-valued precision contained in the PUB"}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"run(...,precision=val)"})," value"]}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"options.default_shots"})," value"]}),"\n",(0,s.jsxs)(i.li,{children:["The ",(0,s.jsx)(i.code,{children:"options.default_precision"})," value"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Example:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler\nfrom qiskit.circuit.library import random_iqp\nfrom qiskit.transpiler import generate_preset_pass_manager\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\ncircuit1 = random_iqp(3)\ncircuit1.measure_all()\ncircuit2 = random_iqp(3)\ncircuit2.measure_all()\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=3, backend=backend\n)\n\ntranspiled1 = pass_manager.run(circuit1)\ntranspiled2 = pass_manager.run(circuit2)\n\n# Setting shots during primitive initialization\nsampler = Sampler(mode=backend, options={"default_shots": 4096})\n\n# Setting options after primitive initialization\n# This uses auto-complete.\nsampler.options.default_shots = 2000\n\n# This does bulk update.  The value for default_shots is overridden if you specify shots with run() or in the PUB.\nsampler.options.update(\n    default_shots=1024, dynamical_decoupling={"sequence_type": "XpXm"}\n)\n\n# Sample two circuits at 128 shots each.\nsampler.run([transpiled1, transpiled2], shots=128)\n'})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:"<RuntimeJobV2('d5k96icjt3vs73ds5t0g', 'sampler')>\n"})}),"\n",(0,s.jsx)(i.h3,{id:"maximum-execution-time",children:"Maximum execution time"}),"\n",(0,s.jsxs)(i.p,{children:["The maximum execution time (",(0,s.jsx)(i.code,{children:"max_execution_time"}),") limits how long a job can run.  If a job exceeds this time limit, it is forcibly canceled.  This value applies to single jobs, whether they are run in job, session, or batch mode."]}),"\n",(0,s.jsx)(i.p,{children:"The value is set in seconds, based on quantum time (not wall clock time), which is the amount of time that the QPU is dedicated to processing your job.  It is ignored when using local testing mode because that mode does not use quantum time."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\nestimator = Estimator(mode=backend)\n\nestimator.options.max_execution_time = 2500\n"})}),"\n",(0,s.jsx)("span",{id:"no-error-mitigation"}),"\n",(0,s.jsx)(i.h2,{id:"turn-off-all-error-mitigation-and-error-suppression",children:"Turn off all error mitigation and error suppression"}),"\n",(0,s.jsxs)(i.p,{children:["You can turn off all error mitigation and suppression if you are, for example, doing research on your own mitigation techniques. To accomplish this, for EstimatorV2, set ",(0,s.jsx)(i.code,{children:"resilience_level = 0"}),". For SamplerV2, no changes are necessary because no error mitigation or suppression options are enabled by default."]}),"\n",(0,s.jsx)(i.p,{children:"Example:"}),"\n",(0,s.jsx)(i.p,{children:"Turn off all error mitigation and suppression in Estimator."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import EstimatorV2 as Estimator, QiskitRuntimeService\n\n# Define the service.  This allows you to access IBM QPU.\nservice = QiskitRuntimeService()\n\n# Get a backend\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Define Estimator\nestimator = Estimator(backend)\n\noptions = estimator.options\n\n# Turn off all error mitigation and suppression\noptions.resilience_level = 0\n"})}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(n,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Find more details about the ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," methods in the ",(0,s.jsx)(i.a,{href:"../api/qiskit-ibm-runtime/estimator-v2",children:"Estimator API reference"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Find more details about the ",(0,s.jsx)(i.code,{children:"SamplerV2"})," methods in the ",(0,s.jsx)(i.a,{href:"../api/qiskit-ibm-runtime/sampler-v2",children:"Sampler API reference"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Find details about how to configure ",(0,s.jsx)(i.a,{href:"configure-error-suppression",children:"error suppression"})," and ",(0,s.jsx)(i.a,{href:"configure-error-mitigation",children:"error mitigation"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Decide what ",(0,s.jsx)(i.a,{href:"execution-modes",children:"execution mode"})," to run your job in."]}),"\n"]})})]})}function p(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function h(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,i,n){n.d(i,{R:()=>r,x:()=>a});var t=n(96540);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);