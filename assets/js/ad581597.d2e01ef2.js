"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[4593],{64939(e,i,t){t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>l,metadata:()=>n,toc:()=>m});const n=JSON.parse('{"id":"guides/v2-primitives","title":"Migrate to the V2 primitives","description":"Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (Estimator V2 and Sampler V2)","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/v2-primitives.mdx","sourceDirName":"guides","slug":"/guides/v2-primitives","permalink":"/guides/v2-primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/v2-primitives.mdx","tags":[],"version":"current","frontMatter":{"title":"Migrate to the V2 primitives","description":"Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (Estimator V2 and Sampler V2)"},"sidebar":"tutorialsSidebar","previous":{"title":"Migrate from Qiskit Pulse to fractional gates","permalink":"/guides/pulse-migration"},"next":{"title":"Migrate to local simulators","permalink":"/guides/local-simulators"}}');var s=t(74848),r=t(28453),a=t(11470),o=t(19365);const l={title:"Migrate to the V2 primitives",description:"Migrate from using the original primitives (Estimator and Sampler) to using the updated V2 primitives (Estimator V2 and Sampler V2)"},u="Migrate to the Qiskit Runtime V2 primitives",c={},m=[{value:"Overview",id:"overview",level:2},{value:"Major changes",id:"major-changes",level:2},{value:"Import",id:"import",level:3},{value:"Input and output",id:"input-and-output",level:3},{value:"Input",id:"input",level:4},{value:"Examples",id:"examples",level:5},{value:"Output",id:"output",level:4},{value:"Estimator examples (input and output)",id:"estimator-examples-input-and-output",level:4},{value:"Sampler examples  (input and output)",id:"sampler-examples--input-and-output",level:4},{value:"Options",id:"options",level:3},{value:"Error mitigation and suppression",id:"error-mitigation-and-suppression",level:3},{value:"Transpilation",id:"transpilation",level:3},{value:"Job status",id:"job-status",level:3},{value:"Steps to migrate to Estimator V2",id:"steps-to-migrate-to-estimator-v2",level:2},{value:"Estimator full examples",id:"estimator-full-examples",level:2},{value:"Run a single experiment",id:"run-a-single-experiment",level:3},{value:"Run multiple experiments in a single job",id:"run-multiple-experiments-in-a-single-job",level:3},{value:"Run parameterized circuits",id:"run-parameterized-circuits",level:3},{value:"Use sessions and advanced options",id:"use-sessions-and-advanced-options",level:3},{value:"Steps to migrate to Sampler V2",id:"steps-to-migrate-to-sampler-v2",level:2},{value:"Sampler full examples",id:"sampler-full-examples",level:2},{value:"Run a single experiment",id:"run-a-single-experiment-1",level:3},{value:"Run multiple experiments in a single job",id:"run-multiple-experiments-in-a-single-job-1",level:3},{value:"Run parameterized circuits",id:"run-parameterized-circuits-1",level:3},{value:"Use sessions and advanced options",id:"use-sessions-and-advanced-options-1",level:3},{value:"Next steps",id:"next-steps",level:2}];function p(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Admonition:t}=i;return t||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n","\n","\n",(0,s.jsx)("span",{id:"v2-primitives"}),"\n",(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"migrate-to-the-qiskit-runtime-v2-primitives",children:"Migrate to the Qiskit Runtime V2 primitives"})}),"\n",(0,s.jsx)(t,{type:"warning",children:(0,s.jsxs)(i.p,{children:["The original primitives (referred to as the V1 primitives), ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/0.26/sampler-v1",children:"V1 Sampler"})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/0.26/estimator-v1",children:"V1 Estimator"}),", have been deprecated in ",(0,s.jsx)(i.code,{children:"qiskit-ibm-runtime"})," 0.23.\nTheir support was removed on 15 August 2024."]})}),"\n",(0,s.jsx)(i.p,{children:"With the deprecation of the V1 primitives, all code should be migrated to use the V2 interfaces. This guide describes what changed in the Qiskit Runtime V2 primitives (available with qiskit-ibm-runtime 0.21.0) and why, describes each new primitive in detail, and gives examples to help you migrate code from using the legacy primitives to the V2 primitives.  The examples in the guide all use the Qiskit Runtime primitives, but in general, the same changes apply to the other primitive implementations.  The functions unique to Qiskit Runtime such as error mitigation remain unique to Qiskit Runtime."}),"\n",(0,s.jsxs)(i.p,{children:["For information about the changes to the Qiskit reference primitives (now called ",(0,s.jsx)(i.em,{children:"statevector"})," primitives), see ",(0,s.jsx)(i.a,{href:"qiskit-1.0-features#qiskit.primitives",children:"the qiskit.primitives section"})," in the Qiskit 1.0 feature changes page.  See ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.StatevectorSampler",children:"StatevectorSampler"})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.StatevectorEstimator",children:"StatevectorEstimator"})," for V2 primitive reference implementations."]}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(i.p,{children:["Version 2 of the primitives is introduced with a new base class for both Sampler and Estimator (",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BaseSamplerV2",children:"BaseSamplerV2"})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BaseEstimatorV2",children:"BaseEstimatorV2"}),"), along with new types for their inputs and outputs."]}),"\n",(0,s.jsxs)(i.p,{children:["The new interface lets you specify a single circuit and multiple observables (if using Estimator) and parameter value sets for that circuit, so that sweeps over parameter value sets and observables can be efficiently specified. Previously, you had to specify the same circuit multiple times to match the size of the data to be combined.  Also, while you can still use  ",(0,s.jsx)(i.code,{children:"resilience_level"})," (if using Estimator) as the simple knob, V2 primitives give you the flexibility to turn on or off individual error mitigation / suppression methods to customize them for your needs."]}),"\n",(0,s.jsxs)(i.p,{children:["To reduce the total job execution time, V2 primitives only accept circuits and observables that use instructions supported by the target QPU (quantum processing unit).  Such circuits and observables are referred to as instruction set architecture (ISA) circuits and observables. V2 primitives do not perform layout, routing, and translation operations.  See the ",(0,s.jsx)(i.a,{href:"/guides/transpile",children:"transpilation documentation"})," for instructions to transform circuits."]}),"\n",(0,s.jsx)(i.p,{children:"Sampler V2 is simplified to focus on its core task of sampling the output register from execution of quantum circuits. It returns the samples, whose type is defined by the program, without weights. The output data is also separated by the output register names defined by the program. This change enables future support for circuits with classical control flow."}),"\n",(0,s.jsxs)(i.p,{children:["See the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2",children:"EstimatorV2 API reference"})," and ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2",children:"SamplerV2 API reference"})," for full details."]}),"\n",(0,s.jsx)(i.h2,{id:"major-changes",children:"Major changes"}),"\n",(0,s.jsx)(i.h3,{id:"import",children:"Import"}),"\n",(0,s.jsxs)(i.p,{children:["For backward compatibility, you must explicity import the V2 primitives. Specifying ",(0,s.jsx)(i.code,{children:"import\xa0<primitive>V2\xa0as\xa0<primitive>"})," is not required, but makes it easier to transition code to V2."]}),"\n",(0,s.jsx)(t,{type:"warning",children:(0,s.jsxs)(i.p,{children:["After the V1 primitives are no longer supported, ",(0,s.jsx)(i.code,{children:"import\xa0<primitive>"})," will import the V2 version of the specified primitive."]})}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import EstimatorV2 as Estimator\n"})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import Estimator\n"})})})]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import SamplerV2 as Sampler\n"})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import Sampler\n"})})})]}),"\n",(0,s.jsx)(i.h3,{id:"input-and-output",children:"Input and output"}),"\n",(0,s.jsx)(i.h4,{id:"input",children:"Input"}),"\n",(0,s.jsxs)(i.p,{children:["Both ",(0,s.jsx)(i.code,{children:"SamplerV2"})," and ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," take one or more ",(0,s.jsx)(i.em,{children:"primitive unified blocs"})," (PUBs) as the input. Each PUB is a tuple that contains ",(0,s.jsx)(i.strong,{children:"one"})," circuit and the data broadcasted to that circuit, which can be multiple observables and parameters.  Each PUB returns a result."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Sampler V2 PUB format: (",(0,s.jsx)(i.code,{children:"<circuit>"}),", ",(0,s.jsx)(i.code,{children:"<parameter values>"}),", ",(0,s.jsx)(i.code,{children:"<shots>"}),"), where ",(0,s.jsx)(i.code,{children:"<parameter values>"}),"and ",(0,s.jsx)(i.code,{children:"<shots>"})," are optional."]}),"\n",(0,s.jsxs)(i.li,{children:["Estimator V2 PUB format: (",(0,s.jsx)(i.code,{children:"<circuit>"}),", ",(0,s.jsx)(i.code,{children:"<observables>"}),", ",(0,s.jsx)(i.code,{children:"<parameter values>"}),", ",(0,s.jsx)(i.code,{children:"<precision>"}),"), where ",(0,s.jsx)(i.code,{children:"<parameter values>"}),"and ",(0,s.jsx)(i.code,{children:"<precision>"})," are optional.\nNumpy ",(0,s.jsx)(i.a,{href:"https://numpy.org/doc/stable/user/basics.broadcasting.html",children:"broadcasting rules"})," are used when combining observables and parameter values."]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Additionally, the following changes have been made:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Estimator V2 has gained a ",(0,s.jsx)(i.code,{children:"precision"})," argument in the ",(0,s.jsx)(i.code,{children:"run()"})," method that specifies the targeted precision of the expectation value estimates."]}),"\n",(0,s.jsxs)(i.li,{children:["Sampler V2 has the ",(0,s.jsx)(i.code,{children:"shots"})," argument in its ",(0,s.jsx)(i.code,{children:"run()"})," method."]}),"\n"]}),"\n",(0,s.jsx)(i.h5,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(i.p,{children:["Estimator V2 example that uses precision in ",(0,s.jsx)(i.code,{children:"run()"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Estimate expectation values for two PUBs, both with 0.05 precision.\nestimator.run([(circuit1, obs_array1), (circuit2, obs_array_2)], precision=0.05)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["Sampler V2 example that uses shots in ",(0,s.jsx)(i.code,{children:"run()"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'# Sample two circuits at 128 shots each.\nsampler.run([circuit1, circuit2], shots=128)\n\n# Sample two circuits at different amounts of shots.\n# The "None"s are necessary as placeholders\n# for the lack of parameter values in this example.\nsampler.run([\n  (circuit1, None, 123),\n  (circuit2, None, 456),\n])\n'})}),"\n",(0,s.jsx)(i.h4,{id:"output",children:"Output"}),"\n",(0,s.jsxs)(i.p,{children:["The output is now in the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.PubResult",children:(0,s.jsx)(i.code,{children:"PubResult"})})," format. A ",(0,s.jsx)(i.code,{children:"PubResult"})," is the data and metadata resulting from a single PUB\u2019s execution."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Estimator V2 continues to return expectation values."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"data"})," portion of a Estimator V2 PubResult contains both expectation values and standard errors (",(0,s.jsx)(i.code,{children:"stds"}),"). V1 returned variance in metadata."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Sampler V2 returns per-shot measurements in the form of ",(0,s.jsx)(i.strong,{children:"bitstrings"}),",\ninstead of the quasi-probability distributions from the V1\ninterface. The bitstrings show the measurement outcomes, preserving the shot\norder in which they were measured."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Sampler V2 has convenience methods like ",(0,s.jsx)(i.code,{children:"get_counts()"})," to help with migration."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["The Sampler V2 result objects organize data in terms of their ",(0,s.jsx)(i.strong,{children:"input circuits' classical register names"}),", for\ncompatibility with dynamic circuits.  By default, the classical register name is ",(0,s.jsx)(i.code,{children:"meas"}),", as shown in the following example.  When defining your circuit, if you create one or more classical registers with a non-default name, use that name to get the results. You can find the classical register name by running ",(0,s.jsx)(i.code,{children:"<circuit_name>.cregs"}),". For example, ",(0,s.jsx)(i.code,{children:"qc.cregs"}),"."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Define a quantum circuit with 2 qubits\ncircuit = QuantumCircuit(2)\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.measure_all()\ncircuit.draw()\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:"        \u250c\u2500\u2500\u2500\u2510      \u2591 \u250c\u2500\u2510\n   q_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\u2500\u2591\u2500\u2524M\u251c\u2500\u2500\u2500\n        \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510 \u2591 \u2514\u2565\u2518\u250c\u2500\u2510\n   q_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\u2500\u2591\u2500\u2500\u256b\u2500\u2524M\u251c\n             \u2514\u2500\u2500\u2500\u2518 \u2591  \u2551 \u2514\u2565\u2518\nmeas: 2/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n                      0  1\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.h4,{id:"estimator-examples-input-and-output",children:"Estimator examples (input and output)"}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"Estimator14",label:"1 circuit, 4 observables",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Estimator V1: Execute 1 circuit with 4 observables\njob = estimator_v1.run([circuit] * 4, [obs1, obs2, obs3, obs4])\nevs = job.result().values\n\n# Estimator V2: Execute 1 circuit with 4 observables\njob = estimator_v2.run([(circuit, [obs1, obs2, obs3, obs4])])\nevs = job.result()[0].data.evs\n"})})}),(0,s.jsx)(o.A,{value:"Estimator142",label:"1 circuit, 4 observables, 2 parameter sets",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Estimator V1: Execute 1 circuit with 4 observables and 2 parameter sets\njob = estimator_v1.run([circuit] * 8, [obs1, obs2, obs3, obs4] * 2, [vals1, vals2] * 4)\nevs = job.result().values\n\n# Estimator V2: Execute 1 circuit with 4 observables and 2 parameter sets\n\njob = estimator_v2.run([(circuit, [[obs1], [obs2], [obs3], [obs4]], [[vals1], [vals2]])])\nevs = job.result()[0].data.evs\n"})})}),(0,s.jsx)(o.A,{value:"Estimator22",label:"2 circuits, 2 observables",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Estimator V1: Cannot execute 2 circuits with different observables\n\n# Estimator V2: Execute 2 circuits with 2 different observables.  There are\n# two PUBs because each PUB can have only one circuit.\njob = estimator_v2.run([(circuit1, obs1), (circuit2, obs2)])\nevs1 = job.result()[0].data.evs  # result for pub 1 (circuit 1)\nevs2 = job.result()[1].data.evs  # result for pub 2 (circuit 2)\n"})})})]}),"\n",(0,s.jsx)("span",{id:"sampler-examples"}),"\n",(0,s.jsx)(i.h4,{id:"sampler-examples--input-and-output",children:"Sampler examples  (input and output)"}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"Sampler13",label:"1 circuit, 3 parameter sets",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"  # Sampler V1: Execute 1 circuit with 3 parameter sets\n  job = sampler_v1.run([circuit] * 3, [vals1, vals2, vals3])\n  dists = job.result().quasi_dists\n\n  # Sampler V2: Executing 1 circuit with 3 parameter sets\n  job = sampler_v2.run([(circuit, [vals1, vals2, vals3])])\n  counts = job.result()[0].data.meas.get_counts()\n"})})}),(0,s.jsx)(o.A,{value:"Sampler21",label:"2 circuits, 1 parameter set",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Sampler V1: Execute 2 circuits with 1 parameter set\n  job = sampler_v1.run([circuit1, circuit2], [vals1] * 2)\n  dists = job.result().quasi_dists\n\n  # Sampler V2: Execute 2 circuits with 1 parameter set\n  job = sampler_v2.run([(circuit1, vals1), (circuit2, vals1)])\n  counts1 = job.result()[0].data.meas.get_counts()  # result for pub 1 (circuit 1)\n  counts2 = job.result()[1].data.meas.get_counts()  # result for pub 2 (circuit 2)\n"})})}),(0,s.jsxs)(o.A,{value:"SamplerOut",label:"Convert V2 output to V1 format",children:[(0,s.jsxs)(i.p,{children:["The V1 output format was a dictionary of bitstrings (as an int) as the key and quasi-probabilities as the value for each circuit. The V2 format has the same key (but as a string) and counts as the value. To convert the V2 format to V1, divide the counts by the number of shots, where the number of shots selected is described in the ",(0,s.jsx)(i.a,{href:"/guides/specify-runtime-options#shots",children:"Specify options"})," guide."]}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"v2_result = sampler_v2_job.result()\nv1_format = []\nfor pub_result in v2_result:\n    counts = pub_result.data.meas.get_counts()\n    v1_format.append( {int(key, 2): val/shots for key, val in counts.items()} )\n"})})]})]}),"\n",(0,s.jsx)(i.p,{children:"Example that uses different output registers"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\n\nalpha = ClassicalRegister(5, "alpha")\nbeta = ClassicalRegister(7, "beta")\nqreg = QuantumRegister(12)\n\ncircuit = QuantumCircuit(qreg, alpha, beta)\ncircuit.h(0)\ncircuit.measure(qreg[:5], alpha)\ncircuit.measure(qreg[5:], beta)\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=12)\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\n\nsampler = Sampler(backend)\njob = sampler.run([isa_circuit])\nresult = job.result()\n# Get results for the first (and only) PUB\npub_result = result[0]\nprint(f" >> Counts for the alpha output register: {pub_result.data.alpha.get_counts()}")\nprint(f" >> Counts for the beta output register: {pub_result.data.beta.get_counts()}")\n'})}),"\n",(0,s.jsx)("span",{id:"v2-prim-options"}),"\n",(0,s.jsx)(i.h3,{id:"options",children:"Options"}),"\n",(0,s.jsx)(i.p,{children:"Options are specified differently in the V2 primitives in these ways:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"SamplerV2"})," and ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," now have separate options classes. You can see the available options and update option values during or after primitive initialization."]}),"\n",(0,s.jsxs)(i.li,{children:["Instead of the ",(0,s.jsx)(i.code,{children:"set_options()"})," method, V2 primitive options have the ",(0,s.jsx)(i.code,{children:"update()"})," method that applies changes to the ",(0,s.jsx)(i.code,{children:"options"})," attribute."]}),"\n",(0,s.jsxs)(i.li,{children:["If you do not specify a value for an option, it is given a special value of ",(0,s.jsx)(i.code,{children:"Unset"})," and the server defaults are used."]}),"\n",(0,s.jsxs)(i.li,{children:["For V2 primitives, the ",(0,s.jsx)(i.code,{children:"options"})," attribute is the ",(0,s.jsx)(i.code,{children:"dataclass"})," Python type.  You can use the built-in ",(0,s.jsx)(i.code,{children:"asdict"})," method to convert it to a dictionary."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["See the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options",children:"API reference"})," for the list of available options."]}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from dataclasses import asdict\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\nestimator = Estimator(backend, options={"resilience_level": 2})\n\n# Setting options after primitive initialization\n# This uses auto complete.\nestimator.options.default_shots = 4000\n# This does bulk update.\nestimator.options.update(default_shots=4000, resilience_level=2)\n\n# Print the dictionary format.\n# Server defaults are used for unset options.\nprint(asdict(estimator.options))\n'})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\noptions = Options()\n# This uses auto complete.\noptions.resilience_level = 2\nestimator = Estimator(backend=backend, options=options)\n\n# Setting options after primitive initialization.\n# This does bulk update.\nestimator.set_options(shots=4000)\n"})})})]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from dataclasses import asdict\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\nsampler = Sampler(backend, options={"default_shots": 4096})\n\n# Setting options after primitive initialization\n# This uses auto complete.\nsampler.options.dynamical_decoupling.enable = True\n# Turn on gate twirling. Requires qiskit_ibm_runtime 0.23.0 or later.\nsampler.options.twirling.enable_gates = True\n\n# This does bulk update.  The value for default_shots is overridden if you specify shots with run() or in the PUB.\nsampler.options.update(default_shots=1024, dynamical_decoupling={"sequence_type": "XpXm"})\n\n# Print the dictionary format.\n# Server defaults are used for unset options.\nprint(asdict(sampler.options))\n'})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Options\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\noptions = Options()\n# This uses auto complete.\noptions.resilience_level = 2\nsampler = Sampler(backend=backend, options=options)\n\n# Setting options after primitive initialization.\n# This does bulk update.\nsampler.set_options(shots=2000)\n"})})})]}),"\n",(0,s.jsx)("span",{id:"error-mit"}),"\n",(0,s.jsx)(i.h3,{id:"error-mitigation-and-suppression",children:"Error mitigation and suppression"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Because Sampler V2 returns samples without postprocessing, it does not support resilience levels."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Sampler V2 does not support ",(0,s.jsx)(i.code,{children:"optimization_level"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Estimator V2 will drop support for ",(0,s.jsx)(i.code,{children:"optimization_level"})," on or around 30 September 2024."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Estimator V2 does not support resilience level 3.  This is because resilience level 3 in V1 Estimator uses Probabilistic Error Cancellation (PEC), which is proven to give unbiased results at the cost of exponential processing time. Level 3 was removed to draw attention to that tradeoff. You can, however, still use PEC as the error mitigation method by specifying the ",(0,s.jsx)(i.code,{children:"pec_mitigation"})," option."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Estimator V2 supports ",(0,s.jsx)(i.code,{children:"resilience_level"})," 0-2, as described in the following table.  These options are more advanced than their V1 counterparts. You can also explicitly turn on / off individual error mitigation / suppression methods."]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Level 1"}),(0,s.jsx)(i.th,{children:"Level 2"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Measurement twirling"}),(0,s.jsx)(i.td,{children:"Measurement twirling"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"Readout error mitigation"}),(0,s.jsx)(i.td,{children:"Readout error mitigation"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{}),(0,s.jsx)(i.td,{children:"ZNE"})]})]})]}),"\n"]}),"\n"]}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from dataclasses import asdict\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\n# Setting options during primitive initialization\nestimator = Estimator(backend)\n\n# Set resilience_level to 0\nestimator.options.resilience_level = 0\n\n# Turn on measurement error mitigation\nestimator.options.resilience.measure_mitigation = True\n"})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import Estimator, Options\n\nestimator = Estimator(backend, options=options)\n\noptions = Options()\n\noptions.resilience_level = 2\n"})})})]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_runtime import SamplerV2 as Sampler\n\nsampler = Sampler(backend)\n# Turn on dynamical decoupling with sequence XpXm.\nsampler.options.dynamical_decoupling.enable = True\nsampler.options.dynamical_decoupling.sequence_type = "XpXm"\n\nprint(f">> dynamical decoupling sequence to use: {sampler.options.dynamical_decoupling.sequence_type}")\n'})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit_ibm_runtime import Sampler, Options\n\nsampler = Sampler(backend, options=options)\n\noptions = Options()\n\noptions.resilience_level = 2\n"})})})]}),"\n",(0,s.jsx)("span",{id:"transpilation"}),"\n",(0,s.jsx)(i.h3,{id:"transpilation",children:"Transpilation"}),"\n",(0,s.jsx)(i.p,{children:"V2 primitives support only circuits that adhere to the Instruction Set Architecture (ISA) of a particular backend. Because the primitives do not perform layout, routing, and translation operations, the corresponding transpilation options from V1 are not supported."}),"\n",(0,s.jsx)(i.h3,{id:"job-status",children:"Job status"}),"\n",(0,s.jsxs)(i.p,{children:["The V2 primitives have a new ",(0,s.jsx)(i.code,{children:"RuntimeJobV2"})," class, which inherits from ",(0,s.jsx)(i.code,{children:"BasePrimitiveJob"}),". The ",(0,s.jsx)(i.code,{children:"status()"})," method of this new class returns a string instead of a JobStatus enum from Qiskit. See the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/runtime-job-v2",children:"RuntimeJobV2 API reference"})," for details."]}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"V2",label:"V2 primitives",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'job = estimator.run(...)\n\n# check if a job is still running\nprint(f"Job {job.job_id()} is still running: {job.status() == "RUNNING"}")\n'})})}),(0,s.jsx)(o.A,{value:"V1",label:"V1 primitives",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit.providers.jobstatus import JobStatus\n\njob = estimator.run(...)\n\n#check if a job is still running\nprint(f"Job {job.job_id()} is still running: {job.status() is JobStatus.RUNNING}")\n'})})})]}),"\n",(0,s.jsx)(i.h2,{id:"steps-to-migrate-to-estimator-v2",children:"Steps to migrate to Estimator V2"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Replace ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import Estimator"})," with ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import EstimatorV2 as Estimator"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Remove any ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import Options"})," statements, since the ",(0,s.jsx)(i.code,{children:"Options"})," class is not used by V2 primitives. You can instead pass options as a dictionary when initializing the ",(0,s.jsx)(i.code,{children:"EstimatorV2"})," class (for example ",(0,s.jsx)(i.code,{children:"estimator = Estimator(backend, options={\u201cdynamical_decoupling\u201d: {\u201cenable\u201d: True}})"}),"), or set them after initialization:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"estimator = Estimator(backend)\nestimator.options.dynamical_decoupling.enable = True\n"})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Review all the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options",children:"supported options"})," and make updates accordingly."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Group each circuit you want to run with the observables and parameter values you want to apply to the circuit in a tuple (a PUB). For example, use ",(0,s.jsx)(i.code,{children:"(circuit1, observable1, parameter_set1)"})," if you want to run ",(0,s.jsx)(i.code,{children:"circuit1"})," with ",(0,s.jsx)(i.code,{children:"observable1"})," and ",(0,s.jsx)(i.code,{children:"parameter_set1"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["You might need to reshape your arrays of observables or parameter sets if you want to apply their outer product. For example, an array of observables of shape (4, 1) and an array of parameter sets of shape (1, 6) will give you a result of (4, 6) expectation values. See the ",(0,s.jsx)(i.a,{href:"https://numpy.org/doc/stable/user/basics.broadcasting.html",children:"Numpy broadcasting rules"})," for more details."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"You can optionally specify the precision you want for that specific PUB."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Update the estimator ",(0,s.jsx)(i.code,{children:"run()"})," method to pass in the list of PUBs. For example, ",(0,s.jsx)(i.code,{children:"run([(circuit1, observable1, parameter_set1)])"}),".\nYou can optionally specify a ",(0,s.jsx)(i.code,{children:"precision"})," here, which would apply to all PUBs."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Estimator V2 job results are grouped by PUBs. You can see the expectation value and standard error for each PUB by indexing to it. For example:"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'pub_result = job.result()[0]\nprint(f">>> Expectation values: {pub_result.data.evs}")\nprint(f">>> Standard errors: {pub_result.data.stds}")\n'})}),"\n",(0,s.jsx)(i.h2,{id:"estimator-full-examples",children:"Estimator full examples"}),"\n",(0,s.jsx)(i.h3,{id:"run-a-single-experiment",children:"Run a single experiment"}),"\n",(0,s.jsx)(i.p,{children:"Use Estimator to determine the expectation value of a single circuit-observable pair."}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import SparsePauliOp, random_hermitian\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator, QiskitRuntimeService\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\nestimator = Estimator(backend)\n\nn_qubits = 127\n\nmat = np.real(random_hermitian(n_qubits, seed=1234))\ncircuit = IQP(mat)\nobservable = SparsePauliOp("Z" * n_qubits)\n\npm = generate_preset_pass_manager(optimization_level=1, backend=backend)\nisa_circuit = pm.run(circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\n\njob = estimator.run([(isa_circuit, isa_observable)])\nresult = job.result()\n\nprint(f" > Expectation value: {result[0].data.evs}")\nprint(f" > Metadata: {result[0].metadata}")\n'})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import SparsePauliOp, random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nmat = np.real(random_hermitian(n_qubits, seed=1234))\ncircuit = IQP(mat)\nobservable = SparsePauliOp("Z" * n_qubits)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\n\nestimator = Estimator(backend)\njob = estimator.run(isa_circuit, isa_observable)\nresult = job.result()\n\nprint(f" > Observable: {observable.paulis}")\nprint(f" > Expectation value: {result.values}")\nprint(f" > Metadata: {result.metadata}")\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"run-multiple-experiments-in-a-single-job",children:"Run multiple experiments in a single job"}),"\n",(0,s.jsx)(i.p,{children:"Use Estimator to determine the expectation values of multiple circuit-observable pairs."}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'service = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\n\nn_qubits = 3\nrng = np.random.default_rng()\nmats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]\ncircuits = [IQP(mat) for mat in mats]\nobservables = [\n    SparsePauliOp("X" * n_qubits),\n    SparsePauliOp("Y" * n_qubits),\n    SparsePauliOp("Z" * n_qubits),\n]\n\nisa_circuits = pm.run(circuits)\nisa_observables = [ob.apply_layout(isa_circuits[0].layout) for ob in observables]\n\nestimator = Estimator(backend)\njob = estimator.run([(isa_circuits[0], isa_observables[0]),(isa_circuits[1], isa_observables[1]),(isa_circuits[2], isa_observables[2])])\njob_result = job.result()\nfor idx in range(len(job_result)):\n    pub_result = job_result[idx]\n    print(f">>> Expectation values for PUB {idx}: {pub_result.data.evs}")\n    print(f">>> Standard errors for PUB {idx}: {pub_result.data.stds}")\n'})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import SparsePauliOp, random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Estimator\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nrng = np.random.default_rng()\nmats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]\ncircuits = [IQP(mat) for mat in mats]\nobservables = [\n    SparsePauliOp("X" * n_qubits),\n    SparsePauliOp("Y" * n_qubits),\n    SparsePauliOp("Z" * n_qubits),\n]\n\n# Get ISA circuits\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuits = pm.run(circuits)\nisa_observables = [ob.apply_layout(isa_circuits[0].layout) for ob in observables]\n\nestimator = Estimator(backend)\njob = estimator.run(isa_circuits, isa_observables)\nresult = job.result()\n\nprint(f" > Expectation values: {result.values}")\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"run-parameterized-circuits",children:"Run parameterized circuits"}),"\n",(0,s.jsx)(i.p,{children:"Use Estimator to run multiple experiments in a single job, leveraging parameter values to increase circuit reusability. In the following example, notice that steps 1 and 2 are the same for V1 and V2."}),"\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\n\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# Step 1: Map classical inputs to a quantum problem\n\ntheta = Parameter("\u03b8")\n\nchsh_circuit = QuantumCircuit(2)\nchsh_circuit.h(0)\nchsh_circuit.cx(0, 1)\nchsh_circuit.ry(theta, 0)\n\nnumber_of_phases = 21\nphases = np.linspace(0, 2 * np.pi, number_of_phases)\nindividual_phases = [[ph] for ph in phases]\n\nZZ = SparsePauliOp.from_list([("ZZ", 1)])\nZX = SparsePauliOp.from_list([("ZX", 1)])\nXZ = SparsePauliOp.from_list([("XZ", 1)])\nXX = SparsePauliOp.from_list([("XX", 1)])\nops = [ZZ, ZX, XZ, XX]\n\n# Step 2: Optimize problem for quantum execution.\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nchsh_isa_circuit = pm.run(chsh_circuit)\nisa_observables = [operator.apply_layout(chsh_isa_circuit.layout) for operator in ops]\n\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\n\n# Step 3: Execute using Qiskit primitives.\n\n# Reshape observable array for broadcasting\nreshaped_ops = np.fromiter(isa_observables, dtype=object)\nreshaped_ops = reshaped_ops.reshape((4, 1))\n\nestimator = Estimator(backend, options={"default_shots": int(1e4)})\njob = estimator.run([(chsh_isa_circuit, reshaped_ops, individual_phases)])\n# Get results for the first (and only) PUB\npub_result = job.result()[0]\nprint(f">>> Expectation values: {pub_result.data.evs}")\nprint(f">>> Standard errors: {pub_result.data.stds}")\nprint(f">>> Metadata: {pub_result.metadata}")\n'})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\n\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# Step 1: Map classical inputs to a quantum problem\n\ntheta = Parameter("\u03b8")\n\nchsh_circuit = QuantumCircuit(2)\nchsh_circuit.h(0)\nchsh_circuit.cx(0, 1)\nchsh_circuit.ry(theta, 0)\n\nnumber_of_phases = 21\nphases = np.linspace(0, 2 * np.pi, number_of_phases)\nindividual_phases = [[ph] for ph in phases]\n\nZZ = SparsePauliOp.from_list([("ZZ", 1)])\nZX = SparsePauliOp.from_list([("ZX", 1)])\nXZ = SparsePauliOp.from_list([("XZ", 1)])\nXX = SparsePauliOp.from_list([("XX", 1)])\nops = [ZZ, ZX, XZ, XX]\n\n# Step 2: Optimize problem for quantum execution.\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nchsh_isa_circuit = pm.run(chsh_circuit)\nisa_observables = [operator.apply_layout(chsh_isa_circuit.layout) for operator in ops]\n\nfrom qiskit_ibm_runtime import Estimator\n\n# Step 3: Execute using Qiskit Primitives.\nnum_ops = len(isa_observables)\n\nbatch_circuits = [chsh_isa_circuit] * number_of_phases * num_ops\nbatch_ops = [op for op in isa_observables for _ in individual_phases]\nbatch_phases = individual_phases * num_ops\n\nestimator = Estimator(backend, options={"shots": int(1e4)})\njob = estimator.run(batch_circuits, batch_ops, batch_phases)\nexpvals = job.result().values\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"use-sessions-and-advanced-options",children:"Use sessions and advanced options"}),"\n",(0,s.jsx)(i.p,{children:"Explore sessions and advanced options to optimize circuit performance on QPUs."}),"\n",(0,s.jsx)(t,{type:"caution",children:(0,s.jsxs)(i.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,s.jsx)(i.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,s.jsx)(i.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"EstimatorV2",label:"Estimator V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit.quantum_info import SparsePauliOp, random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, EstimatorV2 as Estimator\n\nn_qubits = 127\n\nrng = np.random.default_rng(1234)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\ncircuit = IQP(mat)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\nanother_circuit = IQP(mat)\nobservable = SparsePauliOp("X" * n_qubits)\nanother_observable = SparsePauliOp("Y" * n_qubits)\n\npm = generate_preset_pass_manager(optimization_level=1, backend=backend)\nisa_circuit = pm.run(circuit)\nanother_isa_circuit = pm.run(another_circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\nanother_isa_observable = another_observable.apply_layout(another_isa_circuit.layout)\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nwith Session(backend=backend) as session:\n    estimator = Estimator()\n\n    estimator.options.resilience_level = 1\n\n    job = estimator.run([(isa_circuit, isa_observable)])\n    another_job = estimator.run([(another_isa_circuit, another_isa_observable)])\n    result = job.result()\n    another_result = another_job.result()\n\n    # first job\n    print(f" > Expectation value: {result[0].data.evs}")\n    print(f" > Metadata: {result[0].metadata}")\n\n    # second job\n    print(f" > Another Expectation value: {another_result[0].data.evs}")\n    print(f" > More Metadata: {another_result[0].metadata}")\n'})})}),(0,s.jsx)(o.A,{value:"EstimatorV1",label:"Estimator (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit.quantum_info import SparsePauliOp, random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Session, Estimator, Options\n\nn_qubits = 127\n\nrng = np.random.default_rng(1234)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\ncircuit = IQP(mat)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\nanother_circuit = IQP(mat)\nobservable = SparsePauliOp("X" * n_qubits)\nanother_observable = SparsePauliOp("Y" * n_qubits)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\nanother_isa_circuit = pm.run(another_circuit)\nisa_observable = observable.apply_layout(isa_circuit.layout)\nanother_isa_observable = another_observable.apply_layout(another_isa_circuit.layout)\n\noptions = Options()\noptions.optimization_level = 2\noptions.resilience_level = 2\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nwith Session(backend=backend) as session:\n    estimator = Estimator(options=options)\n    job = estimator.run(isa_circuit, isa_observable)\n    another_job = estimator.run(another_isa_circuit, another_isa_observable)\n    result = job.result()\n    another_result = another_job.result()\n\n# first job\nprint(f" > Expectation values job 1: {result.values}")\n\n# second job\nprint(f" > Expectation values job 2: {another_result.values}")\n'})})})]}),"\n",(0,s.jsx)(i.h2,{id:"steps-to-migrate-to-sampler-v2",children:"Steps to migrate to Sampler V2"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["Replace ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import Sampler"})," with ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import SamplerV2 as Sampler"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:["Remove any ",(0,s.jsx)(i.code,{children:"from qiskit_ibm_runtime import Options"})," statements, since the ",(0,s.jsx)(i.code,{children:"Options"})," class is not used by V2 primitives. You can instead pass options as a dictionary when initializing the ",(0,s.jsx)(i.code,{children:"SamplerV2"})," class (for example ",(0,s.jsx)(i.code,{children:"sampler = Sampler(backend, options={\u201cdefault_shots\u201d: 1024})"}),"), or set them after initialization:","\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"sampler = Sampler(backend)\nsampler.options.default_shots = 1024\n"})}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["Review all the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options",children:"supported options"})," and make updates accordingly."]}),"\n",(0,s.jsxs)(i.li,{children:["Group each circuit you want to run with the observables and parameter values you want to apply to the circuit in a tuple (a PUB). For example, use ",(0,s.jsx)(i.code,{children:"(circuit1, parameter_set1)"})," if you want to run ",(0,s.jsx)(i.code,{children:"circuit1"})," with ",(0,s.jsx)(i.code,{children:"parameter_set1"}),".\nYou can optionally specify the shots you want for that specific PUB."]}),"\n",(0,s.jsxs)(i.li,{children:["Update the sampler ",(0,s.jsx)(i.code,{children:"run()"})," method to pass in the list of PUBs. For example, ",(0,s.jsx)(i.code,{children:"run([(circuit1, parameter_set1)])"}),".\nYou can optionally specify ",(0,s.jsx)(i.code,{children:"shots"})," here, which would apply to all PUBs."]}),"\n",(0,s.jsx)(i.li,{children:"Sampler V2 job results are grouped by PUBs. You can see the output data for each PUB by indexing to it. While Sampler V2 returns unweighted samples, the result class has a convenience method to get counts instead. For example:"}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'pub_result = job.result()[0]\nprint(f">>> Counts: {pub_result.data.meas.get_counts()}")\nprint(f">>> Per-shot measurement: {pub_result.data.meas.get_counts()}")\n'})}),"\n",(0,s.jsx)(t,{type:"note",children:(0,s.jsxs)(i.p,{children:["You need the classical register name to get the results.  By default, it is named ",(0,s.jsx)(i.code,{children:"meas"})," when you use ",(0,s.jsx)(i.code,{children:"measure_all()"}),". When defining your circuit, if you create one or more classical registers with a non-default name, use that name to get the results. You can find the classical register name by running ",(0,s.jsx)(i.code,{children:"<circuit_name>.cregs"}),". For example, ",(0,s.jsx)(i.code,{children:"qc.cregs"}),"."]})}),"\n",(0,s.jsx)(i.h2,{id:"sampler-full-examples",children:"Sampler full examples"}),"\n",(0,s.jsx)(i.h3,{id:"run-a-single-experiment-1",children:"Run a single experiment"}),"\n",(0,s.jsx)(i.p,{children:"Use Sampler to determine the counts or quasi-probability distribution of a single circuit."}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nmat = np.real(random_hermitian(n_qubits, seed=1234))\ncircuit = IQP(mat)\ncircuit.measure_all()\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\n\nsampler = Sampler(backend)\njob = sampler.run([isa_circuit])\nresult = job.result()\n"})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Sampler\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nmat = np.real(random_hermitian(n_qubits, seed=1234))\ncircuit = IQP(mat)\ncircuit.measure_all()\n\nsampler = Sampler(backend)\njob = sampler.run(circuit)\nresult = job.result()\n\nprint(f" > Quasi-probability distribution: {result.quasi_dists}")\nprint(f" > Metadata: {result.metadata}")\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"run-multiple-experiments-in-a-single-job-1",children:"Run multiple experiments in a single job"}),"\n",(0,s.jsx)(i.p,{children:"Use Sampler to determine the counts or quasi-probability distributions of multiple circuits in one job."}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nrng = np.random.default_rng()\nmats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]\ncircuits = [IQP(mat) for mat in mats]\nfor circuit in circuits:\n    circuit.measure_all()\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuits = pm.run(circuits)\n\nsampler = Sampler(backend)\njob = sampler.run(isa_circuits)\nresult = job.result()\n\nfor idx, pub_result in enumerate(result):\n    print(f" > Counts for pub {idx}: {pub_result.data.meas.get_counts()}")\n'})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Sampler\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nn_qubits = 127\n\nrng = np.random.default_rng()\nmats = [np.real(random_hermitian(n_qubits, seed=rng)) for _ in range(3)]\ncircuits = [IQP(mat) for mat in mats]\nfor circuit in circuits:\n    circuit.measure_all()\n\nsampler = Sampler(backend)\njob = sampler.run(circuits)\nresult = job.result()\n\nprint(f" > Quasi-probability distribution: {result.quasi_dists}")\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"run-parameterized-circuits-1",children:"Run parameterized circuits"}),"\n",(0,s.jsx)(i.p,{children:"Run several experiments in a single job, leveraging parameter values to increase circuit reusability."}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import RealAmplitudes\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# Step 1: Map classical inputs to a quantum problem\nnum_qubits = 127\ncircuit = RealAmplitudes(num_qubits=num_qubits, reps=2)\ncircuit.measure_all()\n\n# Define three sets of parameters for the circuit\nrng = np.random.default_rng(1234)\nparameter_values = [\n    rng.uniform(-np.pi, np.pi, size=circuit.num_parameters) for _ in range(3)\n]\n\n# Step 2: Optimize problem for quantum execution.\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=num_qubits)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\n\n# Step 3: Execute using Qiskit primitives.\n\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler\n\nsampler = Sampler(backend)\njob = sampler.run([(isa_circuit, parameter_values)])\nresult = job.result()\n# Get results for the first (and only) PUB\npub_result = result[0]\n# Get counts from the classical register "meas".\nprint(f" >> Counts for the meas output register: {pub_result.data.meas.get_counts()}")\n'})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import RealAmplitudes\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\n# Step 1: Map classical inputs to a quantum problem\nnum_qubits = 5\ncircuit = RealAmplitudes(num_qubits=num_qubits, reps=2)\ncircuit.measure_all()\n\n# Define three sets of parameters for the circuit\nrng = np.random.default_rng(1234)\nparameter_values = [\n    rng.uniform(-np.pi, np.pi, size=circuit.num_parameters) for _ in range(3)\n]\n\n# Step 2: Optimize problem for quantum execution.\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=num_qubits)\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\n\n# Step 3: Execute using Qiskit primitives.\n\nfrom qiskit_ibm_runtime import Sampler\n\nsampler = Sampler(backend)\njob = sampler.run([isa_circuit] * 3, parameter_values)\nresult = job.result()\n\nprint(f" > Quasi-probability distribution: {result.quasi_dists}")\nprint(f" > Metadata: {result.metadata}")\n'})})})]}),"\n",(0,s.jsx)(i.h3,{id:"use-sessions-and-advanced-options-1",children:"Use sessions and advanced options"}),"\n",(0,s.jsx)(i.p,{children:"Explore sessions and advanced options to optimize circuit performance on QPUs."}),"\n",(0,s.jsx)(t,{type:"caution",children:(0,s.jsxs)(i.p,{children:["The following code block will return an error for users on the Open Plan because it uses sessions. Workloads on the Open Plan can run only in ",(0,s.jsx)(i.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,s.jsx)(i.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n","\n",(0,s.jsxs)(a.A,{children:[(0,s.jsx)(o.A,{value:"SamplerV2",label:"Sampler V2",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler, Session\n\nn_qubits = 127\n\nrng = np.random.default_rng(1234)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\ncircuit = IQP(mat)\ncircuit.measure_all()\nmat = np.real(random_hermitian(n_qubits, seed=rng))\nanother_circuit = IQP(mat)\nanother_circuit.measure_all()\n\npm = generate_preset_pass_manager(backend=backend, optimization_level=1)\nisa_circuit = pm.run(circuit)\nanother_isa_circuit = pm.run(another_circuit)\n\nservice = QiskitRuntimeService()\n\n# Turn on dynamical decoupling with sequence XpXm.\nsampler.options.dynamical_decoupling.enable = True\nsampler.options.dynamical_decoupling.sequence_type = "XpXm"\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nwith Session(backend=backend) as session:\n    sampler = Sampler()\n    job = sampler.run([isa_circuit])\n    another_job = sampler.run([another_isa_circuit])\n    result = job.result()\n    another_result = another_job.result()\n\n# first job\nprint(f" > Counts for job 1: {result[0].data.meas.get_counts()}")\n\n# second job\nprint(f" > Counts for job 2: {another_result[0].data.meas.get_counts()}")\n'})})}),(0,s.jsx)(o.A,{value:"SamplerV1",label:"Sampler (V1)",children:(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import IQP\nfrom qiskit.quantum_info import random_hermitian\nfrom qiskit_ibm_runtime import QiskitRuntimeService, Sampler, Session, Options\n\nn_qubits = 127\n\nrng = np.random.default_rng(1234)\nmat = np.real(random_hermitian(n_qubits, seed=rng))\ncircuit = IQP(mat)\ncircuit.measure_all()\nmat = np.real(random_hermitian(n_qubits, seed=rng))\nanother_circuit = IQP(mat)\nanother_circuit.measure_all()\n\noptions = Options()\noptions.optimization_level = 2\noptions.resilience_level = 0\n\nservice = QiskitRuntimeService()\n\nbackend = service.least_busy(operational=True, simulator=False, min_num_qubits=127)\n\nwith Session(backend=backend) as session:\n    sampler = Sampler(options=options)\n    job = sampler.run(circuit)\n    another_job = sampler.run(another_circuit)\n    result = job.result()\n    another_result = another_job.result()\n\n# first job\nprint(f" > Quasi-probability distribution job 1: {result.quasi_dists}")\n\n# second job\nprint(f" > Quasi-probability distribution job 2: {another_result.quasi_dists}")\n'})})})]}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(t,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Learn more about setting options in the ",(0,s.jsx)(i.a,{href:"/guides/specify-runtime-options",children:"Specify options"})," guide."]}),"\n",(0,s.jsxs)(i.li,{children:["Learn more details about ",(0,s.jsx)(i.a,{href:"/guides/primitive-input-output",children:"Primitive inputs and outputs."})]}),"\n",(0,s.jsxs)(i.li,{children:["Experiment with the ",(0,s.jsx)(i.a,{href:"/tutorials/chsh-inequality",children:"CHSH Inequality"})," tutorial."]}),"\n"]})})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},19365(e,i,t){t.d(i,{A:()=>a});t(96540);var n=t(34164);const s="tabItem_Ymn6";var r=t(74848);function a({children:e,hidden:i,className:t}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,n.A)(s,t),hidden:i,children:e})}},11470(e,i,t){t.d(i,{A:()=>S});var n=t(96540),s=t(34164),r=t(17559),a=t(23104),o=t(56347),l=t(205),u=t(57485),c=t(31682),m=t(70679);function p(e){return n.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:i}=e;return!!i&&"object"==typeof i&&"value"in i}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function d(e){const{values:i,children:t}=e;return(0,n.useMemo)(()=>{const e=i??function(e){return p(e).map(({props:{value:e,label:i,attributes:t,default:n}})=>({value:e,label:i,attributes:t,default:n}))}(t);return function(e){const i=(0,c.XI)(e,(e,i)=>e.value===i.value);if(i.length>0)throw new Error(`Docusaurus error: Duplicate values "${i.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[i,t])}function h({value:e,tabValues:i}){return i.some(i=>i.value===e)}function b({queryString:e=!1,groupId:i}){const t=(0,o.W6)(),s=function({queryString:e=!1,groupId:i}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!i)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return i??null}({queryString:e,groupId:i});return[(0,u.aZ)(s),(0,n.useCallback)(e=>{if(!s)return;const i=new URLSearchParams(t.location.search);i.set(s,e),t.replace({...t.location,search:i.toString()})},[s,t])]}function _(e){const{defaultValue:i,queryString:t=!1,groupId:s}=e,r=d(e),[a,o]=(0,n.useState)(()=>function({defaultValue:e,tabValues:i}){if(0===i.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:i}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${i.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=i.find(e=>e.default)??i[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:i,tabValues:r})),[u,c]=b({queryString:t,groupId:s}),[p,_]=function({groupId:e}){const i=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,s]=(0,m.Dv)(i);return[t,(0,n.useCallback)(e=>{i&&s.set(e)},[i,s])]}({groupId:s}),v=(()=>{const e=u??p;return h({value:e,tabValues:r})?e:null})();(0,l.A)(()=>{v&&o(v)},[v]);return{selectedValue:a,selectValue:(0,n.useCallback)(e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),c(e),_(e)},[c,_,r]),tabValues:r}}var v=t(92303);const x="tabList__CuJ",j="tabItem_LNqP";var f=t(74848);function g({className:e,block:i,selectedValue:t,selectValue:n,tabValues:r}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),u=e=>{const i=e.currentTarget,s=o.indexOf(i),a=r[s].value;a!==t&&(l(i),n(a))},c=e=>{let i=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=o.indexOf(e.currentTarget)+1;i=o[t]??o[0];break}case"ArrowLeft":{const t=o.indexOf(e.currentTarget)-1;i=o[t]??o[o.length-1];break}}i?.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":i},e),children:r.map(({value:e,label:i,attributes:n})=>(0,f.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{o.push(e)},onKeyDown:c,onClick:u,...n,className:(0,s.A)("tabs__item",j,n?.className,{"tabs__item--active":t===e}),children:i??e},e))})}function y({lazy:e,children:i,selectedValue:t}){const r=(Array.isArray(i)?i:[i]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===t);return e?(0,n.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:r.map((e,i)=>(0,n.cloneElement)(e,{key:i,hidden:e.props.value!==t}))})}function k(e){const i=_(e);return(0,f.jsxs)("div",{className:(0,s.A)(r.G.tabs.container,"tabs-container",x),children:[(0,f.jsx)(g,{...i,...e}),(0,f.jsx)(y,{...i,...e})]})}function S(e){const i=(0,v.A)();return(0,f.jsx)(k,{...e,children:p(e.children)},String(i))}},28453(e,i,t){t.d(i,{R:()=>a,x:()=>o});var n=t(96540);const s={},r=n.createContext(s);function a(e){const i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);