"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5680],{57199(e,i,t){t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/primitives","title":"Introduction to primitives","description":"Introduction to primitives in Qiskit and Qiskit Runtime, and an explanation of available primitives","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/primitives.mdx","sourceDirName":"guides","slug":"/guides/primitives","permalink":"/guides/primitives","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/primitives.mdx","tags":[],"version":"current","frontMatter":{"title":"Introduction to primitives","sidebar_label":"Introduction to primitives","description":"Introduction to primitives in Qiskit and Qiskit Runtime, and an explanation of available primitives","notebook_path":"docs/guides/primitives.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Efficient simulation of stabilizer circuits with Qiskit Aer primitives","permalink":"/guides/simulate-stabilizer-circuits"},"next":{"title":"Get started with primitives","permalink":"/guides/get-started-with-primitives"}}');var n=t(74848),r=t(28453);const a={title:"Introduction to primitives",sidebar_label:"Introduction to primitives",description:"Introduction to primitives in Qiskit and Qiskit Runtime, and an explanation of available primitives",notebook_path:"docs/guides/primitives.ipynb"},o=void 0,c={},l=[{value:"Why did Qiskit introduce primitives?",id:"why-did-qiskit-introduce-primitives",level:2},{value:"What is a primitive?",id:"what-is-a-primitive",level:2},{value:"Primitive definition and implementations",id:"primitive-definition-and-implementations",level:2},{value:"Base classes",id:"base-classes",level:3},{value:"Implementations",id:"implementations",level:3},{value:"Benefits of Qiskit primitives",id:"benefits-of-qiskit-primitives",level:2},{value:"Primitive details",id:"primitive-details",level:2},{value:"Estimator",id:"estimator",level:3},{value:"Sampler",id:"sampler",level:3},{value:"Next steps",id:"next-steps",level:2}];function m(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Admonition:t,Details:s,OpenInLabBanner:a}=i;return t||h("Admonition",!0),s||h("Details",!0),a||h("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(a,{notebookPath:"docs/guides/primitives.ipynb"}),"\n","\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:(0,n.jsx)("b",{children:"Package versions"})}),(0,n.jsx)(i.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,n.jsx)(t,{type:"note",title:"New execution model, now in beta release",children:(0,n.jsxs)(i.p,{children:["The beta release of a new execution model is now available. The directed execution model provides more flexibility when customizing your error mitigation workflow. See the ",(0,n.jsx)(i.a,{href:"/guides/directed-execution-model",children:"Directed execution model"})," guide for more information."]})}),"\n",(0,n.jsx)("span",{id:"qpu-access-patterns"}),"\n",(0,n.jsx)(i.h2,{id:"why-did-qiskit-introduce-primitives",children:"Why did Qiskit introduce primitives?"}),"\n",(0,n.jsxs)(i.p,{children:["Similar to the early days of classical computers, when developers had to manipulate CPU registers directly, the early interface to QPUs simply returned the raw data from the control electronics.\nThis was not a big issue when QPUs lived in labs and only allowed direct access by researchers.\nAcknowledging that most developers would not and should not be familiar with distilling such raw data into 0s and 1s, Qiskit introduced ",(0,n.jsx)(i.code,{children:"backend.run"}),", a first abstraction for accessing QPUs in the cloud. This allowed developers\nto operate on a familiar data format and focus on the bigger picture."]}),"\n",(0,n.jsxs)(i.p,{children:["As access to QPUs became more widespread, and with more quantum algorithms being developed,\nagain the need for a higher-level abstraction emerged. In response, Qiskit introduced\nthe primitives interface, which is optimized for two core tasks in quantum algorithm development:\nexpectation value estimation (",(0,n.jsx)(i.code,{children:"Estimator"}),") and circuit sampling (",(0,n.jsx)(i.code,{children:"Sampler"}),"). The goal is once\nagain to help developers to focus more on innovation and less on data conversion. The primitives interface supersedes the ",(0,n.jsx)(i.code,{children:"backend.run"})," interface, since ",(0,n.jsx)(i.code,{children:"Sampler"})," provides the same direct hardware access that was offered by ",(0,n.jsx)(i.code,{children:"backend.run"}),"."]}),"\n",(0,n.jsx)(i.h2,{id:"what-is-a-primitive",children:"What is a primitive?"}),"\n",(0,n.jsx)(i.p,{children:"Computing systems are built on multiple layers of abstraction. Abstractions allow you to focus on a\nparticular level of detail relevant to the task at hand. The closer you get to the hardware,\nthe lower the level of abstraction you need (for example, you might need to move or manipulate data at the CPU instruction level). The more complex the task you want to perform,\nthe higher-level the abstractions will be (for example, you could be using a programming library to perform\nalgebraic calculations)."}),"\n",(0,n.jsxs)(i.p,{children:["In this context, a ",(0,n.jsx)(i.em,{children:"primitive"})," is the smallest processing instruction, the simplest building block from which\none can create something useful for a given abstraction level."]}),"\n",(0,n.jsx)(i.p,{children:"The recent progress in quantum computing has increased the need to work at higher levels of abstraction.\nAs the field moves toward larger quantum processing units (QPUs) and more complex workflows, the focus shifts from interacting with individual\nqubit signals to viewing quantum devices as systems that perform necessary tasks."}),"\n",(0,n.jsxs)(i.p,{children:["The two most common tasks for quantum computers are sampling quantum states and calculating expectation values.\nThese tasks motivated the design of the Qiskit primitives: ",(0,n.jsx)(i.strong,{children:"Estimator"})," and ",(0,n.jsx)(i.strong,{children:"Sampler"}),"."]}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsx)(i.li,{children:"Estimator computes expectation values of observables with respect to states prepared by quantum circuits."}),"\n",(0,n.jsx)(i.li,{children:"Sampler samples the output register from quantum circuit execution."}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"In short, the computational model introduced by the Qiskit primitives moves quantum programming one step closer\nto where classical programming is today, where the focus is less on the hardware details and more on the results\nyou are trying to achieve."}),"\n",(0,n.jsx)(i.h2,{id:"primitive-definition-and-implementations",children:"Primitive definition and implementations"}),"\n",(0,n.jsxs)(i.p,{children:["There are two types of Qiskit primitives: the base classes, and their implementations. The Qiskit primitives are defined by open-source primitive base classes that live in the Qiskit SDK (in the  ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/primitives",children:(0,n.jsx)(i.code,{children:"qiskit.primitives"})})," module). Providers (such as Qiskit Runtime) can use these base classes to derive their own Sampler and Estimator implementations.  Most users will interact with provider implementations, not the base primitives."]}),"\n",(0,n.jsx)(i.h3,{id:"base-classes",children:"Base classes"}),"\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BaseEstimatorV2",children:(0,n.jsx)(i.code,{children:"BaseEstimatorV2"})})," and ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BaseSamplerV2",children:(0,n.jsx)(i.code,{children:"BaseSamplerV2"})})," - Abstract base classes that define a common interface for implementing primitives. All other classes in the ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/primitives",children:(0,n.jsx)(i.code,{children:"qiskit.primitives"})})," module inherit from these base classes.  Developers should use these if they are interested in creating their own primitives-based execution model for a specific provider. These classes might also be useful for those who want to do highly customized processing and find that the existing primitives implementations are too simple for their needs. General users will not directly use the base classes."]}),"\n",(0,n.jsx)("span",{id:"implementations"}),"\n",(0,n.jsx)(i.h3,{id:"implementations",children:"Implementations"}),"\n",(0,n.jsx)(i.p,{children:"These are implementations of the primitives base classes:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["The Qiskit Runtime primitives (",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2",children:(0,n.jsx)(i.code,{children:"EstimatorV2"})})," and ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2",children:(0,n.jsx)(i.code,{children:"SamplerV2"})}),") provide a more sophisticated implementation (for example, by including error mitigation) as a cloud-based service. This implementation of the base primitives is used to access IBM Quantum\xae hardware.  They are accessed through IBM Qiskit Runtime."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.StatevectorEstimator",children:(0,n.jsx)(i.code,{children:"StatevectorEstimator"})})," and ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.StatevectorSampler#statevectorsampler",children:(0,n.jsx)(i.code,{children:"StatevectorSampler"})})," - Reference implementations of the primitives that use the simulator built into Qiskit. They are built with the Qiskit ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/quantum_info#quantum-information",children:(0,n.jsx)(i.code,{children:"quantum_info"})})," module, producing results based on ideal statevector simulations.  They are accessed through Qiskit."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:[(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendEstimatorV2",children:(0,n.jsx)(i.code,{children:"BackendEstimatorV2"})})," and ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.BackendSamplerV2",children:(0,n.jsx)(i.code,{children:"BackendSamplerV2"})})," - You can use these classes to \u201cwrap\u201d any quantum computing resource into a primitive. This lets you write primitive-style code for providers that don\u2019t yet have a primitives-based interface. These classes can be used just like the regular Sampler and Estimator, except they should be initialized with an additional ",(0,n.jsx)(i.code,{children:"backend"})," argument for selecting which quantum computer to run on. They are accessed by using Qiskit."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(i.h2,{id:"benefits-of-qiskit-primitives",children:"Benefits of Qiskit primitives"}),"\n",(0,n.jsxs)(i.p,{children:["With primitives, Qiskit users can write quantum code for a specific QPU without having to explicitly\nmanage every detail. Also, because of the additional layer of abstraction, you might be able to more easily\naccess advanced hardware capabilities of a given provider. For example, with Qiskit Runtime primitives,\nyou can take advantage of the latest advancements in error mitigation and suppression by toggling options such as the primitive's ",(0,n.jsxs)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/options-estimator-options#resilience_level",children:[(0,n.jsx)(i.code,{children:"resilience_level"}),","]})," rather than building your own implementation of these techniques."]}),"\n",(0,n.jsx)(i.p,{children:"For hardware providers, implementing primitives natively means you can provide your users with a more \u201cout-of-the-box\u201d\nway to access your hardware features such as advanced post-processing techniques. It is therefore easier for your users to benefit from your hardware's best capabilities."}),"\n",(0,n.jsx)(i.h2,{id:"primitive-details",children:"Primitive details"}),"\n",(0,n.jsx)(i.p,{children:"As described previously, all primitives are created from the base classes; therefore, they have the same general structure and usage.  For example, the format of the input for all Estimator primitives is the same.  However, there are differences in implementations that make them unique."}),"\n",(0,n.jsx)(t,{type:"note",children:(0,n.jsx)(i.p,{children:"Because most users access the Qiskit Runtime primitives, the examples in the rest of this section are based on Qiskit Runtime primitives."})}),"\n",(0,n.jsx)("span",{id:"estimator"}),"\n",(0,n.jsx)(i.h3,{id:"estimator",children:"Estimator"}),"\n",(0,n.jsx)(i.p,{children:"The Estimator primitive computes the expectation values for one or more observables with respect to states prepared by quantum circuits. The circuits can be parametrized, as long as the parameter values are also provided as input to the primitive."}),"\n",(0,n.jsxs)(i.p,{children:["The input is an array of ",(0,n.jsx)(i.a,{href:"/guides/primitive-input-output#pubs",children:"PUBs."})," Each PUB is in the format:"]}),"\n",(0,n.jsxs)(i.p,{children:["(",(0,n.jsx)(i.code,{children:"<single circuit>"}),", ",(0,n.jsx)(i.code,{children:"<one or more observables>"}),", ",(0,n.jsx)(i.code,{children:"<optional one or more parameter values>"}),", ",(0,n.jsx)(i.code,{children:"<optional precision>"}),"),"]}),"\n",(0,n.jsxs)(i.p,{children:["where the optional ",(0,n.jsx)(i.code,{children:"parameter values"})," can be a list or a single parameter.  Different Estimator implementations support various configuration options. If the input contains measurements, they are ignored."]}),"\n",(0,n.jsxs)(i.p,{children:["The output is a ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.PubResult#pubresult",children:(0,n.jsx)(i.code,{children:"PubResult"})})," that contains the computed expectation values per pair, and their standard errors, in ",(0,n.jsx)(i.code,{children:"PubResult"})," form. Each ",(0,n.jsx)(i.code,{children:"PubResult"})," contains both data and metadata."]}),"\n",(0,n.jsxs)(i.p,{children:["The Estimator combines elements from observables and parameter values by following NumPy broadcasting rules as described in the ",(0,n.jsx)(i.a,{href:"primitive-input-output#broadcasting-rules",children:"Primitive inputs and outputs"})," topic."]}),"\n",(0,n.jsx)(i.p,{children:"Example:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'# This cell is hidden from users, it creates the circuits and observables to run\n\nfrom qiskit_ibm_runtime import EstimatorV2, SamplerV2, QiskitRuntimeService\nfrom qiskit.circuit.random import random_circuit\nfrom qiskit.circuit import Parameter\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler import generate_preset_pass_manager\nimport numpy as np\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy()\nphi = Parameter("phi")\n\ncircuit1 = random_circuit(10, 5, seed=12345)\ncircuit1.rzz(phi, 1, 2)\nobservable1 = SparsePauliOp.from_sparse_list(\n    [("ZXYZ", [1, 2, 3, 4], 1)], num_qubits=10\n)\nparam_values1 = np.random.uniform(size=5).T\n\ncircuit2 = random_circuit(10, 5, seed=12345)\ncircuit2.rzz(phi, 1, 2)\nobservable2 = SparsePauliOp.from_sparse_list(\n    [("XZYX", [1, 2, 3, 4], 1)], num_qubits=10\n)\nparam_values2 = np.random.uniform(size=5).T\n\nshots1 = 164\nshots2 = 1024\n\npm = generate_preset_pass_manager(optimization_level=1, backend=backend)\ncircuit1 = pm.run(circuit1)\ncircuit2 = pm.run(circuit2)\nobservable1 = observable1.apply_layout(circuit1.layout)\nobservable2 = observable2.apply_layout(circuit2.layout)\n'})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"estimator = EstimatorV2(mode=backend)\nestimator_job = estimator.run(\n    [\n        (circuit1, observable1, param_values1),\n        (circuit2, observable2, param_values2),\n    ]\n)\n"})}),"\n",(0,n.jsx)("span",{id:"sampler"}),"\n",(0,n.jsx)(i.h3,{id:"sampler",children:"Sampler"}),"\n",(0,n.jsx)(i.p,{children:"The Sampler's core task is sampling the output register from the execution of one or more quantum circuits. The input circuits can be parametrized, as long as the parameter values are also provided as input to the primitive."}),"\n",(0,n.jsxs)(i.p,{children:["The input is one or more ",(0,n.jsx)(i.a,{href:"/guides/primitive-input-output#pubs",children:"PUBs,"})," in the format:"]}),"\n",(0,n.jsxs)(i.p,{children:["(",(0,n.jsx)(i.code,{children:"<single circuit>"}),", ",(0,n.jsx)(i.code,{children:"<one or more optional parameter value>"}),", ",(0,n.jsx)(i.code,{children:"<optional shots>"}),"),"]}),"\n",(0,n.jsxs)(i.p,{children:["where there can be multiple ",(0,n.jsx)(i.code,{children:"parameter values"})," items, and each item can be either an array or a single parameter, depending on the chosen circuit. Additionally, the input must contain measurements."]}),"\n",(0,n.jsxs)(i.p,{children:["The output is counts or per-shot measurements, as ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.PubResult#pubresult",children:(0,n.jsx)(i.code,{children:"PubResult"})})," objects, without weights. The result class, however, has methods to return weighted samples, such as counts. See ",(0,n.jsx)(i.a,{href:"primitive-input-output#broadcasting-rules",children:"Primitive inputs and outputs"})," for full details."]}),"\n",(0,n.jsx)(i.p,{children:"Example:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"# This cell is hidden from users, add measurement instructions to circuits\ncircuit1.measure_active()\ncircuit2.measure_active()\n"})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"sampler = SamplerV2(mode=backend)\nsampler_job = sampler.run(\n    [\n        (circuit1, param_values1, shots1),\n        (circuit2, param_values2, shots2),\n    ]\n)\n"})}),"\n",(0,n.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,n.jsx)(t,{type:"tip",title:"Recommendations",children:(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["Read ",(0,n.jsx)(i.a,{href:"get-started-with-primitives",children:"Get started with primitives"})," to implement primitives in your work."]}),"\n",(0,n.jsxs)(i.li,{children:["Review detailed ",(0,n.jsx)(i.a,{href:"primitives-examples",children:"primitives examples."})]}),"\n",(0,n.jsxs)(i.li,{children:["Practice with primitives by working through the ",(0,n.jsx)(i.a,{href:"/learning/courses/variational-algorithm-design/cost-functions",children:"Cost function lesson"})," in IBM Quantum Learning."]}),"\n",(0,n.jsxs)(i.li,{children:["See the ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/estimator-v2",children:"EstimatorV2 API reference"})," and ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/sampler-v2",children:"SamplerV2 API reference"}),"."]}),"\n",(0,n.jsxs)(i.li,{children:["Read ",(0,n.jsx)(i.a,{href:"/guides/v2-primitives",children:"Migrate to V2 primitives"}),"."]}),"\n"]})})]})}function d(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}function h(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,i,t){t.d(i,{R:()=>a,x:()=>o});var s=t(96540);const n={},r=s.createContext(n);function a(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);