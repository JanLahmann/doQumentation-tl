"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[6824],{88531(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/run-jobs-batch","title":"Run jobs in a batch","description":"How to run quantum computing jobs in batch mode using Qiskit Runtime.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/run-jobs-batch.mdx","sourceDirName":"guides","slug":"/guides/run-jobs-batch","permalink":"/guides/run-jobs-batch","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/run-jobs-batch.mdx","tags":[],"version":"current","frontMatter":{"title":"Run jobs in a batch","sidebar_label":"Run jobs in a batch","description":"How to run quantum computing jobs in batch mode using Qiskit Runtime.","notebook_path":"docs/guides/run-jobs-batch.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Choose the right execution mode","permalink":"/guides/choose-execution-mode"},"next":{"title":"Run jobs in a session","permalink":"/guides/run-jobs-session"}}');var a=n(74848),s=n(28453);const r={title:"Run jobs in a batch",sidebar_label:"Run jobs in a batch",description:"How to run quantum computing jobs in batch mode using Qiskit Runtime.",notebook_path:"docs/guides/run-jobs-batch.ipynb"},o=void 0,c={},l=[{value:"Set up to use batches",id:"set-up-to-use-batches",level:2},{value:"Open a batch",id:"open-a-batch",level:2},{value:"Batch length",id:"batch-length",level:2},{value:"Close a batch",id:"close-a-batch",level:2},{value:"Determine batch details",id:"determine-batch-details",level:2},{value:"Reconfigure jobs for parallel processing",id:"reconfigure-jobs-for-parallel-processing",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components},{Admonition:n,Details:i,OpenInLabBanner:r}=t;return n||h("Admonition",!0),i||h("Details",!0),r||h("OpenInLabBanner",!0),(0,a.jsxs)(a.Fragment,{children:["\n",(0,a.jsx)(t.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,a.jsx)(t.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,a.jsx)(r,{notebookPath:"docs/guides/run-jobs-batch.ipynb"}),"\n","\n",(0,a.jsxs)(i,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Package versions"})}),(0,a.jsx)(t.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,a.jsx)(t.p,{children:"Use batch mode to submit multiple primitive jobs simultaneously. Following are examples of working with batches."}),"\n",(0,a.jsx)(t.h2,{id:"set-up-to-use-batches",children:"Set up to use batches"}),"\n",(0,a.jsxs)(t.p,{children:["Before starting a batch, you must ",(0,a.jsx)(t.a,{href:"/guides/install-qiskit",children:"set up Qiskit Runtime"})," and initialize it as a service:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    QiskitRuntimeService,\n    Batch,\n    SamplerV2 as Sampler,\n    EstimatorV2 as Estimator,\n)\n\nservice = QiskitRuntimeService()\n"})}),"\n",(0,a.jsx)(t.h2,{id:"open-a-batch",children:"Open a batch"}),"\n",(0,a.jsxs)(t.p,{children:["You can open a runtime batch by using the context manager ",(0,a.jsx)(t.code,{children:"with Batch(...)"})," or by initializing the ",(0,a.jsx)(t.code,{children:"Batch"}),"\nclass. When you start a batch,  you must specify a QPU by passing a ",(0,a.jsx)(t.code,{children:"backend"})," object.  The batch starts when its first job begins execution."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Batch class"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"backend = service.least_busy(operational=True, simulator=False)\nbatch = Batch(backend=backend)\nestimator = Estimator(mode=batch)\nsampler = Sampler(mode=batch)\n# Close the batch because no context manager was used.\nbatch.close()\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Context manager"})}),"\n",(0,a.jsx)(t.p,{children:"The context manager automatically opens and closes the batch."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    Batch,\n    SamplerV2 as Sampler,\n    EstimatorV2 as Estimator,\n)\n\nbackend = service.least_busy(operational=True, simulator=False)\nwith Batch(backend=backend):\n    estimator = Estimator()\n    sampler = Sampler()\n"})}),"\n",(0,a.jsx)("span",{id:"specify-batch-length"}),"\n",(0,a.jsx)(t.h2,{id:"batch-length",children:"Batch length"}),"\n",(0,a.jsxs)(t.p,{children:["You can define the batch's maximum time to live (TTL) with the ",(0,a.jsx)(t.code,{children:"max_time"})," parameter. This should exceed the longest job's execution time. This timer starts when the batch starts.  When the value is reached, the batch is closed.  Any jobs that are running will finish, but jobs still queued are failed."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'with Batch(backend=backend, max_time="25m"):\n  ...\n'})}),"\n",(0,a.jsx)(t.p,{children:"There is also an interactive time to live (interactive TTL) value that cannot be configured (1 minute for all plans).  If no batch jobs are queued within that window, the batch is temporarily deactivated."}),"\n",(0,a.jsx)(t.p,{children:"Default maximum TTL values:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Instance type"}),(0,a.jsx)(t.th,{children:"Default Maximum TTL"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"All paid plans"}),(0,a.jsx)(t.td,{children:"8 hours"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Open"}),(0,a.jsx)(t.td,{children:"10 minutes"})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:["To determine a batch's maximum TTL or interactive TTL, follow the instructions in ",(0,a.jsx)(t.a,{href:"#batch-details",children:"Determine batch details"})," and look for the ",(0,a.jsx)(t.code,{children:"max_time"})," or ",(0,a.jsx)(t.code,{children:"interactive_timeout"})," value, respectively."]}),"\n",(0,a.jsx)("span",{id:"close"}),"\n",(0,a.jsx)(t.h2,{id:"close-a-batch",children:"Close a batch"}),"\n",(0,a.jsx)(t.p,{children:'A batch automatically closes when it exits the context manager. When the batch context manager is exited, the batch is put into "In progress, not accepting new jobs" status. This means that the batch finishes processing all running or queued jobs until the maximum TTL value is reached. After all jobs are completed, the batch is immediately closed. You cannot submit jobs to a closed batch.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'from qiskit.quantum_info import SparsePauliOp\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.transpiler import generate_preset_pass_manager\nimport numpy as np\n\n# This cell is hidden from users\nservice = QiskitRuntimeService()\nbackend = service.least_busy()\n\n# Define two circuits, each with one parameter with two parameters.\ncircuit = QuantumCircuit(2)\ncircuit.h(0)\ncircuit.cx(0, 1)\ncircuit.ry(Parameter("a"), 0)\ncircuit.cx(0, 1)\ncircuit.h(0)\ncircuit.measure_all()\n\npm = generate_preset_pass_manager(optimization_level=1, backend=backend)\ntranspiled_circuit = pm.run(circuit)\ntranspiled_circuit_sampler = transpiled_circuit\ntranspiled_circuit_sampler.measure_all()\n\nparams = np.random.uniform(size=(2, 3)).T\nobservables = [\n    [\n        SparsePauliOp(["XX", "IY"], [0.5, 0.5]).apply_layout(\n            transpiled_circuit.layout\n        )\n    ],\n    [SparsePauliOp("XX").apply_layout(transpiled_circuit.layout)],\n    [SparsePauliOp("IY").apply_layout(transpiled_circuit.layout)],\n]\n\nsampler_pub = (transpiled_circuit_sampler, params)\nestimator_pub = (transpiled_circuit_sampler, observables, params)\n'})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"with Batch(backend=backend) as batch:\n    estimator = Estimator()\n    sampler = Sampler()\n    job1 = estimator.run([estimator_pub])\n    job2 = sampler.run([sampler_pub])\n\n# The batch is no longer accepting jobs but the submitted job will run to completion.\nresult = job1.result()\nresult2 = job2.result()\n"})}),"\n",(0,a.jsx)(n,{type:"tip",children:(0,a.jsxs)(t.p,{children:["If you are not using a context manager, manually close the batch.  If you leave the batch open and submit more jobs to it later, it is possible that the maximum TTL will be reached before the subsequent jobs start running; causing them to be canceled. You can close a batch as soon as you are done submitting jobs to it. When a batch is closed with ",(0,a.jsx)(t.code,{children:"batch.close()"}),", it no longer accepts new jobs, but the already submitted jobs will still run until completion and their results can be retrieved."]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'batch = Batch(backend=backend)\n\n# If using qiskit-ibm-runtime earlier than 0.24.0, change `mode=` to `batch=`\nestimator = Estimator(mode=batch)\nsampler = Sampler(mode=batch)\njob1 = estimator.run([estimator_pub])\njob2 = sampler.run([sampler_pub])\nprint(f"Result1: {job1.result()}")\nprint(f"Result2: {job2.result()}")\n\n# Manually close the batch. Running and queued jobs will run to completion.\nbatch.close()\n'})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"Result1: PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(3, 2), dtype=float64>), stds=np.ndarray(<shape=(3, 2), dtype=float64>), ensemble_standard_error=np.ndarray(<shape=(3, 2), dtype=float64>), shape=(3, 2)), metadata={'shots': 4096, 'target_precision': 0.015625, 'circuit_metadata': {}, 'resilience': {}, 'num_randomizations': 32})], metadata={'dynamical_decoupling': {'enable': False, 'sequence_type': 'XX', 'extra_slack_distribution': 'middle', 'scheduling_method': 'alap'}, 'twirling': {'enable_gates': False, 'enable_measure': True, 'num_randomizations': 'auto', 'shots_per_randomization': 'auto', 'interleave_randomizations': True, 'strategy': 'active-accum'}, 'resilience': {'measure_mitigation': True, 'zne_mitigation': False, 'pec_mitigation': False}, 'version': 2})\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"Result2: PrimitiveResult([SamplerPubResult(data=DataBin(meas=BitArray(<shape=(3, 2), num_shots=4096, num_bits=2>), meas0=BitArray(<shape=(3, 2), num_shots=4096, num_bits=133>), shape=(3, 2)), metadata={'circuit_metadata': {}})], metadata={'execution': {'execution_spans': ExecutionSpans([DoubleSliceSpan(<start='2026-01-15 07:47:58', stop='2026-01-15 07:48:05', size=24576>)])}, 'version': 2})\n"})}),"\n",(0,a.jsx)("span",{id:"batch-details"}),"\n",(0,a.jsx)(t.h2,{id:"determine-batch-details",children:"Determine batch details"}),"\n",(0,a.jsxs)(t.p,{children:["For a comprehensive overview of a batch's configuration and status, including its interactive and max TTL, use the  ",(0,a.jsx)(t.code,{children:"batch.details() method"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"from qiskit_ibm_runtime import (\n    QiskitRuntimeService,\n    batch,\n    SamplerV2 as Sampler,\n)\n\nservice = QiskitRuntimeService()\nbackend = service.least_busy(operational=True, simulator=False)\n\nwith Batch(backend=backend) as batch:\n    print(batch.details())\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"{'id': 'ce8cf08d-b18e-4d56-ab51-eaff0b8190f4', 'backend_name': 'ibm_torino', 'interactive_timeout': 1, 'max_time': 28800, 'active_timeout': 28800, 'state': 'open', 'accepting_jobs': True, 'last_job_started': None, 'last_job_completed': None, 'started_at': None, 'closed_at': None, 'activated_at': None, 'mode': 'batch', 'usage_time': None}\n"})}),"\n",(0,a.jsx)("span",{id:"partition"}),"\n",(0,a.jsx)(t.h2,{id:"reconfigure-jobs-for-parallel-processing",children:"Reconfigure jobs for parallel processing"}),"\n",(0,a.jsx)(t.p,{children:"There are multiple ways you can reconfigure your jobs to take advantage of the parallel processing provided by batching. The following example shows how you can partition a long list of circuits into multiple jobs and run them as a batch to take advantage of the parallel processing."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"from qiskit_ibm_runtime import SamplerV2 as Sampler, Batch\nfrom qiskit.circuit.random import random_circuit\n\nmax_circuits = 100\ncircuits = [pm.run(random_circuit(5, 5)) for _ in range(5 * max_circuits)]\nfor circuit in circuits:\n    circuit.measure_active()\nall_partitioned_circuits = []\nfor i in range(0, len(circuits), max_circuits):\n    all_partitioned_circuits.append(circuits[i : i + max_circuits])\njobs = []\nstart_idx = 0\n\nwith Batch(backend=backend):\n    sampler = Sampler()\n    for partitioned_circuits in all_partitioned_circuits:\n        job = sampler.run(partitioned_circuits)\n        jobs.append(job)\n"})}),"\n",(0,a.jsx)(n,{type:"caution",children:(0,a.jsxs)(t.p,{children:["If you set ",(0,a.jsx)(t.code,{children:"backend=backend"})," in a primitive, the program is run in job mode, even if it's inside a batch or session context. Setting ",(0,a.jsx)(t.code,{children:"backend=backend"})," is deprecated as of Qiskit Runtime v0.24.0.  Instead, use the ",(0,a.jsx)(t.code,{children:"mode"})," parameter."]})}),"\n",(0,a.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(n,{type:"tip",title:"Recommendations",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Try an example in the ",(0,a.jsx)(t.a,{href:"/tutorials/combine-error-mitigation-techniques",children:"Combine error mitigation options with the estimator primitive"})," tutorial."]}),"\n",(0,a.jsxs)(t.li,{children:["Review the ",(0,a.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/batch#batch",children:"Batch API"})," reference."]}),"\n",(0,a.jsxs)(t.li,{children:["Understand the ",(0,a.jsx)(t.a,{href:"/guides/job-limits",children:"Job limits"})," when sending a job to an IBM QPU."]}),"\n",(0,a.jsxs)(t.li,{children:["Review ",(0,a.jsx)(t.a,{href:"/guides/execution-modes-faq",children:"execution modes FAQs."})]}),"\n"]})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}function h(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,t,n){n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);