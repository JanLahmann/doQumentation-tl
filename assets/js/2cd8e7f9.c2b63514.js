"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5245],{7747(a,n,e){e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>A});const s=JSON.parse('{"id":"tutorials/ghz-spacetime-codes","title":"Mababang-overhead na pagdetekta ng error gamit ang spacetime codes","description":"Mag-eksperimento sa pagdetekta ng error sa isang maliit na random Clifford circuit, at sundan ang proseso ng paghahanda ng GHZ state.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/tutorials/ghz-spacetime-codes.mdx","sourceDirName":"tutorials","slug":"/tutorials/ghz-spacetime-codes","permalink":"/tutorials/ghz-spacetime-codes","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/ghz-spacetime-codes.mdx","tags":[],"version":"current","frontMatter":{"title":"Mababang-overhead na pagdetekta ng error gamit ang spacetime codes","sidebar_label":"Mababang-overhead na pagdetekta ng error gamit ang spacetime codes","description":"Mag-eksperimento sa pagdetekta ng error sa isang maliit na random Clifford circuit, at sundan ang proseso ng paghahanda ng GHZ state.","notebook_path":"docs/tutorials/ghz-spacetime-codes.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Repetition codes","permalink":"/tutorials/repetition-codes"},"next":{"title":"Overview","permalink":"/guides/"}}');var i=e(74848),t=e(28453);const r={title:"Mababang-overhead na pagdetekta ng error gamit ang spacetime codes",sidebar_label:"Mababang-overhead na pagdetekta ng error gamit ang spacetime codes",description:"Mag-eksperimento sa pagdetekta ng error sa isang maliit na random Clifford circuit, at sundan ang proseso ng paghahanda ng GHZ state.",notebook_path:"docs/tutorials/ghz-spacetime-codes.ipynb"},c=void 0,l={},A=[{value:"Panimula",id:"introduction",level:2},{value:"Mga Kinakailangan",id:"requirements",level:3},{value:"Setup",id:"setup",level:3},{value:"Unang Halimbawa",id:"first-example",level:2},{value:"Halimbawa sa Totoong Mundo: Maghanda ng GHZ State sa Tunay na Hardware",id:"real-world-example-prepare-a-ghz-state-on-real-hardware",level:2},{value:"Hakbang 1: Isalin ang mga Classical na Input sa isang Quantum na Problema",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:3},{value:"Hakbang 2: I-optimize ang problema para sa pagpapatakbo sa quantum hardware",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:3},{value:"I-map ang GHZ state sa hardware",id:"map-the-ghz-state-to-hardware",level:4},{value:"Hakbang 3: Isagawa gamit ang Qiskit primitives",id:"step-3-execute-using-qiskit-primitives",level:3},{value:"Hakbang 4: Post-process at ibalik ang resulta sa nais na klasikal na format",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:3},{value:"Talakayan",id:"discussion",level:2},{value:"Mga Sanggunian",id:"references",level:3}];function o(a){const n={a:"a",annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",math:"math",mfrac:"mfrac",mi:"mi",mn:"mn",mo:"mo",mpadded:"mpadded",mrow:"mrow",msqrt:"msqrt",msub:"msub",msup:"msup",mtext:"mtext",p:"p",path:"path",pre:"pre",semantics:"semantics",span:"span",svg:"svg",ul:"ul",...(0,t.R)(),...a.components},{OpenInLabBanner:s}=n;return s||function(a,n){throw new Error("Expected "+(n?"component":"object")+" `"+a+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s,{notebookPath:"docs/tutorials/ghz-spacetime-codes.ipynb"}),"\n","\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"Tinatayang paggamit: 10 segundo sa isang Heron r3 processor (PAALALA: Tantiya lamang ito. Maaaring mag-iba ang iyong aktwal na oras ng pagpapatakbo.)"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Panimula"}),"\n",(0,i.jsxs)(n.p,{children:["Ang ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2504.15725",children:"Low-overhead error detection with spacetime codes"})," ",(0,i.jsx)(n.a,{href:"#references",children:"[1]"})," nina Simon Martiel at Ali Javadi-Abhari ay nagmumungkahi ng pagbuo ng mababang-timbang, connectivity-aware na spacetime checks para sa Clifford-dominated na mga circuit, pagkatapos ay post-selecting sa mga check na ito upang mahuli ang mga pagkakamali nang may mas kaunting overhead kaysa sa buong error correction at mas kaunting shots kaysa sa karaniwang error mitigation."]}),"\n",(0,i.jsx)(n.p,{children:'Nagmumungkahi ang papel na ito ng bagong paraan para sa pagdetekta ng error sa mga quantum circuit (partikular na ang Clifford circuits) na nagtatagpo sa pagitan ng buong error correction at mga mas magaang na mitigation na pamamaraan. Ang pangunahing ideya ay ang paggamit ng spacetime codes upang makabuo ng mga "check" sa buong circuit na kayang mahuli ang mga error, nang may mas mababang qubit at gate overhead kaysa sa buong fault-tolerant na error correction. Nagdisenyo ang mga may-akda ng mahusay na mga algorithm upang pumili ng mga check na mababang-timbang (kinasasangkutan ng ilang qubits), katugma sa pisikal na connectivity ng device, at sumasaklaw sa malalawak na temporal at spatial na bahagi ng circuit. Ipinakita nila ang pamamaraan sa mga circuit na may hanggang 50 logical qubits at ~2450 na CZ gates, na nakamit ang physical-to-logical fidelity gains na hanggang 236x. Tandaan din na habang nagsasama ng mas maraming non-Clifford na operasyon ang mga circuit, ang bilang ng mga wastong check ay bumababa nang exponensyal, na nagpapahiwatig na pinakamabisa ang pamamaraan para sa Clifford-dominated na mga circuit. Sa kabuuan, sa malapit na hinaharap, ang pagdetekta ng error sa pamamagitan ng spacetime codes ay maaaring mag-alok ng praktikal at mas mababang-overhead na ruta tungo sa pagpapabuti ng pagiging maaasahan ng quantum hardware.'}),"\n",(0,i.jsxs)(n.p,{children:["Ang teknikong ito ng pagdetekta ng error ay umaasa sa konsepto ng coherent Pauli checks at batay sa gawa na ",(0,i.jsx)(n.a,{href:"https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.5.033193",children:"Single-shot error mitigation by coherent Pauli checks"})," ",(0,i.jsx)(n.a,{href:"#references",children:"[2]"})," nina van den Berg et al."]}),"\n",(0,i.jsxs)(n.p,{children:["Kamakailan, ang papel na ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2510.09520",children:"Big cats: entanglement in 120 qubits and beyond"})," ",(0,i.jsx)(n.a,{href:"#references",children:"[3]"}),' nina Javadi-Abhari et al. ay nag-uulat ng paglikha ng isang 120-qubit na Greenberger-Horne-Zeilinger (GHZ) state, ang pinakamalaking multipartite entangled state na nagawa hanggang ngayon sa isang superconducting-qubit na platform. Gamit ang isang hardware-aware compiler, mababang-overhead na pagdetekta ng error, at isang "temporary uncomputation" na teknik upang mabawasan ang ingay, ang mga mananaliksik ay nakamit ang isang fidelity na 0.56 \xb1 0.03 na may halos 28% na kahusayan sa post-selection. Ipinakita ng gawaing ito ang tunay na entanglement sa lahat ng 120 qubits, na nagpapatunay ng maraming paraan ng fidelity-certification, at isang pangunahing benchmark para sa scalable na quantum hardware.']}),"\n",(0,i.jsx)(n.p,{children:"Ang tutorial na ito ay nagtatayo sa mga ideyang ito, ginagabayan ka sa pagpapatupad ng error detection algorithm una sa isang maliit na random Clifford circuit at pagkatapos sa gawaing paghahanda ng GHZ state, upang matulungan kang mag-eksperimento sa pagdetekta ng error sa iyong sariling mga quantum circuit."}),"\n",(0,i.jsx)(n.h3,{id:"requirements",children:"Mga Kinakailangan"}),"\n",(0,i.jsx)(n.p,{children:"Bago simulan ang tutorial na ito, tiyaking naka-install ang mga sumusunod:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Qiskit SDK v2.0 o mas bago, na may suporta sa ",(0,i.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualization"})]}),"\n",(0,i.jsxs)(n.li,{children:["Qiskit Runtime v0.40 o mas bago (",(0,i.jsx)(n.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Qiskit Aer v0.17.2 (",(0,i.jsx)(n.code,{children:"pip install qiskit-aer"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/qiskit-community/qiskit-device-benchmarking",children:"Qiskit Device Benchmarking"})," (",(0,i.jsx)(n.code,{children:'pip install "qiskit-device-benchmarking @ git+https://github.com/qiskit-community/qiskit-device-benchmarking.git"'}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["NumPy v2.3.2 (",(0,i.jsx)(n.code,{children:"pip install numpy"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Matplotlib v3.10.7 (",(0,i.jsx)(n.code,{children:"pip install matplotlib"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-device-benchmarking\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Standard library imports\nfrom collections import defaultdict, deque\nfrom functools import partial\n\n# External libraries\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Qiskit\nfrom qiskit import ClassicalRegister, QuantumCircuit\nfrom qiskit.circuit import Delay\nfrom qiskit.circuit.library import RZGate, XGate\nfrom qiskit.converters import circuit_to_dag, dag_to_circuit\nfrom qiskit.quantum_info import Pauli, random_clifford\nfrom qiskit.transpiler import AnalysisPass, PassManager\nfrom qiskit.transpiler.passes import (\n    ALAPScheduleAnalysis,\n    CollectAndCollapse,\n    PadDelay,\n    PadDynamicalDecoupling,\n    RemoveBarriers,\n)\nfrom qiskit.transpiler.passes.optimization.collect_and_collapse import (\n    collect_using_filter_function,\n    collapse_to_operation,\n)\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit.visualization import plot_histogram\n\n# Qiskit Aer\nfrom qiskit_aer import AerSimulator\nfrom qiskit_aer.noise import NoiseModel, ReadoutError, depolarizing_error\n\n# Qiskit IBM Runtime\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler\n\n# Qiskit Device Benchmarking\nfrom qiskit_device_benchmarking.utilities.gate_map import plot_gate_map\n"})}),"\n",(0,i.jsx)(n.h2,{id:"first-example",children:"Unang Halimbawa"}),"\n",(0,i.jsx)(n.p,{children:"Upang ipakita ang pamamaraang ito, magsisimula tayo sa pagbuo ng isang simpleng Clifford circuit. Ang aming layunin ay makadetekta ng ilang uri ng error na nagaganap sa circuit na ito, upang maitapon namin ang mga maling resulta ng pagsukat. Sa terminolohiya ng pagdetekta ng error, ito rin ay kilala bilang aming payload circuit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'circ = random_clifford(num_qubits=2, seed=11).to_circuit()\ncirc.draw("mpl")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(27198).A+"",width:"434",height:"174"})}),"\n",(0,i.jsx)(n.p,{children:"Ang aming layunin ay maglagay ng coherent Pauli check sa payload circuit na ito. Ngunit bago gawin iyon, hinahati namin ang circuit na ito sa mga layer. Magiging kapaki-pakinabang ito sa paglaon kapag naglalagay ng mga Pauli gate sa pagitan."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Separate circuit into layers\ndag = circuit_to_dag(circ)\ncirc_layers = []\nfor layer in dag.layers():\n    layer_as_circuit = dag_to_circuit(layer["graph"])\n    circ_layers.append(layer_as_circuit)\n\n# Create subplots\nfig, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(1, 5, figsize=(10, 4))\n\n# Draw circuits on respective axes\ncirc_layers[0].draw(output="mpl", ax=ax1)\ncirc_layers[1].draw(output="mpl", ax=ax2)\ncirc_layers[2].draw(output="mpl", ax=ax3)\ncirc_layers[3].draw(output="mpl", ax=ax4)\ncirc_layers[4].draw(output="mpl", ax=ax5)\n\n# Adjust layout to prevent overlap\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(69066).A+"",width:"990",height:"199"})}),"\n",(0,i.jsx)(n.p,{children:'Handa na tayo ngayon na magdagdag ng mga coherent Pauli check sa payload circuit. Upang magawa ito, kailangan nating bumuo ng isang "wastong check" at ilagay ito sa circuit. Ang isang "check" sa kasong ito ay isang operator na kayang ipahiwatig kung nagkaroon ng error sa circuit sa pamamagitan ng pagsukat sa isang ancilla qubit. Ito ay itinuturing na wastong check kapag ang mga karagdagang operator na inilagay sa quantum circuit ay hindi lohikal na nagbabago ng orihinal na circuit.'}),"\n",(0,i.jsxs)(n.p,{children:["Ang check na ito ay kayang matukoy ang mga uri ng error na anticommute dito, at ang check ay magdudulot ng pagsukat ng ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.mpadded,{children:[(0,i.jsx)(n.mi,{mathvariant:"normal",children:"\u2223"}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\ket{1}"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsxs)(n.span,{className:"minner",children:[(0,i.jsx)(n.span,{className:"mord",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"mord",children:"1"})}),(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"})]})]})})]})," state sa ancilla qubit sa halip na ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.mpadded,{children:[(0,i.jsx)(n.mi,{mathvariant:"normal",children:"\u2223"}),(0,i.jsx)(n.mn,{children:"0"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\ket{0}"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsxs)(n.span,{className:"minner",children:[(0,i.jsx)(n.span,{className:"mord",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"mord",children:"0"})}),(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"})]})]})})]})," sa pamamagitan ng phase kickback. Kaya naman, makakaya nating itapon ang mga sukat kung saan may sinyales ng error."]}),"\n",(0,i.jsx)(n.p,{children:'Sa pangkalahatan, ang mga coherent Pauli check ay controlled-Pauli operators na inilalagay sa mga "wire" - mga spacetime location sa pagitan ng mga gate. Ang ancilla qubit na responsable sa pagsenyales ng error ay ang control qubit.'}),"\n",(0,i.jsx)(n.p,{children:"Sa ibaba, bumubuo tayo ng wastong check para sa Clifford circuit na ginawa namin sa itaas. Maaari naming ipakita na ang check na ito ay hindi nagbabago ng operasyon ng circuit sa pamamagitan ng pagpapakita na kapag ang mga Pauli check na ito ay pinaalis sa harap ng circuit, magkakansela sila. Madaling ipakita ito dahil ang isang Pauli operator sa pamamagitan ng isang Clifford gate ay isa pang Pauli operator."}),"\n",(0,i.jsxs)(n.p,{children:["Sa pangkalahatan, maaaring gumamit ng decoding heuristic gaya ng nakabalangkas sa ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2504.15725",children:"[1]"})," upang matukoy ang mga wastong check. Para sa layunin ng aming unang halimbawa, maaari rin kaming bumuo ng mga wastong check gamit ang mga analytical na kondisyon ng multiplikasyon ng Pauli at Clifford gate."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Define a valid check\npauli_1 = Pauli("ZI")\npauli_2 = Pauli("XZ")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'circ_1 = circ_layers[0].compose(circ_layers[1])\ncirc_1.draw("mpl")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(88233).A+"",width:"241",height:"174"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'pauli_1_ev = pauli_1.evolve(circ_1, frame="h")\npauli_1_ev\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pauli('-ZI')\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'circ_2 = circ.copy()\ncirc_2.draw("mpl")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(96956).A+"",width:"434",height:"174"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'pauli_2_ev = pauli_2.evolve(circ_2, frame="h")\npauli_2_ev\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pauli('-ZI')\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"pauli_1_ev.dot(pauli_2_ev)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Pauli('II')\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Gaya ng makikita natin, mayroon tayong wastong check, dahil ang mga inilagay na Pauli operator ay may parehong epekto lamang ng isang identity operator sa circuit. Maaari na tayong maglagay ng mga check na ito sa circuit gamit ang isang ancilla qubit. Ang ancilla qubit na ito, o ang check qubit, ay nagsisimula sa ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.mpadded,{children:[(0,i.jsx)(n.mi,{mathvariant:"normal",children:"\u2223"}),(0,i.jsx)(n.mo,{lspace:"0em",rspace:"0em",children:"+"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\ket{+}"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsxs)(n.span,{className:"minner",children:[(0,i.jsx)(n.span,{className:"mord",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"mord",children:"+"})}),(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"})]})]})})]})," state. Kasama nito ang mga controlled na bersyon ng mga Pauli operasyon na nakabalangkas sa itaas at sa wakas ay sinusukat sa ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"X"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"X"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07847em"},children:"X"})]})})]}),' basis. Ang check qubit na ito ay kayang makuha ang mga error sa payload circuit nang hindi lohikal na binabago ito. Ito ay dahil ang ilang uri ng ingay sa payload circuit ay magbabago sa estado ng check qubit, at ito ay masusukat bilang "1" sa halip na "0" kung sakaling magkaroon ng ganitong error.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# New circuit with 3 qubits (2 payload + 1 ancilla for check)\ncirc_meas = QuantumCircuit(3)\ncirc_meas.h(0)\ncirc_meas.compose(circ_layers[0], [1, 2], inplace=True)\ncirc_meas.compose(circ_layers[1], [1, 2], inplace=True)\ncirc_meas.cz(0, 2)\ncirc_meas.compose(circ_layers[2], [1, 2], inplace=True)\ncirc_meas.compose(circ_layers[3], [1, 2], inplace=True)\ncirc_meas.compose(circ_layers[4], [1, 2], inplace=True)\ncirc_meas.cz(0, 1)\ncirc_meas.cx(0, 2)\ncirc_meas.h(0)\n\n# Add measurement to payload qubits\nc0 = ClassicalRegister(2, name="c0")\ncirc_meas.add_register(c0)\ncirc_meas.measure(1, c0[0])\ncirc_meas.measure(2, c0[1])\n\n# Add measurement to check qubit\nc1 = ClassicalRegister(1, name="c1")\ncirc_meas.add_register(c1)\ncirc_meas.measure(0, c1[0])\n\n# Visualize the final circuit with the inserted checks\ncirc_meas.draw("mpl")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(97134).A+"",width:"756",height:"367"})}),"\n",(0,i.jsx)(n.p,{children:'Kung ang check qubit ay nasukat bilang "0", pinapanatili namin ang sukat na iyon. Kung ito ay nasukat bilang "1", nangangahulugan ito na nagkaroon ng error sa payload circuit, at itatapon namin ang sukat na iyon.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Noiseless simulation using stabilizer method\nsim_stab = AerSimulator(method="stabilizer")\nres = sim_stab.run(circ_meas, shots=1000).result()\ncounts_noiseless = res.get_counts()\nprint(f"Stabilizer simulation result: {counts_noiseless}")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Stabilizer simulation result: {'0 11': 523, '0 01': 477}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Plot the noiseless results\n# Note that the first bit in the key corresponds to the check qubit\nplot_histogram(counts_noiseless)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(99405).A+"",width:"630",height:"470"})}),"\n",(0,i.jsx)(n.p,{children:"Pansinin na sa isang ideal na simulator, hindi nakakakita ng anumang error ang check qubit. Nagpapakilala na tayo ngayon ng noise model sa simulation at titingnan kung paano nakukuha ng check qubit ang mga error."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Qiskit Aer noise model\nnoise = NoiseModel()\np2 = 0.003  # two-qubit depolarizing per CZ\np1 = 0.001  # one-qubit depolarizing per 1q Clifford\npr = 0.01  # readout bit-flip probability\n\n# 1q depolarizing on common 1q gates\ne1 = depolarizing_error(p1, 1)\nfor g1 in ["id", "rz", "sx", "x", "h", "s"]:\n    noise.add_all_qubit_quantum_error(e1, g1)\n\n# 2q depolarizing on CZ\ne2 = depolarizing_error(p2, 2)\nnoise.add_all_qubit_quantum_error(e2, "cz")\n\n# Readout error on measure\nro = ReadoutError([[1 - pr, pr], [pr, 1 - pr]])\nnoise.add_all_qubit_readout_error(ro)\n\n# Qiskit Aer simulation with noise model\naer = AerSimulator(method="automatic", seed_simulator=43210)\njob = aer.run(circ_meas, shots=1000, noise_model=noise)\nresult = job.result()\ncounts_noisy = result.get_counts()\nprint(f"Noise model simulation result: {counts_noisy}")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Noise model simulation result: {'1 01': 5, '0 11': 478, '1 11': 6, '1 00': 2, '1 10': 1, '0 01': 500, '0 00': 5, '0 10': 3}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"plot_histogram(counts_noisy)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(34792).A+"",width:"630",height:"470"})}),"\n",(0,i.jsx)(n.p,{children:'Gaya ng makikita natin, ilang mga sukat ang nakuha ang error sa pamamagitan ng pagmamarka ng check qubit bilang "1", na makikita sa huling apat na hanay. Ang mga shot na ito ay itatapon.\nPaalala: Ang ancilla qubit ay maaari ring magdulot ng mga bagong error sa circuit. Upang mabawasan ang epekto nito, maaari tayong maglagay ng mga nested check na may karagdagang ancilla qubits sa quantum circuit.'}),"\n",(0,i.jsx)(n.h2,{id:"real-world-example-prepare-a-ghz-state-on-real-hardware",children:"Halimbawa sa Totoong Mundo: Maghanda ng GHZ State sa Tunay na Hardware"}),"\n",(0,i.jsx)(n.h3,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Hakbang 1: Isalin ang mga Classical na Input sa isang Quantum na Problema"}),"\n",(0,i.jsx)(n.p,{children:"Ipinakita na namin ngayon ang isang mahalagang gawain para sa mga quantum computing algorithm, at ito ay ang paghahanda ng GHZ state. Ipapakita namin kung paano gawin ito sa isang tunay na backend gamit ang pagdetekta ng error."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Set optional seed for reproducibility\nSEED = 1\n\nif SEED:\n    np.random.seed(SEED)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Ang error detection algorithm para sa paghahanda ng GHZ state ay iginagalang ang hardware topology. Nagsisimula tayo sa pagpili ng nais na hardware."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# This is used to run on real hardware\nservice = QiskitRuntimeService()\n\n# Choose a backend to build GHZ on\nbackend_name = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=133\n)\n\nbackend = service.backend(backend_name)\ncoupling_map = backend.target.build_coupling_map()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Ang isang GHZ state sa ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"n"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"n"})]})})]})," qubits ay tinukoy bilang\n",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{stretchy:"false",children:"\u2223"}),(0,i.jsxs)(n.msub,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{mathvariant:"normal",children:"G"}),(0,i.jsx)(n.mi,{mathvariant:"normal",children:"H"}),(0,i.jsx)(n.mi,{mathvariant:"normal",children:"Z"})]}),(0,i.jsx)(n.mi,{children:"n"})]}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"}),(0,i.jsx)(n.mtext,{children:"\u2005\u200a"}),(0,i.jsx)(n.mo,{children:"="}),(0,i.jsx)(n.mtext,{children:"\u2005\u200a"}),(0,i.jsxs)(n.mfrac,{children:[(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsx)(n.msqrt,{children:(0,i.jsx)(n.mn,{children:"2"})})]}),(0,i.jsx)(n.mo,{fence:"false",stretchy:"true",minsize:"1.8em",maxsize:"1.8em",children:"("}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u2223"}),(0,i.jsx)(n.mn,{children:"0"}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{children:"\u2297"}),(0,i.jsx)(n.mi,{children:"n"})]})]}),(0,i.jsx)(n.mtext,{children:"\u2009"}),(0,i.jsx)(n.mo,{children:"+"}),(0,i.jsx)(n.mtext,{children:"\u2009"}),(0,i.jsx)(n.mo,{stretchy:"false",children:"\u2223"}),(0,i.jsx)(n.mn,{children:"1"}),(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mo,{stretchy:"false",children:"\u27e9"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{children:"\u2297"}),(0,i.jsx)(n.mi,{children:"n"})]})]}),(0,i.jsx)(n.mo,{fence:"false",stretchy:"true",minsize:"1.8em",maxsize:"1.8em",children:")"}),(0,i.jsx)(n.mi,{mathvariant:"normal",children:"."})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\lvert \\mathrm{GHZ}_n\\rangle \\;=\\; \\frac{1}{\\sqrt{2}}\\Big(\\lvert 0\\rangle^{\\otimes n} \\,+\\, \\lvert 1\\rangle^{\\otimes n}\\Big)."})]})})}),(0,i.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"\u2223"}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"mord mathrm",children:"GHZ"})}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.1514em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]}),(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"="}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.8em",verticalAlign:"-0.65em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mopen nulldelimiter"}),(0,i.jsx)(n.span,{className:"mfrac",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsxs)(n.span,{className:"vlist",style:{height:"0.8451em"},children:[(0,i.jsxs)(n.span,{style:{top:"-2.551em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:(0,i.jsx)(n.span,{className:"mord sqrt mtight",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsxs)(n.span,{className:"vlist",style:{height:"0.9128em"},children:[(0,i.jsxs)(n.span,{className:"svg-align",style:{top:"-3em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"mord mtight",style:{paddingLeft:"0.833em"},children:(0,i.jsx)(n.span,{className:"mord mtight",children:"2"})})]}),(0,i.jsxs)(n.span,{style:{top:"-2.8728em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"hide-tail mtight",style:{minWidth:"0.853em",height:"1.08em"},children:(0,i.jsx)(n.svg,{xmlns:"http://www.w3.org/2000/svg",width:"400em",height:"1.08em",viewBox:"0 0 400000 1080",preserveAspectRatio:"xMinYMin slice",children:(0,i.jsx)(n.path,{d:"M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z"})})})]})]}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.1272em"},children:(0,i.jsx)(n.span,{})})})]})})})})]}),(0,i.jsxs)(n.span,{style:{top:"-3.23em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"frac-line",style:{borderBottomWidth:"0.04em"}})]}),(0,i.jsxs)(n.span,{style:{top:"-3.394em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"3em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:(0,i.jsx)(n.span,{className:"mord mtight",children:"1"})})})]})]}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.538em"},children:(0,i.jsx)(n.span,{})})})]})}),(0,i.jsx)(n.span,{className:"mclose nulldelimiter"})]}),(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"delimsizing size2",children:"("})}),(0,i.jsx)(n.span,{className:"mopen",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord",children:"0"}),(0,i.jsxs)(n.span,{className:"mclose",children:[(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.7713em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mtight",children:"\u2297"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})]})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,i.jsx)(n.span,{className:"mbin",children:"+"}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"1.8em",verticalAlign:"-0.65em"}}),(0,i.jsx)(n.span,{className:"mopen",children:"\u2223"}),(0,i.jsx)(n.span,{className:"mord",children:"1"}),(0,i.jsxs)(n.span,{className:"mclose",children:[(0,i.jsx)(n.span,{className:"mclose",children:"\u27e9"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.7713em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mtight",children:"\u2297"}),(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"})]})})]})})})})})]}),(0,i.jsx)(n.span,{className:"mord",children:(0,i.jsx)(n.span,{className:"delimsizing size2",children:")"})}),(0,i.jsx)(n.span,{className:"mord",children:"."})]})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ang isang napaka-simpleng paraan upang ihanda ang GHZ state ay ang pumili ng isang root qubit na may paunang Hadamard gate, na naglalagay ng qubit sa isang pantay na superposition state, at pagkatapos ay i-entangle ang qubit na ito sa bawat isa pang qubit. Hindi ito isang magandang pamamaraan, dahil nangangailangan ito ng mahabang-distansya at malalim na CNOT na interaksyon. Sa tutorial na ito, gagamitin namin ang maraming teknik kasabay ng pagdetekta ng error upang mapagkakatiwalaang ihanda ang GHZ state sa tunay na hardware."}),"\n",(0,i.jsx)(n.h3,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Hakbang 2: I-optimize ang problema para sa pagpapatakbo sa quantum hardware"}),"\n",(0,i.jsx)(n.h4,{id:"map-the-ghz-state-to-hardware",children:"I-map ang GHZ state sa hardware"}),"\n",(0,i.jsx)(n.p,{children:"Una, naghahanap tayo ng isang root para i-map ang GHZ circuit sa hardware. Tinatanggal natin ang mga edge/node na ang kanilang mga CZ error, measurement error, at T2 na halaga ay mas malala kaysa sa mga threshold sa ibaba. Hindi sila isasama sa GHZ circuit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def bad_cz(target, threshold=0.01):\n    """Return list of edges whose CZ error is worse than threshold."""\n    undirected_edges = []\n    for edge in backend.target.build_coupling_map().get_edges():\n        if (edge[1], edge[0]) not in undirected_edges:\n            undirected_edges.append(edge)\n    edges = undirected_edges\n    cz_errors = {}\n    for edge in edges:\n        cz_errors[edge] = target["cz"][edge].error\n    worst_edges = sorted(cz_errors.items(), key=lambda x: x[1], reverse=True)\n    return [list(edge) for edge, error in worst_edges if error > threshold]\n\ndef bad_readout(target, threshold=0.01):\n    """Return list of nodes whose measurement error is worse than threshold."""\n    meas_errors = {}\n    for node in range(backend.num_qubits):\n        meas_errors[node] = target["measure"][(node,)].error\n    worst_nodes = sorted(\n        meas_errors.items(), key=lambda x: x[1], reverse=True\n    )\n    return [node for node, error in worst_nodes if error > threshold]\n\ndef bad_coherence(target, threshold=60):\n    """Return list of nodes whose T2 value is lower than threshold."""\n    t2s = {}\n    for node in range(backend.num_qubits):\n        t2 = target.qubit_properties[node].t2\n        t2s[node] = t2 * 1e6 if t2 else 0\n    worst_nodes = sorted(t2s.items(), key=lambda x: x[1])\n    return [node for node, val in worst_nodes if val < threshold]\n\nTHRESH_CZ = 0.025  # exclude from BFS those edges whose CZ error is worse than this threshold\nTHRESH_MEAS = 0.15  # exclude from BFS those nodes whose measurement error is worse than this threshold\nTHRESH_T2 = 10  # exclude from BFS those nodes whose T2 value is lower than this threshold\n\nbad_edges = bad_cz(backend.target, threshold=THRESH_CZ)\nbad_nodes_readout = bad_readout(backend.target, threshold=THRESH_MEAS)\ndead_qubits = bad_readout(backend.target, threshold=0.4)\nbad_nodes_coherence = bad_coherence(backend.target, threshold=THRESH_T2)\nbad_nodes = list(set(bad_nodes_readout) | set(bad_nodes_coherence))\nprint(f"{len(bad_edges)} bad edges: \\n{bad_edges}")\nprint(f"{len(bad_nodes)} bad nodes: \\n{bad_nodes}")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"17 bad edges:\n[[30, 31], [112, 113], [113, 114], [113, 119], [120, 121], [130, 131], [145, 146], [146, 147], [111, 112], [55, 59], [64, 65], [131, 138], [131, 132], [119, 133], [129, 130], [47, 57], [29, 38]]\n5 bad nodes:\n[1, 113, 131, 146, 120]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Gamit ang function sa ibaba, binubuo natin ang GHZ circuit sa piniling hardware simula sa root at gumagamit ng breadth-first search (BFS)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def parallel_ghz(root, num_qubits, backend, bad_edges, skip):\n    """\n    Build a GHZ state of size `num_qubits` on the given `backend`,\n    starting from `root`, expanding in BFS order.\n\n    At each BFS layer, every active qubit adds at most one new neighbor\n    (so that two-qubit operations can run in parallel with no qubit conflicts).\n\n    It grows the entanglement tree outward layer-by-layer.\n    """\n\n    # -------------------------------------------------------------\n    # (1) Filter usable connections from the backend coupling map\n    # -------------------------------------------------------------\n    # The coupling map lists all directed hardware connections as (control, target).\n    # We remove edges that are:\n    #   - listed in `bad_edges` (or their reversed form)\n    #   - involve a qubit in the `skip` list\n    cmap = backend.configuration().coupling_map\n    edges = [\n        e\n        for e in cmap\n        if e not in bad_edges\n        and [e[1], e[0]] not in bad_edges\n        and e[0] not in skip\n        and e[1] not in skip\n    ]\n\n    # -------------------------------------------------------------\n    # (2) Build an undirected adjacency list for traversal\n    # -------------------------------------------------------------\n    # Even though coupling_map edges are directed, BFS expansion just needs\n    # connectivity information (so we treat edges as undirected for search).\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # -------------------------------------------------------------\n    # (3) Initialize the quantum circuit and BFS state\n    # -------------------------------------------------------------\n    n = backend.configuration().num_qubits\n    qc = QuantumCircuit(\n        n\n    )  # create a circuit with same number of qubits as hardware\n    visited = [\n        root\n    ]  # record the order qubits are added to the GHZ chain/tree\n    queue = deque([root])  # BFS queue (start from root)\n    explored = defaultdict(\n        set\n    )  # to track which neighbors each node has already explored\n    layers = []  # list of per-layer (control, target) gate tuples\n    qc.h(root)  # GHZ states start with a Hadamard on the root qubit\n\n    # -------------------------------------------------------------\n    # (4) BFS expansion: build the GHZ tree one layer at a time\n    # -------------------------------------------------------------\n    # Loop until we\'ve added the desired number of qubits to the GHZ\n    while queue and len(visited) < num_qubits:\n        layer = []  # collect new (control, target) pairs for this layer\n        current = list(\n            queue\n        )  # snapshot current frontier (so queue mutations don\'t affect iteration)\n        busy = (\n            set()\n        )  # track qubits already used in this layer (to avoid conflicts)\n\n        for node in current:\n            queue.popleft()\n\n            # find one unvisited neighbor of this node not already explored\n            unvisited_neighbors = [\n                nb\n                for nb in adj[node]\n                if nb not in visited and nb not in explored[node]\n            ]\n\n            if unvisited_neighbors:\n                nb = unvisited_neighbors[\n                    0\n                ]  # pick the first available neighbor\n                visited.append(nb)  # mark it as part of the GHZ structure\n                queue.append(\n                    node\n                )  # re-enqueue current node (can keep growing)\n                queue.append(nb)  # enqueue the newly added qubit\n                explored[node].add(nb)  # mark that edge as explored\n                layer.append(\n                    (node, nb)\n                )  # schedule a CNOT between node and neighbor\n                busy.update([node, nb])  # reserve both qubits for this layer\n\n                # stop early if we\'ve reached the desired number of qubits\n                if len(visited) == num_qubits:\n                    break\n            # else: node has no unused unvisited neighbors left \u2192 skip\n\n        if layer:\n            # add all pairs (node, nb) scheduled this round to layers\n            layers.append(layer)\n        else:\n            # nothing new discovered this pass \u2192 done\n            break\n\n    # -------------------------------------------------------------\n    # (5) Emit all layers into the quantum circuit\n    # -------------------------------------------------------------\n    # For each layer:\n    #   - apply a CX gate for every (control, target) pair\n    #   - insert a barrier so transpiler keeps layer structure\n    for layer in layers:\n        for q1, q2 in layer:\n            qc.cx(q1, q2)\n        qc.barrier()\n\n    # -------------------------------------------------------------\n    # (6) Return outputs\n    # -------------------------------------------------------------\n    # qc: the built quantum circuit\n    # visited: order of qubits added\n    # layers: list of parallelizable two-qubit operations per step\n    return qc, visited, layers\n'})}),"\n",(0,i.jsx)(n.p,{children:"Paulit-ulit na naghahanap tayo ng pinakamahusay na root, kung saan magsisimula ang GHZ circuit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"ROOT = None  # root for BFS search\nGHZ_SIZE = 100  # number of (data) qubits in the GHZ state\nSKIP = []  # nodes to intentionally skip so that we have a better chance for finding checks\n\n# Search for the best root (yielding the shallowest GHZ)\nif ROOT is None:\n    best_root = -1\n    base_depth = 100\n    for root in range(backend.num_qubits):\n        qc, ghz_qubits, _ = parallel_ghz(\n            root, GHZ_SIZE, backend, bad_edges, SKIP\n        )\n        if len(ghz_qubits) != GHZ_SIZE:\n            continue\n        depth = qc.depth(lambda x: x.operation.num_qubits == 2)\n        if depth < base_depth:\n            best_root = root\n            base_depth = depth\n    ROOT = best_root\n"})}),"\n",(0,i.jsx)(n.p,{children:"Binubuo na natin ngayon ang GHZ circuit simula sa isang tiyak na node \u2014 ang pinakamahusay na root \u2014 naghahanap ng pinakamaikling depth gamit ang breadth-first search."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Build a GHZ starting at the best root\nqc, ghz_qubits, _ = parallel_ghz(\n    ROOT, GHZ_SIZE, backend, bad_edges, SKIP + bad_nodes\n)\nbase_depth = qc.depth(lambda x: x.operation.num_qubits == 2)\nbase_count = qc.size(lambda x: x.operation.num_qubits == 2)\nprint(f"base depth: {base_depth}, base count: {base_count}")\nprint(f"ROOT: {ROOT}")\nif len(ghz_qubits) != GHZ_SIZE:\n    raise Exception("No GHZ found. Relax error thresholds.")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"base depth: 17, base count: 99\nROOT: 50\n"})}),"\n",(0,i.jsxs)(n.p,{children:['Kailangan pa nating isaalang-alang ang isang huling bagay bago maglagay ng mga wastong check. Ito ay may kaugnayan sa konsepto ng "coverage", na isang sukatan ng kung gaano karaming wire sa isang quantum circuit ang maaaring saklawin ng isang check. Sa mas mataas na coverage, mas malawak na bahagi ng circuit ang ating matutukoy na may error. Sa pamamagitan ng sukatan na ito, maaari tayong pumili sa mga wastong check na may pinakamataas na circuit coverage. Sa ibang salita, gagamitin natin ang ',(0,i.jsx)(n.code,{children:"weighted_coverage"})," na function para i-score ang iba't ibang check para sa GHZ circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def weighted_coverage(layers, parities, w_idle=0.2, w_gate=0.8):\n    """\n    Compute weighted fraction (idle + gate) of wires that are\n    covered by at least one parity to all active wires.\n    """\n    wires = active_wires(layers)  # defined below\n    covered_by_any = {n_layer: set() for n_layer in range(len(layers))}\n    for parity in parities:\n        trace = z_trace_backward(layers, parity)  # defined below\n        for n_layer, qs in trace.items():\n            covered_by_any[n_layer] |= qs\n    covered_weight = 0\n    total_weight = 0\n    for n_layer in range(len(layers)):\n        idle = wires[n_layer]["idle"]\n        gate = wires[n_layer]["gate"]\n        total_weight += w_idle * len(idle) + w_gate * len(gate)\n        covered_idle = covered_by_any[n_layer] & idle\n        covered_gate = covered_by_any[n_layer] & gate\n        covered_weight += w_idle * len(covered_idle) + w_gate * len(\n            covered_gate\n        )\n    return covered_weight / total_weight if total_weight > 0 else 0\n\ndef active_wires(layers):\n    """\n    Returns per-layer dict with two sets:\n    - \'idle\': activated wires that are idle in this layer\n    - \'gate\': activated wires that are control/target of a CNOT at this layer\n    """\n    first_activation = {}\n    for n_layer, layer in enumerate(layers):\n        for c, t in layer:\n            first_activation.setdefault(c, n_layer)\n            first_activation.setdefault(t, n_layer)\n    result = {}\n    for n_layer in range(len(layers)):\n        active = {\n            q\n            for q, n_layer0 in first_activation.items()\n            if n_layer >= n_layer0\n        }\n        gate = {q for c, t in layers[n_layer] for q in (c, t)}\n        idle = active - gate\n        result[n_layer] = {"idle": idle, "gate": gate}\n    return result\n\ndef z_trace_backward(layers, initial_Zs):\n    """\n    Backward propagate Zs with parity cancellation.\n    Returns {layer: set of qubits with odd parity Z at that layer}.\n    """\n    wires = active_wires(layers)\n    support = set(initial_Zs)\n    trace = {}\n    for n_layer in range(len(layers) - 1, -1, -1):\n        active = wires[n_layer]["idle"] | wires[n_layer]["gate"]\n        trace[n_layer] = support & active\n        # propagate backwards\n        new_support = set()\n        for q in support:\n            hit = False\n            for c, t in layers[n_layer]:\n                if q == t:  # Z on target: copy to control\n                    new_support ^= {t, c}  # toggle both\n                    hit = True\n                    break\n                elif q == c:  # Z on control: passes through\n                    new_support ^= {c}\n                    hit = True\n                    break\n            if not hit:  # unaffected\n                new_support ^= {q}\n        support = new_support\n    return trace\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Maaari na nating ipasok ang mga tseke sa GHZ circuit. Ang paghahanap ng mga wastong tseke ay napaka-maginhawa para sa GHZ state, dahil ang anumang two-qubit Pauli ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"Z"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"Z"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"})]})})]})," operator na ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"Z"}),(0,i.jsx)(n.mi,{children:"i"})]}),(0,i.jsxs)(n.msub,{children:[(0,i.jsx)(n.mi,{children:"Z"}),(0,i.jsx)(n.mi,{children:"j"})]})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"Z_i Z_j"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.9694em",verticalAlign:"-0.2861em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3117em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(n.span,{})})})]})})]}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(n.span,{className:"vlist-r",children:[(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.3117em"},children:(0,i.jsxs)(n.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(n.span,{className:"mord mathnormal mtight",style:{marginRight:"0.05724em"},children:"j"})})]})}),(0,i.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.2861em"},children:(0,i.jsx)(n.span,{})})})]})})]})]})})]})," na kumikilos sa anumang dalawang qubit na ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"i"}),(0,i.jsx)(n.mo,{separator:"true",children:","}),(0,i.jsx)(n.mi,{children:"j"})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"i,j"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.854em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,i.jsx)(n.span,{className:"mpunct",children:","}),(0,i.jsx)(n.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.05724em"},children:"j"})]})})]})," ng GHZ circuit ay isang suporta at samakatuwid ay isang wastong tseke."]}),"\n",(0,i.jsxs)(n.p,{children:["Pansinin din na ang mga tseke sa kasong ito ay controlled-",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsx)(n.mi,{children:"Z"})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"Z"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"})]})})]})," operators na kalapit ng mga Hadamard gates mula sa kaliwa at kanan ng ancilla qubit. Ito ay katumbas ng isang CNOT gate na inilapat sa ancilla qubit. Ang code sa ibaba ay nagpapasok ng mga tseke sa circuit."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# --- Tunables controlling the search space / scoring ---\nMAX_SKIPS = 10  # at most how many qubits to skip (in addition to the bad ones and the ones forced to skip above)\nSHUFFLES = 200  # how many times to try removing nodes for checks\nMAX_DEPTH_INCREASE = 10  # how far from the base GHZ depth to go to include checks (increase this for more checks at expense of depth)\n\nW_IDLE = 0.2  # weight of errors to consider during idle timesteps\nW_GATE = 0.8  # weight of errors to consider during gates\n\n# Remove random nodes from the GHZ and build from the root again to increase checks\ndegree_two_nodes = [\n    i\n    for i in ghz_qubits\n    if all(n in ghz_qubits for n in coupling_map.neighbors(i))\n    and len(coupling_map.neighbors(i)) >= 2\n]\n\n# --- Best-so-far tracking for the randomized search ---\nnum_checks = 0\nbest_covered_fraction = -1\nbest_qc = qc\nbest_checks = []\nbest_parities = []\nbest_layers = []\n\n# Outer loop: vary how many GHZ nodes we try skipping (0..MAX_SKIPS-1)\nfor num_skips in range(MAX_SKIPS):\n    # Inner loop: try SHUFFLES random choices of 'num_skips' nodes to skip\n    for _ in range(SHUFFLES):\n        # Construct the skip set:\n        #   - pre-existing forced SKIP\n        #   - plus a random sample of 'degree_two_nodes' of size 'num_skips'\n        skip = SKIP + list(np.random.choice(degree_two_nodes, num_skips))\n\n        # Rebuild the GHZ using the current skip set and bad_nodes\n        qc, ghz_qubits, layers = parallel_ghz(\n            ROOT, GHZ_SIZE, backend, bad_edges, skip + bad_nodes\n        )\n\n        # Measure circuit cost as 2-qubit-gate depth only\n        depth = qc.depth(lambda x: x.operation.num_qubits == 2)\n\n        # If we failed to reach the target GHZ size, discard this attempt\n        if len(ghz_qubits) != GHZ_SIZE:\n            continue\n\n        # --- Build \"checks\" around the GHZ we just constructed ---\n        # A check qubit is a non-GHZ, non-dead qubit that has \u22652 neighbors inside the GHZ\n        # and all those incident edges are usable (i.e., not in bad_edges).\n        checks = []\n        parities = []\n        for i in range(backend.num_qubits):\n            neighbors = [\n                n for n in coupling_map.neighbors(i) if n in ghz_qubits\n            ]\n\n            if (\n                i not in ghz_qubits\n                and i not in dead_qubits\n                and len(neighbors) >= 2\n                and not any(\n                    [\n                        [neighbor, i] in bad_edges\n                        or [i, neighbor] in bad_edges\n                        for neighbor in neighbors\n                    ]\n                )\n            ):\n                # Record this qubit as a check qubit\n                checks.append(i)\n                parities.append((neighbors[0], neighbors[1]))\n                # Physically couple the check qubit 'i' to the two GHZ neighbors via CNOTs\n                # (This is the actual \"check\" attachment in the circuit.)\n                qc.cx(neighbors[0], i)\n                qc.cx(neighbors[1], i)\n\n        # Score this design using the weighted coverage metric over the GHZ build layers\n        covered_fraction = weighted_coverage(\n            layers=layers, parities=parities, w_idle=W_IDLE, w_gate=W_GATE\n        )\n\n        # Keep it only if:\n        #   - coverage improves over the best so far, AND\n        #   - the 2q depth budget isn't blown by more than MAX_DEPTH_INCREASE\n        if (\n            covered_fraction > best_covered_fraction\n            and depth <= base_depth + MAX_DEPTH_INCREASE\n        ):\n            best_covered_fraction = covered_fraction\n            best_qc = qc\n            best_ghz_qubits = ghz_qubits\n            best_checks = checks\n            best_parities = parities\n            best_layers = layers\n"})}),"\n",(0,i.jsx)(n.p,{children:"Maaari na nating i-print ang mga qubit na ginagamit sa GHZ circuit at ang mga check qubit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# --- After search, report the best design found ---\nqc = best_qc\nchecks = best_checks\nparities = best_parities\nlayers = best_layers\nghz_qubits = best_ghz_qubits\nif len(ghz_qubits) != GHZ_SIZE:\n    raise Exception("No GHZ found. Relax error thresholds.")\n\nprint(f"GHZ qubits: {ghz_qubits} {len(ghz_qubits)}")\nprint(f"Check qubits: {checks} {len(checks)}")\n\ncovered_fraction = weighted_coverage(\n    layers=layers, parities=parities, w_idle=W_IDLE, w_gate=W_GATE\n)\nprint(\n    "Covered fraction (no idle): ",\n    weighted_coverage(\n        layers=layers, parities=parities, w_idle=0.0, w_gate=1.0\n    ),\n)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"GHZ qubits: [50, 49, 51, 38, 52, 48, 58, 53, 47, 71, 39, 46, 70, 54, 33, 45, 72, 69, 55, 32, 37, 73, 68, 34, 31, 44, 25, 74, 78, 67, 18, 24, 79, 75, 89, 57, 11, 23, 93, 59, 88, 66, 10, 22, 92, 90, 87, 65, 12, 9, 21, 94, 91, 86, 77, 13, 8, 20, 95, 98, 97, 14, 7, 36, 99, 111, 107, 15, 6, 41, 115, 110, 106, 19, 17, 5, 40, 114, 109, 108, 105, 27, 4, 42, 118, 104, 28, 3, 129, 117, 103, 29, 2, 128, 125, 96, 30, 127, 124, 102] 100\nCheck qubits: [16, 26, 35, 43, 85, 126] 6\nCovered fraction (no idle):  0.4595959595959596\n"})}),"\n",(0,i.jsx)(n.p,{children:"Maaari din nating i-print ang ilang mga istatistika ng error."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def circuit_errors(target, circ, error_type="cz"):\n    """\n    Pull per-resource error numbers from a Qiskit Target\n    for ONLY the qubits/edges actually used by `circ`.\n\n    Args:\n        target: qiskit.transpiler.Target (e.g., backend.target)\n        circ:   qiskit.QuantumCircuit\n        error_type: one of {"cz", "meas", "t1", "t2"}:\n            - "cz"   -> 2q CZ gate error on the circuit\'s used edges\n            - "meas" -> measurement error on the circuit\'s used qubits\n            - "t1"   -> T1 (converted to microseconds) on used qubits\n            - "t2"   -> T2 (converted to microseconds) on used qubits\n\n    Returns:\n        list[float] of the requested quantity for the active edges/qubits.\n    """\n\n    # Get all 2-qubit edges that appear in the circuit (as undirected pairs).\n    active_edges = active_gates(circ)  # e.g., {(0,1), (2,3), ...}\n\n    # Intersect those with the device coupling map (so we only query valid edges).\n    # Note: target.build_coupling_map().get_edges() yields directed pairs.\n    edges = [\n        edge\n        for edge in target.build_coupling_map().get_edges()\n        if tuple(sorted(edge)) in active_edges\n    ]\n\n    # Deduplicate direction: keep only one orientation of each edge.\n    undirected_edges = []\n    for edge in edges:\n        if (edge[1], edge[0]) not in undirected_edges:\n            undirected_edges.append(edge)\n    edges = undirected_edges  # (not used later\u2014see note below)\n\n    # Accumulators for different error/physics quantities\n    cz_errors, meas_errors, t1_errors, t2_errors = [], [], [], []\n\n    # For every active (undirected) edge in the circuit, fetch its CZ error.\n    # NOTE: Uses active_gates(circ) again (undirected tuples). This assumes\n    # `target[\'cz\']` accepts undirected indexing; many Targets store both directions.\n    for edge in active_gates(circ):\n        cz_errors.append(target["cz"][edge].error)\n\n    # For every active qubit, fetch measure error and T1/T2 (converted to \xb5s).\n    for qubit in active_qubits(circ):\n        meas_errors.append(target["measure"][(qubit,)].error)\n        t1_errors.append(\n            target.qubit_properties[qubit].t1 * 1e6\n        )  # seconds -> microseconds\n        t2_errors.append(\n            target.qubit_properties[qubit].t2 * 1e6\n        )  # seconds -> microseconds\n\n    # Select which set to return.\n    if error_type == "cz":\n        return cz_errors\n    elif error_type == "meas":\n        return meas_errors\n    elif error_type == "t1":\n        return t1_errors\n    else:\n        return t2_errors\n\ndef active_qubits(circ):\n    """\n    Return a list of qubit indices that participate in at least one\n    non-delay, non-barrier instruction in `circ`.\n    """\n    active_qubits = set()\n    for inst in circ.data:\n        # Skip scheduling artifacts that don\'t act on state\n        if (\n            inst.operation.name != "delay"\n            and inst.operation.name != "barrier"\n        ):\n            for qubit in inst.qubits:\n                q = circ.find_bit(\n                    qubit\n                ).index  # map Qubit object -> integer index\n                active_qubits.add(q)\n    return list(active_qubits)\n\ndef active_gates(circ):\n    """\n    Return a set of undirected 2-qubit edges (i, j) that appear in `circ`.\n    """\n    used_2q_gates = set()\n    for inst in circ:\n        if inst.operation.num_qubits == 2:\n            qs = inst.qubits\n            # map Qubit objects -> indices, then sort to make the edge undirected\n            qs = sorted([circ.find_bit(q).index for q in qs])\n            used_2q_gates.add(tuple(sorted(qs)))\n    return used_2q_gates\n\n# ---- Print summary statistics ----\ncz_errors = circuit_errors(backend.target, qc, error_type="cz")\nmeas_errors = circuit_errors(backend.target, qc, error_type="meas")\nt1_errors = circuit_errors(backend.target, qc, error_type="t1")\nt2_errors = circuit_errors(backend.target, qc, error_type="t2")\n\nnp.set_printoptions(linewidth=np.inf)\nprint(\n    f"cz errors: \\n mean: {np.round(np.mean(cz_errors), 3)}, max: {np.round(np.max(cz_errors), 3)}"\n)\nprint(\n    f"meas errors: \\n mean: {np.round(np.mean(meas_errors), 3)}, max: {np.round(np.max(meas_errors), 3)}"\n)\nprint(\n    f"t1 errors: \\n mean: {np.round(np.mean(t1_errors), 1)}, min: {np.round(np.min(t1_errors), 1)}"\n)\nprint(\n    f"t2 errors: \\n mean: {np.round(np.mean(t2_errors), 1)}, min: {np.round(np.min(t2_errors), 1)}"\n)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"cz errors: \n mean: 0.002, max: 0.012\nmeas errors: \n mean: 0.014, max: 0.121\nt1 errors: \n mean: 267.9, min: 23.6\nt2 errors: \n mean: 155.9, min: 13.9\n"})}),"\n",(0,i.jsx)(n.p,{children:"Tulad ng dati, maaari nating i-simulate ang circuit nang una sa kawalan ng ingay upang matiyak ang kawastuhan ng GHZ state preparation circuit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# --- Simulate to ensure correctness ---\n\nqc_meas = qc.copy()\n\n# Add measurements to the GHZ qubits\nc1 = ClassicalRegister(len(ghz_qubits), "c1")\nqc_meas.add_register(c1)\nfor q, c in zip(ghz_qubits, c1):\n    qc_meas.measure(q, c)\n\n# Add measurements to the check qubits\nif len(checks) > 0:\n    c2 = ClassicalRegister(len(checks), "c2")\n    qc_meas.add_register(c2)\n    for q, c in zip(checks, c2):\n        qc_meas.measure(q, c)\n\n# Simulate the circuit with stabilizer method\nsim_stab = AerSimulator(method="stabilizer")\nres = sim_stab.run(qc_meas, shots=1000).result()\ncounts = res.get_counts()\nprint("Stabilizer simulation result:")\nprint(counts)\n\n# Rename keys to "0 0" and "0 1" for easier plotting\n# First len(checks) bits are check bits, rest are GHZ bits\nkeys = list(counts.keys())\nfor key in keys:\n    check_bits = key[: len(checks)]\n    ghz_bits = key[(len(checks) + 1) :]\n    if set(check_bits) == {"0"} and set(ghz_bits) == {"0"}:\n        counts["0 0"] = counts.pop(key)\n    elif set(check_bits) == {"0"} and set(ghz_bits) == {"1"}:\n        counts["0 1"] = counts.pop(key)\n    else:\n        continue\n\nplot_histogram(counts)\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"Stabilizer simulation result:\n{'000000 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111': 525, '000000 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000': 475}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(7431).A+"",width:"630",height:"470"})}),"\n",(0,i.jsx)(n.p,{children:"Tulad ng inaasahan, ang mga check qubit ay nasusukat bilang lahat ng sero, at matagumpay nating nahanda ang GHZ state."}),"\n",(0,i.jsx)(n.h3,{id:"step-3-execute-using-qiskit-primitives",children:"Hakbang 3: Isagawa gamit ang Qiskit primitives"}),"\n",(0,i.jsx)(n.p,{children:"Handa na tayo ngayon na patakbuhin ang circuit sa tunay na hardware at ipakita kung paano nakakakuha ng mga error ang error detection protocol sa paghahanda ng GHZ state."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"BAD_QUBITS = []  # specify any additional bad qubits to avoid (this is specific to the chosen backend)\nSHOTS = 10000  # number of shots\n"})}),"\n",(0,i.jsx)(n.p,{children:"Nagtatakda tayo ng isang helper function upang idagdag ang mga sukat sa GHZ circuit."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def add_measurements(qc, ghz_qubits, checks):\n    # --- Measure each set of qubits into different classical registers to facilitate post-processing ---\n\n    # Add measurements to the GHZ qubits\n    c1 = ClassicalRegister(len(ghz_qubits), "c1")\n    qc.add_register(c1)\n    for q, c in zip(ghz_qubits, c1):\n        qc.measure(q, c)\n\n    # Add measurements to the check qubits\n    c2 = ClassicalRegister(len(checks), "c2")\n    qc.add_register(c2)\n    for q, c in zip(checks, c2):\n        qc.measure(q, c)\n\n    return qc\n'})}),"\n",(0,i.jsx)(n.p,{children:"Bago ang pagpapatakbo, iginuhit natin ang layout ng GHZ qubits at ng check qubits sa napiling hardware."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Plot the layout of GHZ and check qubits on the device\nplot_gate_map(\n    backend,\n    label_qubits=True,\n    line_width=20,\n    line_color=[\n        "black"\n        if edge[0] in ghz_qubits + checks and edge[1] in ghz_qubits + checks\n        else "lightgrey"\n        for edge in backend.coupling_map.graph.edge_list()\n    ],\n    qubit_color=[\n        "blue"\n        if i in ghz_qubits\n        else "salmon"\n        if i in checks\n        else "lightgrey"\n        for i in range(0, backend.num_qubits)\n    ],\n)\nplt.show()\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(10030).A+"",width:"660",height:"499"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'qc.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(56626).A+"",width:"3810",height:"6870"})}),"\n",(0,i.jsx)(n.p,{children:"Idinaragdag na natin ngayon ang mga sukat."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"qc = add_measurements(qc, ghz_qubits, checks)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Ang scheduling pipeline sa ibaba ay nagtatakda ng timing, nag-aalis ng mga barrier, nagpapasimple ng mga delay, at naglalagay ng dynamical decoupling, habang pinapanatili ang orihinal na oras ng operasyon."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# The scheduling consists of first inserting delays while barriers are still there\n# Then removing the barriers and consolidating the delays, so that the operations do not move in time\n# Lastly we replace delays with dynamical decoupling\ncollect_function = partial(\n    collect_using_filter_function,\n    filter_function=(lambda node: node.op.name == "delay"),\n    split_blocks=True,\n    min_block_size=2,\n    split_layers=False,\n    collect_from_back=False,\n    max_block_width=None,\n)\n\ncollapse_function = partial(\n    collapse_to_operation,\n    collapse_function=(\n        lambda circ: Delay(sum(inst.operation.duration for inst in circ))\n    ),\n)\n\nclass Unschedule(AnalysisPass):\n    """Removes a property from the passmanager property set so that the circuit looks unscheduled, so we can schedule it again."""\n\n    def run(self, dag):\n        del self.property_set["node_start_time"]\n\ndef build_passmanager(backend, dd_qubits=None):\n    pm = generate_preset_pass_manager(\n        target=backend.target,\n        layout_method="trivial",\n        optimization_level=2,\n        routing_method="none",\n    )\n\n    pm.scheduling = PassManager(\n        [\n            ALAPScheduleAnalysis(target=backend.target),\n            PadDelay(target=backend.target),\n            RemoveBarriers(),\n            Unschedule(),\n            CollectAndCollapse(\n                collect_function=collect_function,\n                collapse_function=collapse_function,\n            ),\n            ALAPScheduleAnalysis(target=backend.target),\n            PadDynamicalDecoupling(\n                dd_sequence=[XGate(), RZGate(-np.pi), XGate(), RZGate(np.pi)],\n                spacing=[1 / 4, 1 / 2, 0, 0, 1 / 4],\n                target=backend.target,\n                qubits=dd_qubits,\n            ),\n        ]\n    )\n\n    return pm\n'})}),"\n",(0,i.jsx)(n.p,{children:"Maaari na nating gamitin ang custom pass manager upang i-transpile ang circuit para sa napiling backend."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Transpile the circuits for the backend\npm = build_passmanager(backend, ghz_qubits)\n\n# Instruction set architecture (ISA) level circuit after scheduling and DD insertion\n isa_circuit = pm.run(qc)\n\n# Draw after scheduling and DD insertion\n# timeline_drawer(isa_circuit, show_idle=False, time_range=(0, 1000), target=backend.target)\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'isa_circuit.draw("mpl", fold=-1, idle_wires=False)\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(32520).A+"",width:"13665",height:"7011"})}),"\n",(0,i.jsx)(n.p,{children:"Isinusumite natin ang trabaho gamit ang Qiskit Runtime Sampler primitive."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Select the sampler options\nsampler = Sampler(mode=backend)\nsampler.options.default_shots = SHOTS\nsampler.options.dynamical_decoupling.enable = False\nsampler.options.execution.rep_delay = 0.00025\n\n# Submit the job\nprint("Submitting sampler job")\nghz_job = sampler.run([isa_circuit])\n\nprint(ghz_job.job_id())\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:"d493f17nmdfs73abf9qg\n"})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Hakbang 4: Post-process at ibalik ang resulta sa nais na klasikal na format"}),"\n",(0,i.jsx)(n.p,{children:"Maaari na nating kunin at suriin ang mga resulta mula sa Sampler job."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Retrieve the job results\njob_result = ghz_job.result()\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Get the counts from GHZ and check qubit measurements\nghz_counts = job_result[0].data.c1.get_counts()\nchecks_counts = job_result[0].data.c2.get_counts()\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# Post-process to get unflagged GHZ counts (i.e., check bits are all '0')\njoined_counts = job_result[0].join_data().get_counts()\nunflagged_counts = {}\nfor key, count in joined_counts.items():\n    check_bits = key[: len(checks)]\n    ghz_bits = key[len(checks) :]\n    if set(check_bits) == {\"0\"}:\n        unflagged_counts[ghz_bits] = count\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Get top 20 outcomes by frequency from the unflagged counts\ntop_counts = dict(\n    sorted(unflagged_counts.items(), key=lambda x: x[1], reverse=True)[:20]\n)\n\n# Rename keys for better visualization\ntop_counts_renamed = {}\ni = 0\nfor key, count in top_counts.items():\n    if set(key) == {"0"}:\n        top_counts_renamed["all 0s"] = count\n    elif set(key) == {"1"}:\n        top_counts_renamed["all 1s"] = count\n    else:\n        top_counts_renamed[f"other_{i}"] = count\n        i += 1\n\nplot_histogram(top_counts_renamed, figsize=(12, 7))\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Output of the previous code cell",src:e(38314).A+"",width:"1189",height:"690"})}),"\n",(0,i.jsx)(n.p,{children:"Sa histogram sa itaas, nagpakita tayo ng 20 bitstring na sukat mula sa GHZ qubits na hindi na-flag ng mga check qubit. Gaya ng inaasahan, ang all-0 at all-1 na mga bitstring ang may pinakamataas na bilang. Dapat pansinin na ang ilang maling bitstring na may mababang error weight ay hindi nakuha ng error detection. Ang pinakamataas na bilang ay makikita pa rin sa mga inaasahang bitstring."}),"\n",(0,i.jsx)(n.h2,{id:"discussion",children:"Talakayan"}),"\n",(0,i.jsxs)(n.p,{children:["Sa tutorial na ito, ipinakita natin kung paano ipatupad ang isang low-overhead na pamamaraan ng error detection gamit ang mga spacetime code, at ipinakita ang tunay na aplikasyon nito sa paghahanda ng mga GHZ state sa hardware. Sumangguni sa ",(0,i.jsx)(n.a,{href:"https://arxiv.org/abs/2510.09520",children:"[3]"})," upang mas malalim na tuklasin ang mga teknikal na detalye ng paghahanda ng GHZ state. Bukod sa error detection, ginagamit ng mga may-akda ang readout error mitigation gamit ang M3 at TREX at nagsasagawa ng mga pamamaraan ng pansamantalang uncomputation upang maghanda ng mga high-fidelity na GHZ state."]}),"\n",(0,i.jsx)(n.h3,{id:"references",children:"Mga Sanggunian"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["[1] Martiel, S., & Javadi-Abhari, A. (2025). Low-overhead error detection with spacetime codes. ",(0,i.jsx)(n.em,{children:"arXiv preprint arXiv:2504.15725."})]}),"\n",(0,i.jsxs)(n.li,{children:["[2] van den Berg, E., Bravyi, S., Gambetta, J. M., Jurcevic, P., Maslov, D., & Temme, K. (2023). Single-shot error mitigation by coherent Pauli checks. ",(0,i.jsx)(n.em,{children:"Physical Review Research"}),", 5(3), 033193."]}),"\n"]})]})}function d(a={}){const{wrapper:n}={...(0,t.R)(),...a.components};return n?(0,i.jsx)(n,{...a,children:(0,i.jsx)(o,{...a})}):o(a)}},69066(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},32520(a,n,e){e.d(n,{A:()=>s});const s=e.p+"assets/images/0c4b279b-0-91316b1ab0e11561feb517424632c0ac.avif"},96956(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},99405(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},34792(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},97134(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},56626(a,n,e){e.d(n,{A:()=>s});const s=e.p+"assets/images/78c8c2b6-0-2fa53aec723d68528765ff8ef541a241.avif"},7431(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},10030(a,n,e){e.d(n,{A:()=>s});const s=e.p+"assets/images/d0faf114-0-27d78f2ebdb6250209af5c69cf3baa78.avif"},38314(a,n,e){e.d(n,{A:()=>s});const s=e.p+"assets/images/d7902975-0-c34f2c9fe0eb82e171ec12438b783e67.avif"},88233(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,AAAAHGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZgAAAXBtZXRhAAAAAAAAACFoZGxyAAAAAAAAAABwaWN0AAAAAAAAAAAAAAAAAAAAAA5waXRtAAAAAAABAAAANGlsb2MAAAAAREAAAgABAAAAAAGUAAEAAAAAAAADIAACAAAAAAS0AAEAAAAAAAAALAAAADhpaW5mAAAAAAACAAAAFWluZmUCAAAAAAEAAGF2MDEAAAAAFWluZmUCAAAAAAIAAGF2MDEAAAAAr2lwcnAAAACKaXBjbwAAAAxhdjFDgQAMAAAAABRpc3BlAAAAAAAAAPEAAACuAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAcAAAAAA5waXhpAAAAAAEIAAAAOGF1eEMAAAAAdXJuOm1wZWc6bXBlZ0I6Y2ljcDpzeXN0ZW1zOmF1eGlsaWFyeTphbHBoYQAAAAAdaXBtYQAAAAAAAAACAAEDgQIDAAIEhAIFhgAAABppcmVmAAAAAAAAAA5hdXhsAAIAAQABAAADVG1kYXQSAAoKGB38K1ggIaDQgDKPBkyAArR9LZsadZOTHztkUQWjEIuZDbJCXnOM1pK8yvnv6OiW4W/EGjD8W++FXMtvRrPeKpZ0RgGPXLf7rpQ/ahx3H7qEoqgilPLlPpb3nESUtgxyhHqkLUCVcXyxGlSskGSMq8koVmJ0uRIFzJ0NbTclsHWP04BmJQ3javr8FM5yYjPNWNVtckOJn4DMcV2R/2LnSh0QzgfJu9US6uTLbg1MFEaGXp5dm4onJkHCrkcWVG3N4sFugSWZXlwQnWOilCTfhjjduorBJOspS50/vMigKlMVw87QKMx7UEocwLcnlQ5q2sec/mTEwvpMD3z+rf/Hku6SzmL9a+lOMojM08chuQH/KQo2lHn7c0Y4Hxhe2q9/5ds2mxAE4RXxoN4ZeUiRaoZ+MVQ9CW+Vuj86kUC3T7AO4E+e5Sn0+bMPfzW6bS5YM7aXzTdgTTqPUNd2CvytIfGVrSZKqfDpQZ1UML2VF2tD10M6TuKTVlG7v8gLCXAawjnwq61cUcWC20D6XhHEP6OYVkO+Hd0UnNMGL1QADQYSdABauuVqX6nW+GrQIRJdhOzvbuKDQpXZnMy83vMjHvJQNeUlvJ7rX1gYAyzWklyGh0TSEkraBsWAVbQW8XzuzowIydDr2ll/1DjEJs4p/SePJXlRANSKGLxbB2+6xAkv36vd+DGDyGphqTBMjMo/Gm2TDSYzQwSM4/13bzoubcNJJyhbrYsgE+KxKfxj/sYRCFvZ0L3ac+C0LiE0Ij/f5n2EEBqcpiTy/tYzgyXA/3Qmqi0z4iPyafx/jG2kxdfxrhUSPLAqn38CDfcjlcg1iwKx9fMTxRwNeJtb2jL1teuZUODVr27RQaG77ZCy8+ontpYvg5F9LT9mk7tO4vQMswkIoQ+4GuMk6vbQ83ei57ACZ7i2U0LI5L4Sj5A7WV+dVLhE0Yquuz5Db7GE+N7IpO97SqCMjUkWH9LNtNvd2iggctEPIsNN2Ronn5gk4MFIzJWApgMMJMphRkJERZXap9Vxa5SzUzYb4EhC1LSUjcD1CgAd67BtzpDJ3BIACgYYHfwrWFQyIBIACihAthjTOnzznMAJ2Rm5oSTXG8T1kJ1Tsh4vZx6g"},27198(a,n,e){e.d(n,{A:()=>s});const s="data:image/avif;base64,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"},28453(a,n,e){e.d(n,{R:()=>r,x:()=>c});var s=e(96540);const i={},t=s.createContext(i);function r(a){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof a?a(n):{...n,...a}},[n,a])}function c(a){let n;return n=a.disableParentContext?"function"==typeof a.components?a.components(i):a.components||i:r(a.components),s.createElement(t.Provider,{value:n},a.children)}}}]);