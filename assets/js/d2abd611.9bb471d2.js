"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5232],{98568(e,t,n){n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/qiskit-addons-cutting-gates","title":"Get started with gate cutting","description":"Two worked examples of gate cutting using the circuit cutting addon to get started with the package","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/qiskit-addons-cutting-gates.mdx","sourceDirName":"guides","slug":"/guides/qiskit-addons-cutting-gates","permalink":"/guides/qiskit-addons-cutting-gates","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/qiskit-addons-cutting-gates.mdx","tags":[],"version":"current","frontMatter":{"title":"Get started with gate cutting","sidebar_label":"Get started with gate cutting","description":"Two worked examples of gate cutting using the circuit cutting addon to get started with the package","notebook_path":"docs/guides/qiskit-addons-cutting-gates.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Circuit cutting","permalink":"/guides/qiskit-addons-cutting"},"next":{"title":"Get started with wire cuts","permalink":"/guides/qiskit-addons-cutting-wires"}}');var s=n(74848),a=n(28453);const r={title:"Get started with gate cutting",sidebar_label:"Get started with gate cutting",description:"Two worked examples of gate cutting using the circuit cutting addon to get started with the package",notebook_path:"docs/guides/qiskit-addons-cutting-gates.ipynb"},c="Get started with circuit cutting using gate cuts",o={},l=[{value:"Gate cutting to reduce circuit depth",id:"gate-cutting-to-reduce-circuit-depth",level:2},{value:"Gate cutting to reduce circuit width",id:"gate-cutting-to-reduce-circuit-width",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:i,Details:r,OpenInLabBanner:c}=t;return i||h("Admonition",!0),r||h("Details",!0),c||h("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(t.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(t.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(c,{notebookPath:"docs/guides/qiskit-addons-cutting-gates.ipynb"}),"\n",(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"get-started-with-circuit-cutting-using-gate-cuts",children:"Get started with circuit cutting using gate cuts"})}),"\n","\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Package versions"})}),(0,s.jsx)(t.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\nqiskit-aer~=0.17\nqiskit-addon-cutting~=0.10.0\n"})})]}),"\n",(0,s.jsxs)(t.p,{children:["This guide demonstrates two working examples of gate cuts with the ",(0,s.jsx)(t.code,{children:"qiskit-addon-cutting"})," package. The first example shows how to reduce circuit depth (the number of circuit instructions) by cutting entangling gates on non-adjacent qubits that would otherwise incur a SWAP overhead when transpiled to hardware. The second example covers how to use gate cutting to reduce the circuit width (the number of qubits) by splitting a circuit into several circuits with fewer qubits."]}),"\n",(0,s.jsxs)(t.p,{children:["Both examples will use the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.efficient_su2",children:(0,s.jsx)(t.code,{children:"efficient_su2"})})," ansatz and reconstructs the same observable."]}),"\n",(0,s.jsx)(t.h2,{id:"gate-cutting-to-reduce-circuit-depth",children:"Gate cutting to reduce circuit depth"}),"\n",(0,s.jsx)(t.p,{children:"The following workflow reduces a circuit's depth by cutting distant gates, avoiding a large series of SWAP gates that would otherwise be introduced."}),"\n",(0,s.jsxs)(t.p,{children:["Start with the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.efficient_su2",children:(0,s.jsx)(t.code,{children:"efficient_su2"})}),' ansatz, with "circular" entanglement to introduce distant gates.']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-addon-cutting\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import efficient_su2\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit_ibm_runtime.fake_provider import FakeManilaV2\nfrom qiskit_ibm_runtime import SamplerV2, Batch\nfrom qiskit_aer.primitives import EstimatorV2\nfrom qiskit_addon_cutting import (\n    cut_gates,\n    partition_problem,\n    generate_cutting_experiments,\n    reconstruct_expectation_values,\n)\n\ncircuit = efficient_su2(num_qubits=4, entanglement="circular")\ncircuit.assign_parameters([0.4] * len(circuit.parameters), inplace=True)\n\nobservable = SparsePauliOp(["ZZII", "IZZI", "-IIZZ", "XIXI", "ZIZZ", "IXIX"])\nprint(f"Observable: {observable}")\ncircuit.draw("mpl", scale=0.8)\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Observable: SparsePauliOp(['ZZII', 'IZZI', 'IIZZ', 'XIXI', 'ZIZZ', 'IXIX'],\n              coeffs=[ 1.+0.j,  1.+0.j, -1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(8659).A+"",width:"1079",height:"237"})}),"\n",(0,s.jsxs)(t.p,{children:["Each of the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.CXGate",children:(0,s.jsx)(t.code,{children:"CNOT"})})," gates between qubits ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsxs)(t.msub,{children:[(0,s.jsx)(t.mi,{children:"q"}),(0,s.jsx)(t.mn,{children:"0"})]})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"q_0"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsxs)(t.span,{className:"mord",children:[(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"q"}),(0,s.jsx)(t.span,{className:"msupsub",children:(0,s.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(t.span,{className:"vlist-r",children:[(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.3011em"},children:(0,s.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"},children:[(0,s.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(t.span,{className:"mord mtight",children:"0"})})]})}),(0,s.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(t.span,{className:"vlist-r",children:(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(t.span,{})})})]})})]})]})})]})," and ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsxs)(t.msub,{children:[(0,s.jsx)(t.mi,{children:"q"}),(0,s.jsx)(t.mn,{children:"3"})]})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"q_3"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,s.jsxs)(t.span,{className:"mord",children:[(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"q"}),(0,s.jsx)(t.span,{className:"msupsub",children:(0,s.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(t.span,{className:"vlist-r",children:[(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.3011em"},children:(0,s.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"},children:[(0,s.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(t.span,{className:"mord mtight",children:"3"})})]})}),(0,s.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(t.span,{className:"vlist-r",children:(0,s.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(t.span,{})})})]})})]})]})})]})," introduce two SWAP gates after transpilation (assuming the qubits are connected in a straight line). To avoid this increase in depth, you can replace these distant gates with ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qpd-two-qubit-qpd-gate",children:(0,s.jsx)(t.code,{children:"TwoQubitQPDGate"})})," objects using the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#cut_gates",children:(0,s.jsx)(t.code,{children:"cut_gates()"})})," method.  This function also returns a list of ",(0,s.jsx)(t.a,{href:"../api/qiskit-addon-cutting/qpd-qpd-basis",children:(0,s.jsx)(t.code,{children:"QPDBasis"})})," instances - one for each decomposition."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Find the indices of the distant gates\ncut_indices = [\n    i\n    for i, instruction in enumerate(circuit.data)\n    if {circuit.find_bit(q)[0] for q in instruction.qubits} == {0, 3}\n]\n\n# Decompose distant CNOTs into TwoQubitQPDGate instances\nqpd_circuit, bases = cut_gates(circuit, cut_indices)\n\nqpd_circuit.draw("mpl", scale=0.8)\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(57029).A+"",width:"1228",height:"237"})}),"\n",(0,s.jsxs)(t.p,{children:["Now that the cut gate instructions have been added, the subexperiments will have a smaller depth after transpilation than the original circuit. The code snippet below generates the subexperiments using the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#generate_cutting_experiments",children:(0,s.jsx)(t.code,{children:"generate_cutting_experiments"})}),", which ingests the circuit and observable to reconstruct."]}),"\n",(0,s.jsx)(i,{type:"note",title:"Note about the number of samples",children:(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"num_samples"})," argument specifies how many samples to draw from the quasi-probability distribution and determines the accuracy of the coefficients used for the reconstruction. Passing infinity (",(0,s.jsx)(t.code,{children:"np.inf"}),") will ensure all coefficients are calculated exactly. Read the API docs on ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qpd#generate_qpd_weights",children:"generating weights"})," and ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#generate_cutting_experiments",children:"generating cutting experiments"})," for more information."]})}),"\n",(0,s.jsxs)(t.p,{children:["Once the subexperiments are generated, you can then transpile them and use the ",(0,s.jsx)(t.code,{children:"Sampler"})," primitive to sample the distribution and reconstruct the estimated expectation values. The following code block generates, transpiles, and executes the subexperiments. It then reconstructs the results and compares them to the exact expectation value."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Generate the subexperiments and sampling coefficients\nsubexperiments, coefficients = generate_cutting_experiments(\n    circuits=qpd_circuit, observables=observable.paulis, num_samples=np.inf\n)\n\n# Set a backend to use and transpile the subexperiments\nbackend = FakeManilaV2()\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, backend=backend\n)\nisa_subexperiments = pass_manager.run(subexperiments)\n\n# Set up the Qiskit Runtime Sampler primitive, submit the subexperiments, and retrieve the results\nsampler = SamplerV2(backend)\njob = sampler.run(isa_subexperiments, shots=4096 * 3)\nresults = job.result()\n\n# Reconstruct the results\nreconstructed_expval_terms = reconstruct_expectation_values(\n    results,\n    coefficients,\n    observable.paulis,\n)\n\n# Apply the coefficients of the original observable\nreconstructed_expval = np.dot(reconstructed_expval_terms, observable.coeffs)\n\nestimator = EstimatorV2()\nexact_expval = (\n    estimator.run([(circuit, observable, [0.4] * len(circuit.parameters))])\n    .result()[0]\n    .data.evs\n)\nprint(\n    f"Reconstructed expectation value: {np.real(np.round(reconstructed_expval, 8))}"\n)\nprint(f"Exact expectation value: {np.round(exact_expval, 8)}")\nprint(\n    f"Error in estimation: {np.real(np.round(reconstructed_expval-exact_expval, 8))}"\n)\nprint(\n    f"Relative error in estimation: {np.real(np.round((reconstructed_expval-exact_expval) / exact_expval, 8))}"\n)\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Reconstructed expectation value: 0.49812826\nExact expectation value: 0.50497603\nError in estimation: -0.00684778\nRelative error in estimation: -0.0135606\n"})}),"\n",(0,s.jsxs)(i,{type:"caution",title:"Note about observable coefficients",children:[(0,s.jsxs)(t.p,{children:["To accurately reconstruct the expectation value, the coefficients of the original observable (which are different from the coefficients in the output of ",(0,s.jsx)(t.code,{children:"generate_cutting_experiments()"}),") must be applied to the output of the reconstruction, since this information was lost when the cutting experiments were generated or when the observable was expanded."]}),(0,s.jsxs)(t.p,{children:["Typically these coefficients can be applied through ",(0,s.jsx)(t.code,{children:"numpy.dot()"})," as shown above."]})]}),"\n",(0,s.jsx)(t.h2,{id:"gate-cutting-to-reduce-circuit-width",children:"Gate cutting to reduce circuit width"}),"\n",(0,s.jsxs)(t.p,{children:["This section demonstrates using gate cutting to reduce circuit width. Start with the same ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.efficient_su2",children:(0,s.jsx)(t.code,{children:"efficient_su2"})}),' but use "linear" entanglement.']}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'qc = efficient_su2(4, entanglement="linear", reps=2)\nqc.assign_parameters([0.4] * len(qc.parameters), inplace=True)\n\nobservable = SparsePauliOp(["ZZII", "IZZI", "-IIZZ", "XIXI", "ZIZZ", "IXIX"])\nprint(f"Observable: {observable}")\n\nqc.draw("mpl", scale=0.8)\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Observable: SparsePauliOp(['ZZII', 'IZZI', 'IIZZ', 'XIXI', 'ZIZZ', 'IXIX'],\n              coeffs=[ 1.+0.j,  1.+0.j, -1.+0.j,  1.+0.j,  1.+0.j,  1.+0.j])\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(30469).A+"",width:"634",height:"237"})}),"\n",(0,s.jsxs)(t.p,{children:["Then generate the ",(0,s.jsx)(t.em,{children:"subcircuits"})," and ",(0,s.jsx)(t.em,{children:"subobservables"})," you'll execute using the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#partition_problem",children:(0,s.jsx)(t.code,{children:"partition_problem()"})})," function. This function takes in the circuit, observable, and an optional partitioning scheme and returns the cut circuits and observables in the form of a dictionary."]}),"\n",(0,s.jsxs)(t.p,{children:["The partitioning is defined by a label string of the form ",(0,s.jsx)(t.code,{children:'"AABB"'})," where each label in this string corresponds to the qubit in the same index of the ",(0,s.jsx)(t.code,{children:"circuit"})," argument. Qubits sharing a common partition label are grouped together, and any non-local gates that span more than one partition will be cut."]}),"\n",(0,s.jsx)(i,{type:"info",title:"Note",children:(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"observables"})," kwarg to ",(0,s.jsx)(t.code,{children:"partition_problem"})," is of type ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.quantum_info.PauliList",children:(0,s.jsx)(t.code,{children:"PauliList"})}),". Observable term coefficients and phases are ignored during decomposition of the problem and execution of the subexperiments. They may be re-applied during reconstruction of the expectation value."]})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'partitioned_problem = partition_problem(\n    circuit=qc, partition_labels="AABB", observables=observable.paulis\n)\nsubcircuits = partitioned_problem.subcircuits\nsubobservables = partitioned_problem.subobservables\nbases = partitioned_problem.bases\n\nprint(f"Sampling overhead: {np.prod([basis.overhead for basis in bases])}")\nprint(f"Subobservables: {subobservables}")\nsubcircuits["A"].draw("mpl", scale=0.8)\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Sampling overhead: 81.0\nSubobservables: {'A': PauliList(['II', 'ZI', 'ZZ', 'XI', 'ZZ', 'IX']), 'B': PauliList(['ZZ', 'IZ', 'II', 'XI', 'ZI', 'IX'])}\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(51471).A+"",width:"694",height:"138"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'subcircuits["B"].draw("mpl", scale=0.8)\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(90993).A+"",width:"694",height:"138"})}),"\n",(0,s.jsxs)(t.p,{children:["The next step is then to use the subcircuits and subobservables to generate the ",(0,s.jsx)(t.em,{children:"subexperiments"})," to be executed on a QPU using the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#generate_cutting_experiments",children:(0,s.jsx)(t.code,{children:"generate_cutting_experiments"})})," method."]}),"\n",(0,s.jsxs)(t.p,{children:["To estimate the expectation value of the full-sized circuit, many subexperiments are generated from the decomposed gates' joint quasi-probability distribution and then executed on one or more QPUs. The number of samples to be taken from this distribution is controlled by the ",(0,s.jsx)(t.code,{children:"num_samples"})," argument."]}),"\n",(0,s.jsxs)(t.p,{children:["The following code block generates the subexperiments and executes them using the ",(0,s.jsx)(t.code,{children:"Sampler"})," primitive on a local simulator. (To run these on a QPU, change the ",(0,s.jsx)(t.code,{children:"backend"})," to your chosen QPU resource.)"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"subexperiments, coefficients = generate_cutting_experiments(\n    circuits=subcircuits, observables=subobservables, num_samples=np.inf\n)\n\n# Set a backend to use and transpile the subexperiments\nbackend = FakeManilaV2()\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, backend=backend\n)\nisa_subexperiments = {\n    label: pass_manager.run(partition_subexpts)\n    for label, partition_subexpts in subexperiments.items()\n}\n\n# Submit each partition's subexperiments to the Qiskit Runtime Sampler\n# primitive, in a single batch so that the jobs will run back-to-back.\nwith Batch(backend=backend) as batch:\n    sampler = SamplerV2(mode=batch)\n    jobs = {\n        label: sampler.run(subsystem_subexpts, shots=4096 * 3)\n        for label, subsystem_subexpts in isa_subexperiments.items()\n    }\n\n# Retrieve results\nresults = {label: job.result() for label, job in jobs.items()}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Lastly, the expectation value of the full circuit is reconstructed using the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#reconstruct_expectation_values",children:(0,s.jsx)(t.code,{children:"reconstruct_expectation_values"})})," method."]}),"\n",(0,s.jsx)(t.p,{children:"The code block below reconstructs the results and compares them with the exact expectation value."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Get expectation values for each observable term\nreconstructed_expval_terms = reconstruct_expectation_values(\n    results,\n    coefficients,\n    subobservables,\n)\n\n# Reconstruct final expectation value\nreconstructed_expval = np.dot(reconstructed_expval_terms, observable.coeffs)\n\nestimator = EstimatorV2()\nexact_expval = (\n    estimator.run([(qc, observable, [0.4] * len(qc.parameters))])\n    .result()[0]\n    .data.evs\n)\nprint(\n    f"Reconstructed expectation value: {np.real(np.round(reconstructed_expval, 8))}"\n)\nprint(f"Exact expectation value: {np.round(exact_expval, 8)}")\nprint(\n    f"Error in estimation: {np.real(np.round(reconstructed_expval-exact_expval, 8))}"\n)\nprint(\n    f"Relative error in estimation: {np.real(np.round((reconstructed_expval-exact_expval) / exact_expval, 8))}"\n)\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Reconstructed expectation value: 0.53571896\nExact expectation value: 0.56254612\nError in estimation: -0.02682716\nRelative error in estimation: -0.04768882\n"})}),"\n",(0,s.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(i,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Read the ",(0,s.jsx)(t.a,{href:"/guides/qiskit-addons-cutting-wires",children:"Get started with circuit cutting using wire cuts"})," guide."]}),"\n",(0,s.jsxs)(t.li,{children:["Read the arXiv paper on ",(0,s.jsx)(t.a,{href:"https://ieeexplore.ieee.org/document/10236453",children:"circuit knitting with classical communication."})]}),"\n"]})})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function h(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},8659(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/1551c440-c158-478a-a8fe-86df834c59bd-1-bf76ffea5c6a8cf04ec151909db62218.svg"},90993(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/1c527720-0d06-48a1-88b6-9ff95a77a068-0-c767cd7439b469fe827ab0d2272405f6.svg"},30469(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/64010a14-8360-47e2-bb77-af9b2e0dbbfc-1-c7e7d78bc96c5d9b1160da71a2b28419.svg"},57029(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/66dc0a14-ab51-4190-9cda-1c0373e91b9e-0-e9e989232d769301007ae0f42a85f978.svg"},51471(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/a5454265-3785-4a54-b423-baf7815b97ec-1-fb5ab39916cde211ea29840dff0f5193.svg"},28453(e,t,n){n.d(t,{R:()=>r,x:()=>c});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);