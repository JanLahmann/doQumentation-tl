"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1446],{3697(e,i,t){t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"guides/create-a-provider","title":"Create a provider","description":"A short guide on integrating Qiskit into an external provider\'s quantum resources.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/create-a-provider.mdx","sourceDirName":"guides","slug":"/guides/create-a-provider","permalink":"/guides/create-a-provider","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/create-a-provider.mdx","tags":[],"version":"current","frontMatter":{"title":"Create a provider","description":"A short guide on integrating Qiskit into an external provider\'s quantum resources."},"sidebar":"tutorialsSidebar","previous":{"title":"Qiskit SDK version strategy","permalink":"/guides/qiskit-sdk-version-strategy"},"next":{"title":"Securing your data","permalink":"/guides/secure-data"}}');var r=t(74848),s=t(28453);const a={title:"Create a provider",description:"A short guide on integrating Qiskit into an external provider's quantum resources."},o="Integrate external quantum resources with Qiskit",c={},d=[{value:"Providing access to backends",id:"providing-access-to-backends",level:2},{value:"Providing an interface for execution",id:"providing-an-interface-for-execution",level:2}];function l(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:["\n",(0,r.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,r.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"integrate-external-quantum-resources-with-qiskit",children:"Integrate external quantum resources with Qiskit"})}),"\n",(0,r.jsx)(i.p,{children:"The Qiskit SDK is built to support third parties in creating external providers of quantum resources."}),"\n",(0,r.jsx)(i.p,{children:"This means that any organization that develops or deploys quantum compute resources can integrate their services into Qiskit and tap into its userbase."}),"\n",(0,r.jsx)(i.p,{children:"Doing so requires creating a package that supports requests for quantum compute resources and returns them to the user."}),"\n",(0,r.jsxs)(i.p,{children:["Additionally, the package must allow users to submit jobs and retrieve their results through an implementation of the ",(0,r.jsx)(i.code,{children:"qiskit.primitives"})," objects."]}),"\n",(0,r.jsx)(i.h2,{id:"providing-access-to-backends",children:"Providing access to backends"}),"\n",(0,r.jsxs)(i.p,{children:["In order for users to transpile and execute ",(0,r.jsx)(i.code,{children:"QuantumCircuit"})," objects using external resources, they need to instantiate an object containing a ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.transpiler.Target",children:(0,r.jsx)(i.code,{children:"Target"})})," which provides information about a QPU's constraints such as its connectivity, basis gates, and number of qubits. This can be provided through an interface similar to the ",(0,r.jsx)(i.a,{href:"../api/qiskit-ibm-runtime/qiskit-runtime-service",children:(0,r.jsx)(i.code,{children:"QiskitRuntimeService"})})," through which a user can make requests for a QPU. This object should, at minimum, contain a ",(0,r.jsx)(i.code,{children:"Target"}),", but a simpler approach would be to return a ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.providers.BackendV2",children:(0,r.jsx)(i.code,{children:"BackendV2"})})," instance."]}),"\n",(0,r.jsx)(i.p,{children:"An example implementation may look something like:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:'from qiskit.transpiler import Target\nfrom qsikit.providers import BackendV2\n\nclass ProviderService:\n    """ Class for interacting with a provider\'s service"""\n\n    def __init__(\n        self,\n        #Receive arguments for authentication/instantiation\n    ):\n        """ Initiate a connection with the provider service, given some method \n                of authentication """\n\n    def return_target(name: Str) -> Target:\n        """ Interact with the service and return a Target object """\n        return target\n\n    def return_backend(name: Str) -> BackendV2:\n        """ Interact with the service and return a BackendV2 object """\n        return backend\n\n'})}),"\n",(0,r.jsx)(i.h2,{id:"providing-an-interface-for-execution",children:"Providing an interface for execution"}),"\n",(0,r.jsxs)(i.p,{children:["In addition to providing a service returning hardware configurations, a service providing access to external QPU resources also might also support the execution of quantum workloads. Exposing that capability can be done by creating implementations of the Qiskit primitives interfaces; for example the ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BasePrimitiveJob",children:(0,r.jsx)(i.code,{children:"BasePrimitiveJob"})}),", ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BaseEstimatorV2",children:(0,r.jsx)(i.code,{children:"BaseEstimatorV2"})})," and ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BaseSamplerV2",children:(0,r.jsx)(i.code,{children:"BaseSamplerV2"})})," among others. At minimum, these interfaces should be able to provide a method for execution, querying job status, and returning the job results."]}),"\n",(0,r.jsxs)(i.p,{children:["To handle job status and results, the Qiskit SDK provides a ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.DataBin",children:(0,r.jsx)(i.code,{children:"DataBin"})}),", ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.PubResult",children:(0,r.jsx)(i.code,{children:"PubResult"})}),", ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.PrimitiveResult",children:(0,r.jsx)(i.code,{children:"PrimitiveResult"})}),", and ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BasePrimitiveJob",children:(0,r.jsx)(i.code,{children:"BasePrimitiveJob"})})," objects should be used."]}),"\n",(0,r.jsxs)(i.p,{children:["See the ",(0,r.jsx)(i.code,{children:"qiskit.primitives"})," ",(0,r.jsx)(i.a,{href:"../api/qiskit/primitives",children:"API documentation"})," as well as the reference implementations ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BackendEstimatorV2",children:(0,r.jsx)(i.code,{children:"BackendEstimatorV2"})})," and ",(0,r.jsx)(i.a,{href:"../api/qiskit/qiskit.primitives.BackendSamplerV2",children:(0,r.jsx)(i.code,{children:"BackendSampleV2"})})," for more information."]}),"\n",(0,r.jsx)(i.p,{children:"An example implementation of the Estimator primitive may look like:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:'from qiskit.primitives import BaseEstimatorV2, BaseSamplerV2, EstimatorPubLike\nfrom qiskit.primitives import DataBin, PubResult, PrimitiveResult, BasePrimitiveJob\nfrom qiskit.providers import BackendV2\n\nclass EstimatorImplementation(BaseEstimatorV2):\n    """ Class for interacting with the provider\'s Estimator service """\n\n    def __init__(\n        self,\n        *,\n        backend: BackendV2,\n        options: dict\n        # Receive other arguments to instantiate an Estimator primitive with the service\n    ):\n        self._backend = backend\n        self._options = options\n        self._default_precision = 0.01\n\n    @property\n    def backend(self) -> BackendV2:\n        """ Return the backend """\n        return self._backend\n\n    def run(\n        self, pubs: Iterable[EstimatorPubLike], *, precision: float | None = None\n    ) -> BasePrimitiveJob[PrimitiveResult[PubResult]]:\n    """ Steps to implement: \n            1. Define a default precision if none is given \n            2. Validate pub format\n            3. Instantiate an object which inherits from BasePrimitiveJob \n                containing pub and runtime information\n            4. Send the job to the execution service of the provider\n    """\n    job = BasePrimitiveJob(pubs, precision)\n    job_with_results = job.submit()\n    return job_with_results\n'})}),"\n",(0,r.jsx)(i.p,{children:"And an implementation of the Sampler primitive may look like:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:'class SamplerImplementation(BaseSamplerV2):\n    """ Class for interacting with the provider\'s Sampler service """\n\n    def __init__(\n        self,\n        *,\n        backend: BackendV2,\n        options: dict\n        # Receive other arguments to instantiate an Estimator primitive with the service\n    ):\n        self._backend = backend\n        self._options = options\n        self._default_shots = 1024\n\n    @property\n    def backend(self) -> BackendV2:\n        """ Return the Sampler\'s backend """\n        return self._backend\n\n    def run(\n        self, pubs: Iterable[SamplerPubLike], *, shots: int | None = None\n    ) -> BasePrimitiveJob[PrimitiveResult[SamplerPubResult]]:\n    """ Steps to implement: \n            1. Define a default number of shots if none is given \n            2. Validate pub format\n            3. Instantiate an object which inherits from BasePrimitiveJob \n                containing pub and runtime information\n            4. Send the job to the execution service of the provider\n            5. Return the data in some format\n    """\n    job = BasePrimitiveJob(pubs, shots)\n    job_with_results = job.submit()\n    return job_with_results\n'})})]})}function u(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453(e,i,t){t.d(i,{R:()=>a,x:()=>o});var n=t(96540);const r={},s=n.createContext(r);function a(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);