"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[4459],{48560(i,e,t){t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"guides/tools-intro","title":"Introduction to Qiskit","description":"What is Qiskit? This document provides an introduction to the Qiskit stack.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/tools-intro.mdx","sourceDirName":"guides","slug":"/guides/tools-intro","permalink":"/guides/tools-intro","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/tools-intro.mdx","tags":[],"version":"current","frontMatter":{"title":"Introduction to Qiskit","description":"What is Qiskit? This document provides an introduction to the Qiskit stack."},"sidebar":"tutorialsSidebar","previous":{"title":"Build a Qiskit Function template for Hamiltonian simulation","permalink":"/guides/function-template-hamiltonian-simulation"},"next":{"title":"Circuit library","permalink":"/guides/circuit-library"}}');var s=t(74848),r=t(28453);const a={title:"Introduction to Qiskit",description:"What is Qiskit? This document provides an introduction to the Qiskit stack."},o="Introduction to Qiskit",l={},c=[{value:"The Qiskit SDK",id:"the-qiskit-sdk",level:2},{value:"Installation",id:"installation",level:3},{value:"Benchmarking and the Benchpress package",id:"benchmarking-and-the-benchpress-package",level:3},{value:"Qiskit Runtime",id:"qiskit-runtime",level:2},{value:"Is Qiskit Runtime open-source?",id:"is-qiskit-runtime-open-source",level:3},{value:"Qiskit Serverless",id:"qiskit-serverless",level:2},{value:"Qiskit Functions",id:"qiskit-functions",level:2},{value:"Qiskit Transpiler Service",id:"qiskit-transpiler-service",level:2},{value:"Qiskit addons",id:"qiskit-addons",level:2},{value:"The Qiskit ecosystem",id:"the-qiskit-ecosystem",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(i){const e={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...i.components},{Admonition:t}=e;return t||function(i,e){throw new Error("Expected "+(e?"component":"object")+" `"+i+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(e.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(e.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n","\n",(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"introduction-to-qiskit",children:"Introduction to Qiskit"})}),"\n",(0,s.jsx)(e.p,{children:'The name "Qiskit" is a general term referring to a collection of software for executing programs on quantum computers. Most notably among these software tools is the open-source Qiskit SDK, and the runtime environment (accessed using Qiskit Runtime) through which you can execute workloads on IBM\xae quantum processing units (QPUs). As quantum technology evolves, so does Qiskit, with new capabilities released every year that expand this core collection of quantum software.'}),"\n",(0,s.jsx)(e.p,{children:"In addition, many open-source projects are part of the broader Qiskit ecosystem. These software tools are not part of Qiskit itself, but rather interface with Qiskit and can provide valuable additional functionality."}),"\n",(0,s.jsxs)(e.p,{children:["IBM is committed to the responsible development of quantum computing. Learn more and review our responsible quantum principles in the ",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/responsible-quantum-computing",children:"Responsible quantum computing"})," topic."]}),"\n",(0,s.jsx)(e.h2,{id:"the-qiskit-sdk",children:"The Qiskit SDK"}),"\n",(0,s.jsxs)(e.p,{children:["The Qiskit SDK (package name ",(0,s.jsx)(e.a,{href:"https://pypi.org/project/qiskit/",children:(0,s.jsx)(e.code,{children:"qiskit"})}),") is an open-source SDK for working with quantum computers at the level of extended (static, dynamic, and scheduled) quantum circuits, operators, and primitives. This library is the core component of Qiskit; it is the largest package under the Qiskit name with the broadest suite of tools for quantum computation, and many other components interface with it."]}),"\n",(0,s.jsx)(e.p,{children:"Some of the most useful features of the Qiskit SDK include:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Circuit-building tools"})," (",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/circuit",children:(0,s.jsx)(e.code,{children:"qiskit.circuit"})}),") - For initializing and manipulating registers, circuits, instructions, gates, parameters, and control flow objects."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Circuit library"})," (",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/circuit_library",children:(0,s.jsx)(e.code,{children:"qiskit.circuit.library"})}),") - A vast range of circuits, instructions, and gates - key building blocks for circuit-based quantum computations."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Quantum info library"})," (",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/quantum_info",children:(0,s.jsx)(e.code,{children:"qiskit.quantum_info"})}),") - A toolkit for working with quantum states, operators and channels, using exact calculations (no sampling noise). Use this module to specify input observables and analyze fidelity of outputs from primitives queries."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Transpiler"})," (",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/transpiler",children:(0,s.jsx)(e.code,{children:"qiskit.transpiler"})}),") - For transforming and adapting quantum circuits to suit specific device topology, and optimizing for execution on real quantum processing units (QPUs)."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Primitives"})," (",(0,s.jsx)(e.a,{href:"https://docs.quantum.ibm.com/api/qiskit/primitives",children:(0,s.jsx)(e.code,{children:"qiskit.primitives"})}),") - The module that contains the base definitions and reference implementations of the Sampler and Estimator primitives, from which different quantum hardware providers can derive their own implementations. See more information about the Qiskit Runtime primitives ",(0,s.jsx)(e.a,{href:"./primitives",children:"in the documentation"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(e.p,{children:["For a more detailed introduction to installing the Qiskit SDK, check out the ",(0,s.jsx)(e.a,{href:"./install-qiskit",children:"installation page"}),". If you're ready to install it now, simply run:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit\n"})}),"\n",(0,s.jsx)(e.h3,{id:"benchmarking-and-the-benchpress-package",children:"Benchmarking and the Benchpress package"}),"\n",(0,s.jsxs)(e.p,{children:["Benchmarking is important for comparing the relative performance of quantum software across different stages of a development workflow. Benchmarking tests for quantum software might, for example, look at the speed and quality of building, manipulating, and transpiling circuits. IBM Quantum is committed to delivering the most performant SDK possible, and to that end, the Qiskit SDK is benchmarked using over 1,000 tests developed by leading universities, national labs, and researchers at IBM. The benchmarking suite used for these tests, named Benchpress, is now available as ",(0,s.jsx)(e.a,{href:"https://github.com/qiskit/benchpress",children:"an open-source package"}),". You can now use the Benchpress package to perform your own analysis of quantum SDK performance."]}),"\n",(0,s.jsx)(e.h2,{id:"qiskit-runtime",children:"Qiskit Runtime"}),"\n",(0,s.jsxs)(e.p,{children:["Qiskit Runtime is a cloud-based service for executing quantum computations on IBM Quantum\xae hardware. The ",(0,s.jsx)(e.code,{children:"qiskit-ibm-runtime"})," package is a client for that service, and is the successor to the Qiskit IBM Provider. The Qiskit Runtime service streamlines quantum computations and provides optimal implementations of the Qiskit primitives for IBM Quantum hardware. To get started with Qiskit Runtime primitives, visit the ",(0,s.jsx)(e.a,{href:"./get-started-with-primitives",children:"documentation"}),"."]}),"\n",(0,s.jsxs)(e.p,{children:["Qiskit Runtime is designed to use additional classical and quantum compute resources, including techniques such as error suppression and error mitigation, to return a higher-quality result from executing quantum circuits on quantum processors. Examples include dynamical decoupling for error suppression, and readout mitigation and zero-noise extrapolation (ZNE) for error mitigation. Learn how to configure these options on the ",(0,s.jsx)(e.a,{href:"./configure-error-mitigation",children:"Configure error mitigation"})," page."]}),"\n",(0,s.jsxs)(e.p,{children:["Qiskit Runtime also includes three types of execution modes for running your quantum program on IBM hardware: ",(0,s.jsxs)(e.a,{href:"/guides/execution-modes",children:[(0,s.jsx)(e.em,{children:"Job"}),", ",(0,s.jsx)(e.em,{children:"Session"}),", and ",(0,s.jsx)(e.em,{children:"Batch"}),","]})," each of which have different use cases and implications for the quantum job queue. A Job is a single query to a primitive that can be run over a specified number of shots. Sessions allow you to efficiently run multiple jobs in iterative workloads on quantum computers. Batch mode allows you to submit all your jobs at once for parallel processing. Note that Open Plan users cannot submit session jobs."]}),"\n",(0,s.jsx)(e.p,{children:"To quickly install Qiskit Runtime, run the following command:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-ibm-runtime\n"})}),"\n",(0,s.jsxs)(e.p,{children:["More details on setting up a development environment for building quantum programs can be found in the ",(0,s.jsx)(e.a,{href:"./install-qiskit",children:"installation page"}),"."]}),"\n",(0,s.jsx)(e.h3,{id:"is-qiskit-runtime-open-source",children:"Is Qiskit Runtime open-source?"}),"\n",(0,s.jsxs)(e.p,{children:["The short answer is, ",(0,s.jsx)(e.em,{children:"not all of it"}),". The Qiskit Runtime service software that handles the technicalities of running your quantum program on an IBM Quantum device (including any error mitigation and suppression) is ",(0,s.jsx)(e.strong,{children:"not"})," open-source. However, the Qiskit Runtime client (the interface for users to access the Qiskit Runtime service), the Qiskit SDK running on the server side, and some of the software used for error mitigation, ",(0,s.jsx)(e.strong,{children:"are"})," open-source.  To get involved with the Qiskit open-source efforts, visit our GitHub organization at ",(0,s.jsx)(e.a,{href:"https://github.com/Qiskit",children:"github.com/Qiskit"})," and ",(0,s.jsx)(e.a,{href:"https://github.com/Qiskit-Extensions/",children:"github.com/Qiskit-Extensions"}),"."]}),"\n",(0,s.jsx)(e.h2,{id:"qiskit-serverless",children:"Qiskit Serverless"}),"\n",(0,s.jsxs)(e.p,{children:["Creating utility-scale quantum applications generally requires a variety of compute resource requirements. Qiskit Serverless (",(0,s.jsx)(e.code,{children:"qiskit-ibm-catalog.QiskitServerless"}),") provides a simple interface to run workloads across quantum-classical resources. This includes deploying programs to IBM Quantum Platform and running workloads remotely, as well as easy resource management for multi-cloud and quantum-centric supercomputing use cases. See more information in the ",(0,s.jsx)(e.a,{href:"/guides/serverless",children:"Qiskit Serverless documentation"})," about how to use this collection of tools to:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Parallelize classical tasks, such as pre-processing and post-processing"}),"\n",(0,s.jsx)(e.li,{children:"Persist long-running workloads in the cloud, even if your laptop is turned off"}),"\n",(0,s.jsx)(e.li,{children:"Deploy reusable programs in the cloud"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"To start using Qiskit Serverless right away, install it with pip:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit_serverless\n"})}),"\n",(0,s.jsx)(e.h2,{id:"qiskit-functions",children:"Qiskit Functions"}),"\n",(0,s.jsxs)(e.p,{children:["Qiskit Functions (",(0,s.jsx)(e.code,{children:"qiskit-ibm-catalog.QiskitFunctionsCatalog"}),") are abstracted services designed to accelerate algorithm discovery and application prototyping. Explore the ",(0,s.jsx)(e.a,{href:"https://quantum.cloud.ibm.com/functions",children:"Qiskit Functions Catalog"}),", including:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Circuit functions"}),": Services that include transpilation, error suppression, error mitigation, and post-processing techniques that take abstract circuits and desired measurement observables as input. With Circuit functions, users can discover new algorithms and applications without needing to manage transpilation or quantum hardware performance."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Application functions"}),": Services that include entire quantum workflows, from mapping classical to quantum, optimizing for hardware, execution on hardware, and post-processing. Users can prototype industry applications with domain-familiar inputs and outputs."]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Premium Plan, Flex Plan, and On-Prem (via IBM Quantum Platform API) Plan members can access IBM-provided functions right away, or purchase licenses for the partner-provided functions directly from those partners."}),"\n",(0,s.jsx)(e.p,{children:"The catalog can be installed with pip:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-ibm-catalog\n"})}),"\n",(0,s.jsx)(e.h2,{id:"qiskit-transpiler-service",children:"Qiskit Transpiler Service"}),"\n",(0,s.jsxs)(e.p,{children:["The Qiskit Transpiler Service (",(0,s.jsxs)(e.a,{href:"https://pypi.org/project/qiskit-ibm-transpiler/",children:["package name ",(0,s.jsx)(e.code,{children:"qiskit-ibm-transpiler"})]}),") is a new experimental service that provides remote transpilation capabilities on the cloud to IBM Quantum Premium Plan, Flex Plan, and On-Prem (via IBM Quantum Platform API) Plan users. In addition to the local Qiskit SDK transpiler capabilities, your transpilation tasks can benefit from both IBM Quantum cloud resources and AI-powered transpiler passes using this service. To learn more about how to integrate cloud-based transpilation into your Qiskit workflow you can ",(0,s.jsx)(e.a,{href:"./qiskit-transpiler-service",children:"check out the documentation"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"The transpiler service can be installed with pip:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-ibm-transpiler\n"})}),"\n",(0,s.jsx)(e.h2,{id:"qiskit-addons",children:"Qiskit addons"}),"\n",(0,s.jsxs)(e.p,{children:["Qiskit addons are a collection of research capabilities for utility-scale algorithm discovery. These capabilities build upon Qiskit\u2019s performant foundation of tools for creating and running quantum algorithms. Addons are modular software components that plug into a workflow to scale or design new quantum algorithms. To learn more about the set of available Qiskit addons and how to get started using them, visit the ",(0,s.jsx)(e.a,{href:"/guides/addons",children:"documentation"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"There are a number of addons depending on what research capability you are interested in. Each of them can be installed with pip."}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"/guides/qiskit-addons-sqd",children:"Sample-based quantum diagonalization (SQD)"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-addon-sqd\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"/guides/qiskit-addons-aqc",children:"Approximate quantum compilation (AQC)"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-addon-aqc-tensor[quimb-jax]\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"/guides/qiskit-addons-obp",children:"Operator backpropagation (OBP)"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-addon-obp\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"/guides/qiskit-addons-mpf",children:"Multi-product formulas (MPF)"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"pip install qiskit-addon-mpf\n"})}),"\n",(0,s.jsx)(e.h2,{id:"the-qiskit-ecosystem",children:"The Qiskit ecosystem"}),"\n",(0,s.jsx)(e.p,{children:'Beyond Qiskit there are many open-source projects that use the "Qiskit" name but are not part of Qiskit itself; rather, they interface with Qiskit and can provide valuable additional functionality to supplement the core Qiskit workflow. Some of these projects are maintained by IBM Quantum teams, whereas others are supported by the broader open-source community. The Qiskit SDK is designed in a modular, extensible way to make it easy for developers to create projects like these that extend its capabilities.'}),"\n",(0,s.jsx)(e.p,{children:"Some popular projects in the Qiskit ecosystem include:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Qiskit Aer"})," (",(0,s.jsx)(e.code,{children:"qiskit-aer"}),") - a package for quantum computing simulators with realistic noise models. It provides interfaces to run quantum circuits with or without noise using multiple different simulation methods. Maintained by IBM Quantum."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"qBraid SDK"})," (",(0,s.jsx)(e.code,{children:"qbraid"}),") - a platform-agnostic quantum runtime framework for both quantum software and hardware providers, designed to streamline the full lifecycle management of quantum jobs\u2014from defining program specifications to job submission and through to the post-processing and visualization of results. Maintained by qBraid."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"mthree"})," ",(0,s.jsx)(e.code,{children:"mthree"})," - a package for implementing M3 (Matrix-free Measurement Mitigation), a measurement mitigation technique that solves for corrected measurement probabilities using a dimensionality reduction step followed by either direct LU factorization or a preconditioned iterative method that nominally converges in O(1) steps, and can be computed in parallel. Maintained by IBM Quantum."]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["You can find a catalog of projects in the ",(0,s.jsx)(e.a,{href:"https://qiskit.github.io/ecosystem/",children:"Qiskit ecosystem page"}),", as well as information about how to nominate your own project."]}),"\n",(0,s.jsx)(e.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(t,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["Learn about the library of circuits and instructions available in the Qiskit ",(0,s.jsx)(e.a,{href:"/guides/circuit-library",children:"circuit library"}),"."]}),"\n",(0,s.jsxs)(e.li,{children:["Read about the Qiskit transpiler and the many options for transpilation in the ",(0,s.jsx)(e.a,{href:"/guides/transpile",children:"Transpiler"})," section."]}),"\n",(0,s.jsxs)(e.li,{children:["Find out how to use ",(0,s.jsx)(e.a,{href:"/guides/primitives",children:"Qiskit primitives"})," to streamline quantum programming."]}),"\n"]})})]})}function u(i={}){const{wrapper:e}={...(0,r.R)(),...i.components};return e?(0,s.jsx)(e,{...i,children:(0,s.jsx)(d,{...i})}):d(i)}},28453(i,e,t){t.d(e,{R:()=>a,x:()=>o});var n=t(96540);const s={},r=n.createContext(s);function a(i){const e=n.useContext(r);return n.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function o(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(s):i.components||s:a(i.components),n.createElement(r.Provider,{value:e},i.children)}}}]);