"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[2387],{75599(e,t,s){s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/represent-quantum-computers","title":"Represent quantum computers","description":"Learn about coupling maps, basis gates, and processor errors for transpiling","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/represent-quantum-computers.mdx","sourceDirName":"guides","slug":"/guides/represent-quantum-computers","permalink":"/guides/represent-quantum-computers","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/represent-quantum-computers.mdx","tags":[],"version":"current","frontMatter":{"title":"Represent quantum computers","sidebar_label":"Represent quantum computers","description":"Learn about coupling maps, basis gates, and processor errors for transpiling","notebook_path":"docs/guides/represent-quantum-computers.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Commonly used parameters for transpilation","permalink":"/guides/common-parameters"},"next":{"title":"Transpile circuits remotely with the Qiskit Transpiler Service","permalink":"/guides/qiskit-transpiler-service"}}');var n=s(74848),a=s(28453);const r={title:"Represent quantum computers",sidebar_label:"Represent quantum computers",description:"Learn about coupling maps, basis gates, and processor errors for transpiling",notebook_path:"docs/guides/represent-quantum-computers.ipynb"},o="Representing quantum computers for the transpiler",c={},l=[{value:"Default configuration",id:"default-configuration",level:2},{value:"Coupling map",id:"coupling-map",level:2},{value:"Basis gates",id:"basis-gates",level:2},{value:"Device error rates",id:"device-error-rates",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components},{Admonition:i,Details:r,OpenInLabBanner:o}=t;return i||p("Admonition",!0),r||p("Details",!0),o||p("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(t.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(t.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(o,{notebookPath:"docs/guides/represent-quantum-computers.ipynb"}),"\n",(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"representing-quantum-computers-for-the-transpiler",children:"Representing quantum computers for the transpiler"})}),"\n","\n",(0,n.jsxs)(r,{children:[(0,n.jsx)("summary",{children:(0,n.jsx)("b",{children:"Package versions"})}),(0,n.jsx)(t.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,n.jsxs)(t.p,{children:["To convert an abstract circuit to an ISA circuit that can run on a specific QPU (quantum processing unit), the transpiler needs certain information about the QPU. This information is found in two places: the ",(0,n.jsx)(t.code,{children:"BackendV2"})," (or legacy ",(0,n.jsx)(t.code,{children:"BackendV1"}),") object you plan to submit jobs to, and the backend's ",(0,n.jsx)(t.code,{children:"Target"})," attribute."]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.a,{href:"../api/qiskit/qiskit.transpiler.Target",children:(0,n.jsx)(t.code,{children:"Target"})})," contains all the relevant constraints of a device, such as its native basis gates, qubit connectivity, and pulse or timing information."]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.a,{href:"../api/qiskit/qiskit.providers.BackendV2",children:(0,n.jsx)(t.code,{children:"Backend"})})," possesses a ",(0,n.jsx)(t.code,{children:"Target"})," by default, contains additional information -- such as the ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/1.4/qiskit.pulse.InstructionScheduleMap",children:(0,n.jsx)(t.code,{children:"InstructionScheduleMap"})}),", and provides the interface for submitting quantum circuit jobs."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"You can also explicitly provide information for the transpiler to use, for example, if you have a specific use case, or if you believe this information will help the transpiler generate a more optimized circuit."}),"\n",(0,n.jsxs)(t.p,{children:["The precision with which the transpiler produces the most appropriate circuit for specific hardware depends on how much information the ",(0,n.jsx)(t.code,{children:"Target"})," or ",(0,n.jsx)(t.code,{children:"Backend"})," has about its constraints."]}),"\n",(0,n.jsx)(i,{type:"note",children:(0,n.jsx)(t.p,{children:"Because many of the underlying transpilation algorithms are stochastic, there is no guarantee that a better circuit will be found."})}),"\n",(0,n.jsxs)(t.p,{children:["This page shows several examples of passing QPU information to the transpiler. These examples use the target from the ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/fake-provider-fake-sherbrooke#fakesherbrooke",children:(0,n.jsx)(t.code,{children:"FakeSherbrooke"})})," mock backend."]}),"\n",(0,n.jsx)("span",{id:"default-config"}),"\n",(0,n.jsx)(t.h2,{id:"default-configuration",children:"Default configuration"}),"\n",(0,n.jsxs)(t.p,{children:["The simplest use of the transpiler is to provide all the QPU information by providing the ",(0,n.jsx)(t.code,{children:"Backend"})," or ",(0,n.jsx)(t.code,{children:"Target"}),". To better understand how the transpiler works, construct a circuit and transpile it with different information, as follows."]}),"\n",(0,n.jsxs)(t.p,{children:["Import the necessary libraries and instantiate the QPU:\nIn order to convert an abstract circuit to an ISA circuit that can run on a specific processor, the transpiler needs certain information about the processor.  Typically, this information is stored in the ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.providers.Backend#backend",children:(0,n.jsx)(t.code,{children:"Backend"})})," or ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.Target#target",children:(0,n.jsx)(t.code,{children:"Target"})})," provided to the transpiler, and no further information is needed. However, you can also explicitly provide information for the transpiler to use, for example, if you have a specific use case, or if you believe this information will help the transpiler generate a more optimized circuit."]}),"\n",(0,n.jsxs)(t.p,{children:["This topic shows several examples of passing information to the transpiler. These examples use the target from the ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/fake-provider-fake-sherbrooke#fakesherbrooke",children:(0,n.jsx)(t.code,{children:"FakeSherbrooke"})})," mock backend."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"from qiskit_ibm_runtime.fake_provider import FakeSherbrooke\n\nbackend = FakeSherbrooke()\ntarget = backend.target\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The example circuit uses an instance of ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.circuit.library.efficient_su2",children:(0,n.jsx)(t.code,{children:"efficient_su2"})})," from Qiskit's circuit library."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from qiskit.circuit.library import efficient_su2\n\nqc = efficient_su2(12, entanglement="circular", reps=1)\n\nqc.draw("mpl")\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(49174).A+"",width:"1110",height:"786"})}),"\n",(0,n.jsxs)(t.p,{children:["This example uses default settings to transpile to the ",(0,n.jsx)(t.code,{children:"backend"}),"'s ",(0,n.jsx)(t.code,{children:"target"}),", which provides all the information needed to convert the circuit to one that will run on the backend."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from qiskit.transpiler import generate_preset_pass_manager\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, target=target, seed_transpiler=12345\n)\nqc_t_target = pass_manager.run(qc)\nqc_t_target.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(58067).A+"",width:"3141",height:"796"})}),"\n",(0,n.jsx)(t.p,{children:"This example is used in later sections of this topic to illustrate that the coupling map and basis gates are the essential pieces of information to pass to the transpiler for optimal circuit construction. The QPU can usually select default settings for other information that is not passed in, such as timing and scheduling."}),"\n",(0,n.jsx)(t.h2,{id:"coupling-map",children:"Coupling map"}),"\n",(0,n.jsx)(t.p,{children:"The coupling map is a graph that shows which qubits are connected and hence have two-qubit gates between them. Sometimes this graph is directional, meaning that the two-qubit gates can only go in one direction. However, the transpiler can always flip a gate's direction by adding additional single-qubit gates. An abstract quantum circuit can always be represented on this graph, even if its connectivity is limited, by introducing SWAP gates to move the quantum information around."}),"\n",(0,n.jsxs)(t.p,{children:["The qubits from our abstract circuits are called ",(0,n.jsx)(t.em,{children:"virtual qubits"})," and those on the coupling map are ",(0,n.jsx)(t.em,{children:"physical qubits"}),". The transpiler provides a mapping between virtual and physical qubits. One of the first steps in transpilation, the ",(0,n.jsx)(t.em,{children:"layout"})," stage, performs this mapping."]}),"\n",(0,n.jsx)(i,{type:"note",children:(0,n.jsxs)(t.p,{children:["Although the routing stage is intertwined with the ",(0,n.jsx)(t.em,{children:"layout"})," stage \u2014 which selects the actual qubits \u2014 by default, this topic treats them as separate stages for simplicity. The combination of routing and layout is called ",(0,n.jsx)(t.em,{children:"qubit mapping"}),".  Learn more about these stages in the ",(0,n.jsx)(t.a,{href:"transpiler-stages",children:"Transpiler stages"})," topic."]})}),"\n",(0,n.jsxs)(t.p,{children:["Pass the ",(0,n.jsx)(t.code,{children:"coupling_map"})," keyword argument to see its effect on the transpiler:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'coupling_map = target.build_coupling_map()\n\npass_manager = generate_preset_pass_manager(\n    optimization_level=0, coupling_map=coupling_map, seed_transpiler=12345\n)\nqc_t_cm_lv0 = pass_manager.run(qc)\nqc_t_cm_lv0.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(97214).A+"",width:"3140",height:"786"})}),"\n",(0,n.jsxs)(t.p,{children:["As shown above, several SWAP gates were inserted (each consisting of three CX gates), which will cause a lot of errors on current devices. To see which qubits are selected on the actual qubit topology, use ",(0,n.jsx)(t.code,{children:"plot_circuit_layout"})," from Qiskit Visualizations:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from qiskit.visualization import plot_circuit_layout\n\nplot_circuit_layout(qc_t_cm_lv0, backend, view="physical")\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(86965).A+"",width:"1199",height:"1036"})}),"\n",(0,n.jsxs)(t.p,{children:["This shows that our virtual qubits 0-11 were trivially mapped to the line of physical qubits 0-11. Let's return to the default (",(0,n.jsx)(t.code,{children:"optimization_level=1"}),"), which uses ",(0,n.jsx)(t.code,{children:"VF2Layout"})," if any routing is required."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'pass_manager = generate_preset_pass_manager(\n    optimization_level=1, coupling_map=coupling_map, seed_transpiler=12345\n)\nqc_t_cm_lv1 = pass_manager.run(qc)\nqc_t_cm_lv1.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(29597).A+"",width:"2084",height:"847"})}),"\n",(0,n.jsxs)(t.p,{children:["Now there are no SWAP gates inserted and the physical qubits selected are the same when using the ",(0,n.jsx)(t.code,{children:"target"})," class."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from qiskit.visualization import plot_circuit_layout\n\nplot_circuit_layout(qc_t_cm_lv1, backend, view="physical")\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(3399).A+"",width:"1199",height:"1036"})}),"\n",(0,n.jsx)(t.p,{children:"Now the layout is in a ring.  Because this layout respects the circuit's connectivity, there are no SWAP gates, providing a much better circuit for execution."}),"\n",(0,n.jsx)(t.h2,{id:"basis-gates",children:"Basis gates"}),"\n",(0,n.jsxs)(t.p,{children:["Every quantum computer supports a limited instruction set, called its ",(0,n.jsx)(t.em,{children:"basis gates"}),".  Every gate in the circuit must be translated to the elements of this set. This set should consist of single- and two-qubit gates that provide a universal gates set, meaning that any quantum operation can be decomposed into those gates.  This is done by the ",(0,n.jsx)(t.a,{href:"../api/qiskit/qiskit.transpiler.passes.BasisTranslator",children:"BasisTranslator"}),", and the basis gates can be specified as a keyword argument to the transpiler to provide this information."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"basis_gates = list(target.operation_names)\nprint(basis_gates)\n"})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-text",children:"['sx', 'switch_case', 'x', 'if_else', 'measure', 'for_loop', 'delay', 'ecr', 'id', 'reset', 'rz']\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The default single-qubit gates on ",(0,n.jsx)(t.em,{children:"ibm_sherbrooke"})," are ",(0,n.jsx)(t.code,{children:"rz"}),", ",(0,n.jsx)(t.code,{children:"x"}),", and ",(0,n.jsx)(t.code,{children:"sx"}),", and the default two-qubit gate is ",(0,n.jsx)(t.code,{children:"ecr"})," (echoed cross-resonance). CX gates are constructed from ",(0,n.jsx)(t.code,{children:"ecr"})," gates, so on some QPUs ",(0,n.jsx)(t.code,{children:"ecr"})," is specified as the two-qubit basis gate, while on others ",(0,n.jsx)(t.code,{children:"cx"})," is the default. The ",(0,n.jsx)(t.code,{children:"ecr"})," gate is the ",(0,n.jsx)(t.em,{children:"entangling"})," part of the ",(0,n.jsx)(t.code,{children:"cx"})," gate. In addition to the control gates, there are also ",(0,n.jsx)(t.code,{children:"delay"})," and ",(0,n.jsx)(t.code,{children:"measurement"})," instructions."]}),"\n",(0,n.jsx)(i,{type:"note",children:(0,n.jsxs)(t.p,{children:["QPUs have default basis gates, but you can choose whatever gates you want, as long as you provide the instruction or add pulse gates (see ",(0,n.jsx)(t.a,{href:"custom-transpiler-pass",children:"Create transpiler passes."}),") The default basis gates are those that calibrations have been done for on the QPU, so no further instruction/pulse gates need to be provided. For example, on some QPUs ",(0,n.jsx)(t.code,{children:"cx"})," is the default two-qubit gate and ",(0,n.jsx)(t.code,{children:"ecr"})," on others. See the list of possible ",(0,n.jsx)(t.a,{href:"/guides/qpu-information#native-gates",children:"native gates and operations"})," for more details."]})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'pass_manager = generate_preset_pass_manager(\n    optimization_level=1,\n    coupling_map=coupling_map,\n    basis_gates=basis_gates,\n    seed_transpiler=12345,\n)\nqc_t_cm_bg = pass_manager.run(qc)\nqc_t_cm_bg.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(24616).A+"",width:"3079",height:"796"})}),"\n",(0,n.jsxs)(t.p,{children:["Note that the ",(0,n.jsx)(t.code,{children:"CXGate"})," objects have been decomposed to ",(0,n.jsx)(t.code,{children:"ecr"})," gates and single-qubit basis gates."]}),"\n",(0,n.jsx)(t.h2,{id:"device-error-rates",children:"Device error rates"}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.code,{children:"Target"})," class can contain information about the error rates for operations on the device.\nFor example, the following code retrieves the properties for the echoed cross-resonance (ECR) gate between qubit 1 and 0 (note that the ECR gate is directional):"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'target["ecr"][(1, 0)]\n'})}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-text",children:"InstructionProperties(duration=5.333333333333332e-07, error=0.007494257741828603)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The output displays the duration of the gate (in seconds) and its error rate. To reveal error information to the transpiler, build a target model with the ",(0,n.jsx)(t.code,{children:"basis_gates"})," and ",(0,n.jsx)(t.code,{children:"coupling_map"})," from above and populate it with error values from the backend ",(0,n.jsx)(t.code,{children:"FakeSherbrooke"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from qiskit.transpiler import Target\nfrom qiskit.circuit.controlflow import IfElseOp, SwitchCaseOp, ForLoopOp\n\nerr_targ = Target.from_configuration(\n    basis_gates=basis_gates,\n    coupling_map=coupling_map,\n    num_qubits=target.num_qubits,\n    custom_name_mapping={\n        "if_else": IfElseOp,\n        "switch_case": SwitchCaseOp,\n        "for_loop": ForLoopOp,\n    },\n)\n\nfor i, (op, qargs) in enumerate(target.instructions):\n    if op.name in basis_gates:\n        err_targ[op.name][qargs] = target.instruction_properties(i)\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Transpile with our new target ",(0,n.jsx)(t.code,{children:"err_targ"})," as the target:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'pass_manager = generate_preset_pass_manager(\n    optimization_level=1, target=err_targ, seed_transpiler=12345\n)\nqc_t_cm_bg_et = pass_manager.run(qc)\nqc_t_cm_bg_et.draw("mpl", idle_wires=False, fold=-1)\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Output of the previous code cell",src:s(16123).A+"",width:"3079",height:"796"})}),"\n",(0,n.jsxs)(t.p,{children:["Because the target includes error information, the ",(0,n.jsx)(t.code,{children:"VF2PostLayout"})," pass tries to find the optimal qubits to use, resulting in the same circuit that was originally found with the same physical qubits."]}),"\n",(0,n.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,n.jsx)(i,{type:"tip",title:"Recommendations",children:(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Understand ",(0,n.jsx)(t.a,{href:"defaults-and-configuration-options",children:"Transpilation default settings and configuration options."})]}),"\n",(0,n.jsxs)(t.li,{children:["Review the ",(0,n.jsx)(t.a,{href:"common-parameters",children:"Commonly used parameters for transpilation"})," topic."]}),"\n",(0,n.jsxs)(t.li,{children:["Try the ",(0,n.jsx)(t.a,{href:"/guides/circuit-transpilation-settings#compare-transpiler-settings",children:"Compare transpiler settings"})," guide."]}),"\n",(0,n.jsxs)(t.li,{children:["See the ",(0,n.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/transpiler",children:"Transpile API documentation."})]}),"\n"]})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function p(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},3399(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/25d9fac3-abda-4b2d-81b4-351dc0772722-0-f0d71fa5be22e1abcf31f9f7bfdbf356.svg"},24616(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/313e4743-0-927c224cb523085339ee64b7ea271c36.svg"},58067(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/4b81fb9d-d199-45c5-b119-c1f0b973afe9-0-00e4a5d37f7d3bcabbc2756f4af849b7.svg"},29597(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/8035fd05-f7cd-4151-b19a-4968202246e6-0-cdbcc83e094fba52318452c4ab6c6dbe.svg"},49174(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/97f9acc1-ac53-4025-b413-485777932a9b-0-1c4d3a2ba285b40fc6409dfe8fed1463.svg"},86965(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/9be74535-ed36-4d51-afeb-ee53c3f8a046-0-90645aa6c5144035b72cbd85afb43bcc.svg"},97214(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/ec354bee-e06b-42ea-a117-6c1a9308ca73-0-a2a7ed73262f07a612929547e373a0df.svg"},16123(e,t,s){s.d(t,{A:()=>i});const i=s.p+"assets/images/f1e270c4-e2cc-487e-a050-4180bc321b0b-0-9bf647bb9727817a7722f10031d256ca.svg"},28453(e,t,s){s.d(t,{R:()=>r,x:()=>o});var i=s(96540);const n={},a=i.createContext(n);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);