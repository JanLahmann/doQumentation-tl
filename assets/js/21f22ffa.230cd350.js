"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1015],{43457(e,s,n){n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/serverless-manage-resources","title":"Manage Qiskit Serverless compute and data resources","description":"Manage compute and data across your Qiskit pattern with Qiskit Serverless.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/serverless-manage-resources.mdx","sourceDirName":"guides","slug":"/guides/serverless-manage-resources","permalink":"/guides/serverless-manage-resources","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/serverless-manage-resources.mdx","tags":[],"version":"current","frontMatter":{"title":"Manage Qiskit Serverless compute and data resources","sidebar_label":"Manage Qiskit Serverless compute and data resources","description":"Manage compute and data across your Qiskit pattern with Qiskit Serverless.","notebook_path":"docs/guides/serverless-manage-resources.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Run your first Qiskit Serverless workload remotely","permalink":"/guides/serverless-run-first-workload"},"next":{"title":"Port code to Qiskit Serverless","permalink":"/guides/serverless-port-code"}}');var r=n(74848),i=n(28453);const a={title:"Manage Qiskit Serverless compute and data resources",sidebar_label:"Manage Qiskit Serverless compute and data resources",description:"Manage compute and data across your Qiskit pattern with Qiskit Serverless.",notebook_path:"docs/guides/serverless-manage-resources.ipynb"},o=void 0,l={},c=[{value:"Set detailed statuses",id:"set-detailed-statuses",level:2},{value:"Parallel workflows",id:"parallel-workflows",level:2},{value:"Explore different task configurations",id:"explore-different-task-configurations",level:3},{value:"Manage data across your program",id:"manage-data-across-your-program",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Admonition:n,Details:t,OpenInLabBanner:a}=s;return n||p("Admonition",!0),t||p("Details",!0),a||p("OpenInLabBanner",!0),(0,r.jsxs)(r.Fragment,{children:["\n",(0,r.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,r.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,r.jsx)(a,{notebookPath:"docs/guides/serverless-manage-resources.ipynb"}),"\n",(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:(0,r.jsx)("b",{children:"Package versions"})}),(0,r.jsx)(s.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{children:"qiskit[all]~=2.0.0\nqiskit-ibm-runtime~=0.37.0\nqiskit-serverless~=0.22.0\n"})})]}),"\n",(0,r.jsxs)(s.p,{children:["With Qiskit Serverless, you can manage compute and data across your ",(0,r.jsx)(s.a,{href:"/guides/intro-to-patterns",children:"Qiskit pattern"}),", including CPUs, QPUs, and other compute accelerators."]}),"\n",(0,r.jsx)(s.h2,{id:"set-detailed-statuses",children:"Set detailed statuses"}),"\n",(0,r.jsxs)(s.p,{children:["Serverless workloads have several stages across a workflow. By default, the following statuses are viewable with ",(0,r.jsx)(s.code,{children:"job.status()"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"QUEUED"})}),": the workload is queued for classical resources"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"INITIALIZING"})}),": the workload is set up"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"RUNNING"})}),": the workload is currently running on classical resources"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"DONE"})}),": the workload has successfully completed"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"You can also set custom statuses that further describe the specific workflow stage, as follows."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-serverless\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'# This cell is hidden from users, it just creates a new folder\nfrom pathlib import Path\n\nPath("./source_files").mkdir(exist_ok=True)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile ./source_files/status_example.py\n\nfrom qiskit_serverless import update_status, Job\n\n## If your function has a mapping stage, particularly application functions, you can set the status to "RUNNING: MAPPING" as follows:\nupdate_status(Job.MAPPING)\n\n## While handling transpilation, error suppression, and so forth, you can set the status to "RUNNING: OPTIMIZING_FOR_HARDWARE":\nupdate_status(Job.OPTIMIZING_HARDWARE)\n\n## After you submit jobs to Qiskit Runtime, the underlying quantum job will be queued. You can set status to "RUNNING: WAITING_FOR_QPU":\nupdate_status(Job.WAITING_QPU)\n\n## When the Qiskit Runtime job starts running on the QPU, set the following status "RUNNING: EXECUTING_QPU":\nupdate_status(Job.EXECUTING_QPU)\n\n## Once QPU is completed and post-processing has begun, set the status "RUNNING: POST_PROCESSING":\nupdate_status(Job.POST_PROCESSING)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Writing ./source_files/status_example.py\n"})}),"\n",(0,r.jsxs)(s.p,{children:["After successful completion of this workload (with ",(0,r.jsx)(s.code,{children:"save_result()"}),"), this status will be updated to ",(0,r.jsx)(s.code,{children:"DONE"})," automatically."]}),"\n",(0,r.jsx)(s.h2,{id:"parallel-workflows",children:"Parallel workflows"}),"\n",(0,r.jsxs)(s.p,{children:["For classical tasks that can be parallelized, use the ",(0,r.jsx)(s.code,{children:"@distribute_task"})," decorator to define compute requirements needed to perform a task. Start by recalling the ",(0,r.jsx)(s.code,{children:"transpile_remote.py"})," example from the ",(0,r.jsx)(s.a,{href:"./serverless-first-program",children:"Write your first Qiskit Serverless program"})," topic with the following code."]}),"\n",(0,r.jsxs)(s.p,{children:["The following code requires that you have already ",(0,r.jsx)(s.a,{href:"/guides/cloud-setup",children:"saved your credentials"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile ./source_files/transpile_remote.py\n\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_serverless import distribute_task\n\nservice = QiskitRuntimeService()\n\n@distribute_task(target={"cpu": 1})\ndef transpile_remote(circuit, optimization_level, backend):\n    """Transpiles an abstract circuit (or list of circuits) into an ISA circuit for a given backend."""\n    pass_manager = generate_preset_pass_manager(\n        optimization_level=optimization_level,\n        backend=service.backend(backend)\n    )\n    isa_circuit = pass_manager.run(circuit)\n    return isa_circuit\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Writing ./source_files/transpile_remote.py\n"})}),"\n",(0,r.jsxs)(s.p,{children:["In this example, you decorated the ",(0,r.jsx)(s.code,{children:"transpile_remote()"})," function with ",(0,r.jsx)(s.code,{children:'@distribute_task(target={"cpu": 1})'}),". When run, this creates an asynchronous parallel worker task with a single CPU core, and returns with a reference to track the worker. To fetch the result, pass the reference to the ",(0,r.jsx)(s.code,{children:"get()"})," function. We can use this to run multiple parallel tasks:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile --append ./source_files/transpile_remote.py\n\nfrom time import time\nfrom qiskit_serverless import get, get_arguments, save_result, update_status, Job\n\n# Get arguments\narguments = get_arguments()\ncircuit = arguments.get("circuit")\noptimization_level = arguments.get("optimization_level")\nbackend = arguments.get("backend")\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Appending to ./source_files/transpile_remote.py\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile --append ./source_files/transpile_remote.py\n# Start distributed transpilation\n\nupdate_status(Job.OPTIMIZING_HARDWARE)\n\nstart_time = time()\ntranspile_worker_references = [\n    transpile_remote(circuit, optimization_level, backend)\n    for circuit in arguments.get("circuit_list")\n]\n\ntranspiled_circuits = get(transpile_worker_references)\nend_time = time()\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Appending to ./source_files/transpile_remote.py\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile --append ./source_files/transpile_remote.py\n# Save result, with metadata\n\nresult = {\n    "circuits": transpiled_circuits,\n    "metadata": {\n        "resource_usage": {\n            "RUNNING: OPTIMIZING_FOR_HARDWARE": {\n                "CPU_TIME": end_time - start_time,\n                "QPU_TIME": 0,\n            },\n        }\n    },\n}\n\nsave_result(result)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Appending to ./source_files/transpile_remote.py\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'# This cell is hidden from users.\n# It uploads the serverless program and checks it runs.\n\ndef test_serverless_job(title, entrypoint):\n    # Import in function to stop them interfering with user-facing code\n    from qiskit.circuit.random import random_circuit\n    from qiskit_serverless import IBMServerlessClient, QiskitFunction\n    import time\n    import uuid\n\n    title += "_" + uuid.uuid4().hex[:8]\n    serverless = IBMServerlessClient()\n    transpile_remote_demo = QiskitFunction(\n        title=title,\n        entrypoint=entrypoint,\n        working_dir="./source_files/",\n    )\n    serverless.upload(transpile_remote_demo)\n    job = serverless.get(title).run(\n        circuit=random_circuit(3, 3),\n        circuit_list=[random_circuit(3, 3) for _ in range(3)],\n        backend="ibm_torino",\n        optimization_level=1,\n    )\n    for retry in range(25):\n        time.sleep(5)\n        status = job.status()\n        if status == "DONE":\n            print("Job completed successfully")\n            return\n        if status not in [\n            "QUEUED",\n            "INITIALIZING",\n            "RUNNING",\n            "RUNNING: OPTIMIZING_FOR_HARDWARE",\n            "DONE",\n        ]:\n            raise Exception(\n                f"Unexpected job status \'{status}\'.\\nHere\'s the logs:\\n"\n                + job.logs()\n            )\n        print(f"Waiting for job (status \'{status}\')")\n    raise Exception("Job did not complete in time")\n\ntest_serverless_job(\n    title="transpile_remote_serverless_test", entrypoint="transpile_remote.py"\n)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING: OPTIMIZING_FOR_HARDWARE')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Job completed successfully\n"})}),"\n",(0,r.jsx)(s.h3,{id:"explore-different-task-configurations",children:"Explore different task configurations"}),"\n",(0,r.jsxs)(s.p,{children:["You can flexibly allocate CPU, GPU, and memory for your tasks via ",(0,r.jsx)(s.code,{children:"@distribute_task()"}),". For Qiskit Serverless on IBM Quantum\xae Platform, each program is equipped with 16 CPU cores and 32 GB RAM, which can be allocated dynamically as needed."]}),"\n",(0,r.jsx)(s.p,{children:"CPU cores can be allocated as full CPU cores, or even fractional allocations, as shown in the following."}),"\n",(0,r.jsxs)(s.p,{children:["Memory is allocated in number of bytes. Recall that there are 1024 bytes in a kilobyte, 1024 kilobytes in a megabyte, and 1024 megabytes in a gigabyte. To allocate 2 GB of memory for your worker, you need to allocate ",(0,r.jsx)(s.code,{children:'"mem": 2 * 1024 * 1024 * 1024'}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'%%writefile --append ./source_files/transpile_remote.py\n\n@distribute_task(target={\n    "cpu": 16,\n    "mem": 2 * 1024 * 1024 * 1024\n})\ndef transpile_remote(circuit, optimization_level, backend):\n    return None\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Appending to ./source_files/transpile_remote.py\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'# This cell is hidden from users.\n# It checks the distributed program works.\ntest_serverless_job(\n    title="transpile_remote_serverless_test", entrypoint="transpile_remote.py"\n)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'QUEUED')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING: OPTIMIZING_FOR_HARDWARE')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING: OPTIMIZING_FOR_HARDWARE')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING: OPTIMIZING_FOR_HARDWARE')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Waiting for job (status 'RUNNING: OPTIMIZING_FOR_HARDWARE')\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"Job completed successfully\n"})}),"\n",(0,r.jsx)(s.h2,{id:"manage-data-across-your-program",children:"Manage data across your program"}),"\n",(0,r.jsxs)(s.p,{children:["Qiskit Serverless allows you to manage files in the ",(0,r.jsx)(s.code,{children:"/data"})," directory across all your programs. This includes several limitations:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Only ",(0,r.jsx)(s.code,{children:"tar"})," and ",(0,r.jsx)(s.code,{children:"h5"})," files are supported today"]}),"\n",(0,r.jsxs)(s.li,{children:["This is only a flat ",(0,r.jsx)(s.code,{children:"/data"})," storage, and cannot have ",(0,r.jsx)(s.code,{children:"/data/folder/"})," subdirectories"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["The following shows how to upload files. Be sure you have authenticated to Qiskit Serverless with your IBM Quantum account (see ",(0,r.jsx)(s.a,{href:"/guides/serverless-first-program#deploy-to-ibm-quantum-platform",children:"Deploy to IBM Quantum Platform"})," for instructions)."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'import tarfile\nfrom qiskit_serverless import IBMServerlessClient\n\n# Create a tar\nfilename = "transpile_demo.tar"\nfile = tarfile.open(filename, "w")\nfile.add("./source_files/transpile_remote.py")\nfile.close()\n\n# Get a reference to a QiskitFunction\nserverless = IBMServerlessClient()\ntranspile_remote_demo = next(\n    program\n    for program in serverless.list()\n    if program.title == "transpile_remote_serverless"\n)\n\n# Upload the tar to Serverless data directory\nserverless.file_upload(file=filename, function=transpile_remote_demo)\n'})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:'\'{"message":"/usr/src/app/media/5e1f442128cdf60018496a04/transpile_demo.tar"}\'\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Next, you can list all the files in your ",(0,r.jsx)(s.code,{children:"data"})," directory. This data is accessible to all programs."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"serverless.files(function=transpile_remote_demo)\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-text",children:"['classifier_name.pkl.tar', 'output.json.tar', 'transpile_demo.tar']\n"})}),"\n",(0,r.jsxs)(s.p,{children:["This can be done from a program by using ",(0,r.jsx)(s.code,{children:"file_download()"})," to download the file to the program environment, and uncompressing the ",(0,r.jsx)(s.code,{children:"tar"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"%%writefile ./source_files/extract_tarfile.py\n\nimport tarfile\nfrom qiskit_serverless import IBMServerlessClient\n\nserverless = IBMServerlessClient(token=\"<YOUR_API_KEY>\") # Use the 44-character API_KEY you created and saved from the IBM Quantum Platform Home dashboard\nfiles = serverless.files()\ndemo_file = files[0]\ndownloaded_tar = serverless.file_download(demo_file)\n\nwith tarfile.open(downloaded_tar, 'r') as tar:\n    tar.extractall()\n"})}),"\n",(0,r.jsxs)(s.p,{children:["At this point, your program can interact with the files, as you would a local experiment. ",(0,r.jsx)(s.code,{children:"file_upload()"})," , ",(0,r.jsx)(s.code,{children:"file_download()"}),", and ",(0,r.jsx)(s.code,{children:"file_delete()"})," can be called from your local experiment, or your uploaded program, for consistent and flexible data management."]}),"\n",(0,r.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,r.jsx)(n,{type:"info",title:"Recommendations",children:(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["See a full example that ",(0,r.jsx)(s.a,{href:"./serverless-port-code",children:"ports existing code to Qiskit Serverless"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["Read a paper in which researchers used Qiskit Serverless and quantum-centric supercomputing to ",(0,r.jsx)(s.a,{href:"https://arxiv.org/abs/2405.05068v1",children:"explore quantum chemistry"}),"."]}),"\n"]})})]})}function u(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}function p(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,s,n){n.d(s,{R:()=>a,x:()=>o});var t=n(96540);const r={},i=t.createContext(r);function a(e){const s=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);