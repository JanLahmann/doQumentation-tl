"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1578],{72138(i,e,t){t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/addons","title":"Qiskit addons","description":"Understand the Qiskit addon tools, which help you build utility-grade quantum workflows.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/addons.mdx","sourceDirName":"guides","slug":"/guides/addons","permalink":"/guides/addons","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/addons.mdx","tags":[],"version":"current","frontMatter":{"title":"Qiskit addons","description":"Understand the Qiskit addon tools, which help you build utility-grade quantum workflows."},"sidebar":"tutorialsSidebar","previous":{"title":"Port code to Qiskit Serverless","permalink":"/guides/serverless-port-code"},"next":{"title":"Qiskit addon utilities","permalink":"/guides/qiskit-addons-utils"}}');var o=t(74848),s=t(28453);const a={title:"Qiskit addons",description:"Understand the Qiskit addon tools, which help you build utility-grade quantum workflows."},r="Qiskit addons",d={},l=[{value:"Addons for mapping",id:"addons-for-mapping",level:2},{value:"Approximate quantum compilation with tensor networks",id:"approximate-quantum-compilation-with-tensor-networks",level:3},{value:"Multi-product formulas",id:"multi-product-formulas",level:3},{value:"Optimization mapper",id:"optimization-mapper",level:3},{value:"Addons for optimizing",id:"addons-for-optimizing",level:2},{value:"Operator backpropagation",id:"operator-backpropagation",level:3},{value:"Circuit cutting",id:"circuit-cutting",level:3},{value:"Addons for post-processing",id:"addons-for-post-processing",level:2},{value:"Sample-based quantum diagonalization",id:"sample-based-quantum-diagonalization",level:3},{value:"SQD for HPC",id:"sqd-for-hpc",level:3},{value:"Addons for error mitigation",id:"addons-for-error-mitigation",level:2},{value:"M3 (mthree)",id:"m3-mthree",level:3},{value:"Shaded lightcones",id:"shaded-lightcones",level:3},{value:"Propagated noise absorption",id:"propagated-noise-absorption",level:3}];function h(i){const e={a:"a",admonition:"admonition",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...i.components};return(0,o.jsxs)(o.Fragment,{children:["\n",(0,o.jsx)(e.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,o.jsx)(e.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n","\n",(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"qiskit-addons",children:"Qiskit addons"})}),"\n",(0,o.jsxs)(e.p,{children:["Qiskit addons are a collection of research capabilities for enabling algorithm discovery at the utility scale. These capabilities build on Qiskit's performant foundation of tools for creating and running quantum algorithms. They are provided as modular software components that can plug into a ",(0,o.jsx)(e.a,{href:"/guides/intro-to-patterns",children:"workflow"})," to scale or design new quantum algorithms."]}),"\n",(0,o.jsx)(e.h2,{id:"addons-for-mapping",children:"Addons for mapping"}),"\n",(0,o.jsx)(e.h3,{id:"approximate-quantum-compilation-with-tensor-networks",children:"Approximate quantum compilation with tensor networks"}),"\n",(0,o.jsx)(e.p,{children:"Approximate quantum compilation with tensor networks (AQC-Tensor) enables the construction of high-fidelity circuits with reduced depth."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-aqc-tensor",children:"GitHub repository."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"/guides/qiskit-addons-aqc",children:"documentation."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the tutorial on using AQC to ",(0,o.jsx)(e.a,{href:"/tutorials/approximate-quantum-compilation-for-time-evolution",children:"improve Trotterized time evolution."})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"multi-product-formulas",children:"Multi-product formulas"}),"\n",(0,o.jsx)(e.p,{children:"Multi-product formulas (MPF) reduce the Trotter error of Hamiltonian dynamics through a weighted combination of several circuit executions."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-mpf",children:"GitHub repository."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-mpf",children:"documentation."})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"optimization-mapper",children:"Optimization mapper"}),"\n",(0,o.jsx)(e.p,{children:"The Optimization Mapper addon contains functionality to model optimization problems by formulating them in abstract models and then converting into representations that a quantum computer can understand."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-opt-mapper/",children:"documentation"})," for how-to guides and API references."]}),"\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/qiskit/qiskit-addon-opt-mapper",children:"GitHub"})," repository."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"addons-for-optimizing",children:"Addons for optimizing"}),"\n",(0,o.jsx)(e.h3,{id:"operator-backpropagation",children:"Operator backpropagation"}),"\n",(0,o.jsx)(e.p,{children:"Operator backpropagation (OBP) reduces circuit depth by trimming operations from the end at the cost of more operator measurements."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-obp",children:"GitHub repository."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"/guides/qiskit-addons-obp",children:"documentation."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the tutorial on using ",(0,o.jsx)(e.a,{href:"/tutorials/operator-back-propagation",children:"OBP to improve expectation values."})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"circuit-cutting",children:"Circuit cutting"}),"\n",(0,o.jsx)(e.p,{children:"Circuit cutting reduces the depth of transpiled circuits by decomposing entangling gates between non-adjacent qubits."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-cutting",children:"GitHub repository."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-cutting",children:"documentation."})]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"addons-for-post-processing",children:"Addons for post-processing"}),"\n",(0,o.jsx)(e.h3,{id:"sample-based-quantum-diagonalization",children:"Sample-based quantum diagonalization"}),"\n",(0,o.jsx)(e.p,{children:"Sample-based quantum diagonalization (SQD) classically post-processes noisy quantum samples to yield more accurate eigenvalue estimations of quantum system Hamiltonians, for example in chemistry applications."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-sqd",children:"GitHub repository."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the ",(0,o.jsx)(e.a,{href:"/guides/qiskit-addons-sqd",children:"documentation."})]}),"\n",(0,o.jsxs)(e.li,{children:["Read the tutorial on ",(0,o.jsx)(e.a,{href:"/tutorials/sample-based-quantum-diagonalization",children:"Sample-based quantum diagonalization of a chemistry Hamiltonian."})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"sqd-for-hpc",children:"SQD for HPC"}),"\n",(0,o.jsx)(e.p,{children:"This addon is an HPC-ready implementation of the SQD addon. It is written in modern C++17 standards and is designed to create a single compiled binary for use with MPI."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-sqd-hpc/",children:"API reference"})," documentation."]}),"\n",(0,o.jsxs)(e.li,{children:["View the ",(0,o.jsx)(e.a,{href:"https://github.com/qiskit/qiskit-addon-sqd-hpc",children:"GitHub"})," repository."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"addons-for-error-mitigation",children:"Addons for error mitigation"}),"\n",(0,o.jsx)(e.h3,{id:"m3-mthree",children:"M3 (mthree)"}),"\n",(0,o.jsx)(e.p,{children:"Matrix-free Measurement Mitigation (M3) is a package for scalable quantum measurement error mitigation that can be computed in parallel."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-mthree/",children:"documentation"})," for how-to guides, tutorials, and API references."]}),"\n",(0,o.jsxs)(e.li,{children:["Visit the package's ",(0,o.jsx)(e.a,{href:"https://github.com/Qiskit/qiskit-addon-mthree",children:"GitHub"})," page."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"shaded-lightcones",children:"Shaded lightcones"}),"\n",(0,o.jsx)(e.p,{children:"The shaded lightcones addon uses Pauli propagation to reduce the number of error terms in a noise model that need to be mitigated, according to the specifics of the target observable. This has the effect of reducing the sampling overhead for probabilistic error cancellation (PEC) workflows."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-slc/",children:"documentation"})," for how-to guides, tutorials, and API references."]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"propagated-noise-absorption",children:"Propagated noise absorption"}),"\n",(0,o.jsx)(e.p,{children:"Propagated noise absorption (PNA) uses Pauli propagation to absorb information from a noise model into a target observable. Measuring this modified observable has the effect of mitigating the noise as represented by the model."}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:["Visit the ",(0,o.jsx)(e.a,{href:"https://qiskit.github.io/qiskit-addon-pna/apidocs/qiskit_addon_pna.html",children:"documentation"})," for how-to guides, tutorials, and API references."]}),"\n"]})]})}function c(i={}){const{wrapper:e}={...(0,s.R)(),...i.components};return e?(0,o.jsx)(e,{...i,children:(0,o.jsx)(h,{...i})}):h(i)}},28453(i,e,t){t.d(e,{R:()=>a,x:()=>r});var n=t(96540);const o={},s=n.createContext(o);function a(i){const e=n.useContext(s);return n.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function r(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:a(i.components),n.createElement(s.Provider,{value:e},i.children)}}}]);