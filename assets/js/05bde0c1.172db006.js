"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[1139],{42730(e,n,i){i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"guides/dynamical-decoupling-pass-manager","title":"Create a pass manager for dynamical decoupling","description":"How to create a pass manager for dynamical decoupling in Qiskit.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/dynamical-decoupling-pass-manager.mdx","sourceDirName":"guides","slug":"/guides/dynamical-decoupling-pass-manager","permalink":"/guides/dynamical-decoupling-pass-manager","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/dynamical-decoupling-pass-manager.mdx","tags":[],"version":"current","frontMatter":{"title":"Create a pass manager for dynamical decoupling","sidebar_label":"Create a pass manager for dynamical decoupling","description":"How to create a pass manager for dynamical decoupling in Qiskit.","notebook_path":"docs/guides/dynamical-decoupling-pass-manager.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Transpile with pass managers","permalink":"/guides/transpile-with-pass-managers"},"next":{"title":"Transpilation defaults and configuration options","permalink":"/guides/defaults-and-configuration-options"}}');var a=i(74848),t=i(28453);const r={title:"Create a pass manager for dynamical decoupling",sidebar_label:"Create a pass manager for dynamical decoupling",description:"How to create a pass manager for dynamical decoupling in Qiskit.",notebook_path:"docs/guides/dynamical-decoupling-pass-manager.ipynb"},c=void 0,o={},d=[{value:"Next steps",id:"next-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components},{Admonition:s,Details:r,OpenInLabBanner:c}=n;return s||u("Admonition",!0),r||u("Details",!0),c||u("OpenInLabBanner",!0),(0,a.jsxs)(a.Fragment,{children:["\n",(0,a.jsx)(n.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,a.jsx)(n.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,a.jsx)(c,{notebookPath:"docs/guides/dynamical-decoupling-pass-manager.ipynb"}),"\n","\n",(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:(0,a.jsx)("b",{children:"Package versions"})}),(0,a.jsx)(n.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\n"})})]}),"\n",(0,a.jsxs)(n.p,{children:["This page demonstrates how to use the ",(0,a.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.PadDynamicalDecoupling",children:(0,a.jsx)(n.code,{children:"PadDynamicalDecoupling"})})," pass to add an error suppression technique called ",(0,a.jsx)(n.em,{children:"dynamical decoupling"})," to the circuit."]}),"\n",(0,a.jsxs)(n.p,{children:["Dynamical decoupling works by adding pulse sequences (known as ",(0,a.jsx)(n.em,{children:"dynamical decoupling sequences"}),") to idle qubits to flip them around the Bloch sphere, which cancels the effect of noise channels, thereby suppressing decoherence. These pulse sequences are similar to refocusing pulses used in nuclear magnetic resonance. For a full description, see ",(0,a.jsx)(n.a,{href:"https://arxiv.org/abs/1904.06560",children:"A Quantum Engineer's Guide to Superconducting Qubits"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Because the ",(0,a.jsx)(n.code,{children:"PadDynamicalDecoupling"})," pass only operates on scheduled circuits and involves gates that are not necessarily basis gates of our target, you will need the ",(0,a.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.ALAPScheduleAnalysis",children:(0,a.jsx)(n.code,{children:"ALAPScheduleAnalysis"})})," and ",(0,a.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.transpiler.passes.BasisTranslator",children:(0,a.jsx)(n.code,{children:"BasisTranslator"})})," passes as well."]}),"\n",(0,a.jsxs)(n.p,{children:["This example uses ",(0,a.jsx)(n.code,{children:"ibm_fez"}),", which was initialized previously. Get the ",(0,a.jsx)(n.code,{children:"target"})," information from the ",(0,a.jsx)(n.code,{children:"backend"})," and save the operation names as ",(0,a.jsx)(n.code,{children:"basis_gates"})," because the ",(0,a.jsx)(n.code,{children:"target"})," will need to be modified to add timing information for the gates used in dynamical decoupling."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from qiskit_ibm_runtime import QiskitRuntimeService\n\nservice = QiskitRuntimeService()\nbackend = service.backend("ibm_fez")\n\ntarget = backend.target\nbasis_gates = list(target.operation_names)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Create an ",(0,a.jsx)(n.code,{children:"efficient_su2"})," circuit as an example. First, transpile the circuit to the backend because dynamical decoupling pulses need to be added after the circuit has been transpiled and scheduled. Dynamical decoupling often works best when there is a lot of idle time in the quantum circuits - that is, there are qubits that are not being used while others are active. This is the case in this circuit because the two-qubit ",(0,a.jsx)(n.code,{children:"ecr"})," gates are applied sequentially in this ansatz."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit.circuit.library import efficient_su2\n\nqc = efficient_su2(12, entanglement="circular", reps=1)\npm = generate_preset_pass_manager(1, target=target, seed_transpiler=12345)\nqc_t = pm.run(qc)\nqc_t.draw("mpl", fold=-1, idle_wires=False)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Output of the previous code cell",src:i(98683).A+"",width:"3931",height:"796"})}),"\n",(0,a.jsx)(n.p,{children:"A dynamical decoupling sequence is a series of gates that compose to the identity and are spaced regularly in time. For example, start by creating a simple sequence called XY4 consisting of four gates."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from qiskit.circuit.library import XGate, YGate\n\nX = XGate()\nY = YGate()\n\ndd_sequence = [X, Y, X, Y]\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Because of the regular timing of dynamical decoupling sequences, information about the ",(0,a.jsx)(n.code,{children:"YGate"})," must be added to the ",(0,a.jsx)(n.code,{children:"target"})," because it is ",(0,a.jsx)(n.em,{children:"not"})," a basis gate, whereas the ",(0,a.jsx)(n.code,{children:"XGate"})," is. We know ",(0,a.jsx)(n.em,{children:"a priori"})," that the ",(0,a.jsx)(n.code,{children:"YGate"})," has the same duration and error as the ",(0,a.jsx)(n.code,{children:"XGate"}),", however, so we can just retrieve those properties from the ",(0,a.jsx)(n.code,{children:"target"})," and add them back for the ",(0,a.jsx)(n.code,{children:"YGate"})," objects. This is also why the ",(0,a.jsx)(n.code,{children:"basis_gates"})," were saved separately, since we are adding the ",(0,a.jsx)(n.code,{children:"YGate"})," instruction to the ",(0,a.jsx)(n.code,{children:"target"})," although it is not an actual basis gate of ",(0,a.jsx)(n.code,{children:"ibm_fez"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from qiskit.transpiler import InstructionProperties\n\ny_gate_properties = {}\nfor qubit in range(target.num_qubits):\n    y_gate_properties.update(\n        {\n            (qubit,): InstructionProperties(\n                duration=target["x"][(qubit,)].duration,\n                error=target["x"][(qubit,)].error,\n            )\n        }\n    )\n\ntarget.add_instruction(YGate(), y_gate_properties)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Ansatz circuits such as ",(0,a.jsx)(n.code,{children:"efficient_su2"})," are parameterized, so they must have value bound to them before being sent to the backend. Here, assign random parameters."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import numpy as np\n\nrng = np.random.default_rng(1234)\nqc_t.assign_parameters(\n    rng.uniform(-np.pi, np.pi, qc_t.num_parameters), inplace=True\n)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Next, execute the custom passes. Instantiate the ",(0,a.jsx)(n.code,{children:"PassManager"})," with ",(0,a.jsx)(n.code,{children:"ALAPScheduleAnalysis"})," and ",(0,a.jsx)(n.code,{children:"PadDynamicalDecoupling"}),".  Run ",(0,a.jsx)(n.code,{children:"ALAPScheduleAnalysis"})," first to add timing information about the quantum circuit before the regularly-spaced dynamical decoupling sequences can be added. These passes are run on the circuit with ",(0,a.jsx)(n.code,{children:".run()"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from qiskit.transpiler import PassManager\nfrom qiskit.transpiler.passes.scheduling import (\n    ALAPScheduleAnalysis,\n    PadDynamicalDecoupling,\n)\n\ndd_pm = PassManager(\n    [\n        ALAPScheduleAnalysis(target=target),\n        PadDynamicalDecoupling(target=target, dd_sequence=dd_sequence),\n    ]\n)\nqc_dd = dd_pm.run(qc_t)\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Use the visualization tool ",(0,a.jsx)(n.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.visualization.timeline_drawer",children:(0,a.jsx)(n.code,{children:"timeline_drawer"})})," to see the circuit's timing and confirm that a regularly-spaced sequence of ",(0,a.jsx)(n.code,{children:"XGate"})," objects and ",(0,a.jsx)(n.code,{children:"YGate"})," objects appear in the circuit."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"from qiskit.visualization import timeline_drawer\n\ntimeline_drawer(qc_dd, idle_wires=False, target=target)\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Output of the previous code cell",src:i(80613).A+"",width:"1334",height:"988"})}),"\n",(0,a.jsxs)(n.p,{children:["Lastly, because the ",(0,a.jsx)(n.code,{children:"YGate"})," is not an actual basis gate of our backend, manually apply the ",(0,a.jsx)(n.code,{children:"BasisTranslator"})," pass (this is a default pass, but it is executed before scheduling, so it needs to be applied again). The session equivalence library is a library of circuit equivalences that allows the transpiler to decompose circuits into basis gates, as also specified as an argument."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'from qiskit.circuit.equivalence_library import (\n    SessionEquivalenceLibrary as sel,\n)\nfrom qiskit.transpiler.passes import BasisTranslator\n\nqc_dd = BasisTranslator(sel, basis_gates)(qc_dd)\nqc_dd.draw("mpl", fold=-1, idle_wires=False)\n'})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Output of the previous code cell",src:i(6049).A+"",width:"4015",height:"796"})}),"\n",(0,a.jsxs)(n.p,{children:["Now, ",(0,a.jsx)(n.code,{children:"YGate"})," objects are absent from our circuit, and there is explicit timing information in the form of ",(0,a.jsx)(n.code,{children:"Delay"})," gates. This transpiled circuit with dynamical decoupling is now ready to be sent to the backend."]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,a.jsx)(s,{type:"tip",title:"Recommendations",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["To learn how to use the ",(0,a.jsx)(n.code,{children:"generate_preset_passmanager"})," function instead of writing your own passes, start with the ",(0,a.jsx)(n.a,{href:"defaults-and-configuration-options",children:"Transpilation default settings and configuration options"})," topic."]}),"\n",(0,a.jsxs)(n.li,{children:["Try the ",(0,a.jsx)(n.a,{href:"/guides/circuit-transpilation-settings#compare-transpiler-settings",children:"Compare transpiler settings"})," guide."]}),"\n",(0,a.jsxs)(n.li,{children:["See the ",(0,a.jsx)(n.a,{href:"https://docs.quantum-computing.ibm.com/api/qiskit/transpiler",children:"Transpile API documentation."})]}),"\n"]})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}function u(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},98683(e,n,i){i.d(n,{A:()=>s});const s=i.p+"assets/images/8228f889-806a-4873-b1da-27c9795d5f5c-0-8e43cb39bcd61198eb40054c70ad0ea3.svg"},6049(e,n,i){i.d(n,{A:()=>s});const s=i.p+"assets/images/aaa27ee4-1965-41bf-abd2-1d9176af6dc4-0-2314a0371dcafac379051ed41173c679.svg"},80613(e,n,i){i.d(n,{A:()=>s});const s=i.p+"assets/images/cb73e2c4-ab05-4f15-91ae-2fab64028d6e-0-ae44250759313b2ded5fcb1946abf215.svg"},28453(e,n,i){i.d(n,{R:()=>r,x:()=>c});var s=i(96540);const a={},t=s.createContext(a);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);