"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[3475],{26251(e,i,t){t.r(i),t.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/algorithmiq-tem","title":"Tensor-network error mitigation (TEM) - A Qiskit Function by Algorithmiq","description":"Introduction to TEM, a Qiskit Function by Algorithmiq, to compute estimations with software post-processing error mitigation using tensor networks.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/algorithmiq-tem.mdx","sourceDirName":"guides","slug":"/guides/algorithmiq-tem","permalink":"/guides/algorithmiq-tem","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/algorithmiq-tem.mdx","tags":[],"version":"current","frontMatter":{"title":"Tensor-network error mitigation (TEM) - A Qiskit Function by Algorithmiq","sidebar_label":"Tensor-network error mitigation (TEM) - A Qiskit Function by Algorithmiq","description":"Introduction to TEM, a Qiskit Function by Algorithmiq, to compute estimations with software post-processing error mitigation using tensor networks.","notebook_path":"docs/guides/algorithmiq-tem.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"IBM Circuit function","permalink":"/guides/ibm-circuit-function"},"next":{"title":"Performance Management - A Qiskit Function by Q-CTRL Fire Opal","permalink":"/guides/q-ctrl-performance-management"}}');var s=t(74848),r=t(28453);const o={title:"Tensor-network error mitigation (TEM) - A Qiskit Function by Algorithmiq",sidebar_label:"Tensor-network error mitigation (TEM) - A Qiskit Function by Algorithmiq",description:"Introduction to TEM, a Qiskit Function by Algorithmiq, to compute estimations with software post-processing error mitigation using tensor networks.",notebook_path:"docs/guides/algorithmiq-tem.ipynb"},a="Tensor-network error mitigation (TEM): A Qiskit Function by Algorithmiq",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Description",id:"description",level:2},{value:"Get started",id:"get-started",level:2},{value:"Example",id:"example",level:2},{value:"Inputs",id:"inputs",level:2},{value:"Options",id:"options",level:3},{value:"Outputs",id:"outputs",level:2},{value:"Fetching error messages",id:"fetching-error-messages",level:2},{value:"Get support",id:"get-support",level:2},{value:"Next steps",id:"next-steps",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components},{Admonition:n,Details:o,OpenInLabBanner:a}=i;return n||u("Admonition",!0),o||u("Details",!0),a||u("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(a,{notebookPath:"docs/guides/algorithmiq-tem.ipynb"}),"\n","\n",(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"tensor-network-error-mitigation-tem-a-qiskit-function-by-algorithmiq",children:"Tensor-network error mitigation (TEM): A Qiskit Function by Algorithmiq"})}),"\n",(0,s.jsx)(n,{type:"note",title:"Note",children:(0,s.jsx)(i.p,{children:"Qiskit Functions are an experimental feature available only to IBM Quantum\xae Premium Plan, Flex Plan, and On-Prem (via IBM Quantum Platform API) Plan users. They are in preview release status and subject to change."})}),"\n","\n",(0,s.jsxs)(o,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Package versions"})}),(0,s.jsx)(i.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-catalog~=0.11.0\n"})})]}),"\n",(0,s.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(i.p,{children:"Algorithmiq\u2019s Tensor-network Error Mitigation (TEM) method is a hybrid\nquantum-classical algorithm designed for performing noise mitigation entirely at\nthe classical post-processing stage. With TEM, the user can compute the\nexpectation values of observables mitigating the inevitable noise-induced errors\nthat occur on quantum hardware with increased accuracy and cost efficiency,\nmaking it a highly attractive option for quantum researchers and industry\npractitioners alike."}),"\n",(0,s.jsx)(i.p,{children:"The method consists of constructing a tensor network representing the inverse of\nthe global noise channel affecting the state of the quantum processor and then\napplying the map to informationally complete measurement outcomes acquired from\nthe noisy state to obtain unbiased estimators for the observables."}),"\n",(0,s.jsxs)(i.p,{children:["As an advantage, TEM leverages informationally complete measurements to give\naccess to a vast set of mitigated expectation values of observables and has\noptimal sampling overhead on the quantum hardware, as described in Filippov et\nal. (2023), ",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2307.11740",children:"arXiv:2307.11740"}),", and  Filippov\net al. (2024), ",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2403.13542",children:"arXiv:2403.13542"}),". The\nmeasurement overhead refers to the number of additional measurements required to\nperform efficient error mitigation, a critical factor in the feasibility of\nquantum computations. Therefore, TEM has the potential to enable quantum\nadvantage in complex scenarios, such as applications in the fields of quantum\nchaos, many-body physics, Hubbard dynamics, and small molecule chemistry\nsimulations."]}),"\n",(0,s.jsx)(i.p,{children:"The main features and benefits of TEM can be summarized as:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Optimal measurement overhead"}),": TEM is optimal with respect to\n",(0,s.jsx)(i.a,{href:"https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.131.210601",children:"theoretical bounds"}),",\nmeaning that no method can achieve a smaller measurement overhead. In other\nwords, TEM requires the minimum number of additional measurements to perform\nerror mitigation. This in turns means that TEM uses minimal quantum runtime."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Cost-effectiveness"}),": Since TEM handles noise mitigation entirely in the\npost-processing stage, there is no need to add extra circuits to the quantum\ncomputer, which not only makes the computation cheaper but also diminishes the\nrisk of introducing additional errors due to the imperfections of quantum\ndevices."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Estimation of multiple observables"}),": Thanks to informationally-complete\nmeasurements, TEM efficiently estimates multiple observables with the same\nmeasurement data from the quantum computer."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Measurement error mitigation"}),": The TEM Qiskit Function also includes a\n",(0,s.jsx)(i.a,{href:"https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.5.033154",children:"proprietary measurement error mitigation method"}),"\nable to significantly reduce readout errors after a short calibration run."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:"Accuracy"}),": TEM significantly improves the accuracy and reliability of\ndigital quantum simulations, making quantum algorithms more precise and\ndependable."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"description",children:"Description"}),"\n",(0,s.jsx)(i.p,{children:"The TEM function allows you to obtain error-mitigated expectation values for\nmultiple observables on a quantum circuit with minimal sampling overhead. The\ncircuit is measured with an informationally complete positive operator-valued\nmeasure (IC-POVM), and the collected measurement outcomes are processed on a\nclassical computer. This measurement is used to perform the tensor network\nmethods and build a noise-inversion map. The function applies a map that fully\ninverts the whole noisy circuit using tensor networks to represent the noisy\nlayers."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"TEM schematics",src:t(14836).A+"",title:"Error-mitigated estimation of an observable O via post-processing measurement outcomes of the noisy quantum processor. U and N denote an ideal quantum operation and the associated noise map, which can be generally non-local (and extended to grey boxes). D stands for a tensor of operators that are dual to the effects in the IC measurement. The noise mitigation module M is a tensor network that is efficiently contracted from the middle out. The first iteration of the contraction is represented by the dotted purple line, the second one by the dashed line, and the third one by the solid line.",width:"985",height:"562"})}),"\n",(0,s.jsxs)(i.p,{children:["Once the circuits are submitted to the function, they are transpiled and\noptimized to minimize the number of layers with two-qubit gates (the noisier\ngates on quantum devices). The noise affecting the layers is learned through\n",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/noise-learner-noise-learner",children:"Qiskit Runtime"}),"\nusing a sparse Pauli-Lindblad noise model as described in E. van den Berg, Z.\nMinev, A. Kandala, K. Temme, Nat. Phys. (2023).\n",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2201.09866",children:"arXiv:2201.09866"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"The noise model is an accurate description of the noise on the device able to\ncapture subtle features, including qubit cross-talk. However, noise on the\ndevices can fluctuate and drift and the learned noise might not be accurate at\nthe point at which the estimation is done. This might result in inaccurate\nresults."}),"\n",(0,s.jsx)(i.h2,{id:"get-started",children:"Get started"}),"\n",(0,s.jsxs)(i.p,{children:["Authenticate using your ",(0,s.jsx)(i.a,{href:"http://quantum.cloud.ibm.com/",children:"IBM Quantum Platform API key"}),", and select the TEM function as follows. (This snippet assumes you've already ",(0,s.jsx)(i.a,{href:"/guides/functions#install-qiskit-functions-catalog-client",children:"saved your account"})," to your local environment.)"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit_ibm_catalog import QiskitFunctionsCatalog\n\ntem_function_name = "algorithmiq/tem"\n\ncatalog = QiskitFunctionsCatalog(channel="ibm_quantum_platform")\n\n# Load your function\ntem = catalog.load(tem_function_name)\n'})}),"\n",(0,s.jsx)(i.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(i.p,{children:"The following snippet shows an example where TEM is used to compute the expectation values of an observable given a simple quantum circuit."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit import QuantumCircuit\nfrom qiskit.quantum_info import SparsePauliOp\n\n# Create a quantum circuit\nqc = QuantumCircuit(3)\nqc.u(0.4, 0.9, -0.3, 0)\nqc.u(-0.4, 0.2, 1.3, 1)\nqc.u(-1.2, -1.2, 0.3, 2)\nfor _ in range(2):\n    qc.barrier()\n    qc.cx(0, 1)\n    qc.cx(2, 1)\n    qc.barrier()\n    qc.u(0.4, 0.9, -0.3, 0)\n    qc.u(-0.4, 0.2, 1.3, 1)\n    qc.u(-1.2, -1.2, 0.3, 2)\n\n# Define the observables\nobservable = SparsePauliOp("IYX", 1.0)\n\n# Define the execution options\npub = (qc, [observable])\noptions = {"default_precision": 0.02}\n\n# Define backend to use. TEM will choose the least-busy device reported by IBM if not specified\nbackend_name = "ibm_torino"\n\njob = tem.run(pubs=[pub], backend_name=backend_name, options=options)\n'})}),"\n",(0,s.jsx)(i.p,{children:"Use the Qiskit Serverless APIs to check your Qiskit Function workload's status:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"print(job.status())\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:"QUEUED\n"})}),"\n",(0,s.jsx)(i.p,{children:"You can return the results as:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"result = job.result()\nevs = result[0].data.evs\n"})}),"\n",(0,s.jsx)(n,{type:"info",children:(0,s.jsxs)(i.p,{children:["The expected value for the noiseless circuit for the given operator should be around ",(0,s.jsx)(i.code,{children:"0.18409094298943401"}),"."]})}),"\n",(0,s.jsx)(i.h2,{id:"inputs",children:"Inputs"}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.strong,{children:"Parameters"})}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Name"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Required"}),(0,s.jsx)(i.th,{children:"Default"}),(0,s.jsx)(i.th,{children:"Example"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"pubs"})}),(0,s.jsx)(i.td,{children:"Iterable[EstimatorPubLike]"}),(0,s.jsxs)(i.td,{children:["An iterable of PUB-like (primitive unified bloc) objects, such as tuples ",(0,s.jsx)(i.code,{children:"(circuit, observables)"})," or ",(0,s.jsx)(i.code,{children:"(circuit, observables, parameters, precision)"}),". See ",(0,s.jsx)(i.a,{href:"/guides/primitive-input-output#overview-of-pubs",children:"Overview of PUBs"})," for more information. If a non-ISA circuit is passed, it will be transpiled with optimal settings. If an ISA circuit is passed, it will not be transpiled; in this case, the observable must be defined on the whole QPU."]}),(0,s.jsx)(i.td,{children:"Yes"}),(0,s.jsx)(i.td,{children:"N/A"}),(0,s.jsx)(i.td,{children:"(circuit, observables)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"backend_name"})}),(0,s.jsx)(i.td,{children:"str"}),(0,s.jsx)(i.td,{children:"Name of the backend to make the query."}),(0,s.jsx)(i.td,{children:"No"}),(0,s.jsx)(i.td,{children:"If not provided, the least-busy backend will be used."}),(0,s.jsx)(i.td,{children:'"ibm_fez"'})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"options"})}),(0,s.jsx)(i.td,{children:"dict"}),(0,s.jsxs)(i.td,{children:["Input options. See ",(0,s.jsx)(i.code,{children:"Options"})," section for more details."]}),(0,s.jsx)(i.td,{children:"No"}),(0,s.jsxs)(i.td,{children:["See ",(0,s.jsx)(i.code,{children:"Options"})," section for more details."]}),(0,s.jsx)(i.td,{children:'{"max_bond_dimension": 100\\}'})]})]})]}),"\n",(0,s.jsxs)(n,{type:"caution",children:[(0,s.jsx)(i.p,{children:"TEM currently has the following limitations:"}),(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Parametrized circuits are not supported. The parameters argument should be set to ",(0,s.jsx)(i.code,{children:"None"})," if precision is specified. This restriction will be removed in future versions."]}),"\n",(0,s.jsx)(i.li,{children:"Only circuits without loops are supported. This restriction will be removed in future versions."}),"\n",(0,s.jsx)(i.li,{children:"Non-unitary gates, such as reset, measure, and all forms of control flow are not supported. Support for reset will be added in upcoming releases."}),"\n"]})]}),"\n",(0,s.jsx)(i.h3,{id:"options",children:"Options"}),"\n",(0,s.jsx)(i.p,{children:"A dictionary containing the advanced options for the TEM. The dictionary may contain the keys in the following table. If any of the options are not provided, the default value listed in the table will be used. The default values are good for typical use of TEM."}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Name"}),(0,s.jsx)(i.th,{children:"Choices"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Default"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"tem_max_bond_dimension"})}),(0,s.jsx)(i.td,{children:"int"}),(0,s.jsx)(i.td,{children:"The maximum bond dimension to be used for the tensor networks."}),(0,s.jsx)(i.td,{children:"500"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"tem_compression_cutoff"})}),(0,s.jsx)(i.td,{children:"float"}),(0,s.jsx)(i.td,{children:"The cutoff value to be used for the tensor networks."}),(0,s.jsx)(i.td,{children:"1e-16"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"compute_shadows_bias_from_observable"})}),(0,s.jsx)(i.td,{children:"bool"}),(0,s.jsx)(i.td,{children:"A boolean flag indicating whether the bias for the classical shadows measurement protocol should be tailored to the PUB observable or not. If False, the classical shadows protocol (equal probability of measuring Z, X, Y) will be used."}),(0,s.jsx)(i.td,{children:"False"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"shadows_bias"})}),(0,s.jsx)(i.td,{children:"np.ndarray"}),(0,s.jsx)(i.td,{children:"The bias to be used for the randomized classical shadows measurement protocol, a 1d or 2d array of size 3 or shape (num_qubits, 3) respectively. order is ZXY"}),(0,s.jsx)(i.td,{children:"np.array([1 / 3, 1 / 3, 1 / 3])"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"max_execution_time"})}),(0,s.jsxs)(i.td,{children:["int or ",(0,s.jsx)(i.code,{children:"None"})]}),(0,s.jsxs)(i.td,{children:["The maximum execution time on the QPU in seconds. If the runtime exceeds this value, the job will be canceled. If ",(0,s.jsx)(i.code,{children:"None"}),", a default limit set by Qiskit Runtime will apply."]}),(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"None"})})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"num_randomizations"})}),(0,s.jsx)(i.td,{children:"int"}),(0,s.jsx)(i.td,{children:"The number of randomizations to be used for noise learning and gate twirling."}),(0,s.jsx)(i.td,{children:"32"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"max_layers_to_learn"})}),(0,s.jsx)(i.td,{children:"int"}),(0,s.jsx)(i.td,{children:"The maximum number of unique layers to learn."}),(0,s.jsx)(i.td,{children:"4"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"mitigate_readout_error"})}),(0,s.jsx)(i.td,{children:"bool"}),(0,s.jsx)(i.td,{children:"A Boolean flag indicating whether to perform readout error mitigation or not."}),(0,s.jsx)(i.td,{children:"True"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"num_readout_calibration_shots"})}),(0,s.jsx)(i.td,{children:"int"}),(0,s.jsx)(i.td,{children:"The number of shots to be used for readout error mitigation."}),(0,s.jsx)(i.td,{children:"10000"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"default_precision"})}),(0,s.jsx)(i.td,{children:"float"}),(0,s.jsx)(i.td,{children:"The default precision to be used for the PUBs for which the precision is not specified."}),(0,s.jsx)(i.td,{children:"0.02"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"seed"})}),(0,s.jsxs)(i.td,{children:["int or ",(0,s.jsx)(i.code,{children:"None"})]}),(0,s.jsxs)(i.td,{children:["Set the seed of the random number generator for reproducibility. If ",(0,s.jsx)(i.code,{children:"None"}),", don't set the seed."]}),(0,s.jsx)(i.td,{children:"None"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"outputs",children:"Outputs"}),"\n",(0,s.jsxs)(i.p,{children:["A Qiskit ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.PrimitiveResult",children:"PrimitiveResults"})," containing the TEM-mitigated result. The result for each PUB is returned as a ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.PubResult",children:"PubResult"})," containing the following fields:"]}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Name"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"data"}),(0,s.jsx)(i.td,{children:"DataBin"}),(0,s.jsxs)(i.td,{children:["A Qiskit ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/qiskit.primitives.DataBin",children:"DataBin"})," containing the TEM mitigated observable and its standard error. The DataBin has the following fields: ",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:"evs"}),": The TEM-mitigated observable value."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:"stds"}),": The standard error of the TEM-mitigated observable."]})]})]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"metadata"}),(0,s.jsx)(i.td,{children:"dict"}),(0,s.jsxs)(i.td,{children:["A dictionary containing additional results. The dictionary contains the following keys: ",(0,s.jsxs)("ul",{children:[(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"evs_non_mitigated"'}),": The observable value without error mitigation."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"stds_non_mitigated"'}),": The standard error of the result without error mitigation."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"evs_mitigated_no_readout_mitigation"'}),": The observable value with error mitigation but without readout error mitigation."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"stds_mitigated_no_readout_mitigation"'}),": The standard error of the result with error mitigation but without readout error mitigation."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"evs_non_mitigated_with_readout_mitigation"'}),": The observable value without error mitigation but with readout error mitigation."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)(i.code,{children:'"stds_non_mitigated_with_readout_mitigation"'}),": The standard error of the result without error mitigation but with readout error mitigation."]})]})]})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"fetching-error-messages",children:"Fetching error messages"}),"\n",(0,s.jsx)(i.p,{children:"If your workload status is ERROR, use job.result() to fetch the error message as follows:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"print(job.result())\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:"PrimitiveResult([PubResult(data=DataBin(evs=np.ndarray(<shape=(1,), dtype=float64>), stds=np.ndarray(<shape=(1,), dtype=float64>)), metadata={'evs_non_mitigated': array([-0.06314623]), 'stds_non_mitigated': array([0.05917147]), 'evs_mitigated_no_readout_mitigation': array([-0.06411205]), 'stds_mitigated_no_readout_mitigation': array([0.05992467]), 'evs_non_mitigated_with_readout_mitigation': array([-0.07028881]), 'stds_non_mitigated_with_readout_mitigation': array([0.06353934])})], metadata={'resource_usage': {'RUNNING: OPTIMIZING_FOR_HARDWARE': {'CPU_TIME': 0.915754}, 'RUNNING: WAITING_FOR_QPU': {'CPU_TIME': 18.804865}, 'RUNNING: POST_PROCESSING': {'CPU_TIME': 10.433445}, 'RUNNING: EXECUTING_QPU': {'QPU_TIME': 159.0}}})\n"})}),"\n",(0,s.jsx)(i.h2,{id:"get-support",children:"Get support"}),"\n",(0,s.jsxs)(i.p,{children:["Reach out to ",(0,s.jsx)(i.a,{href:"mailto:qiskit_ibm@algorithmiq.fi",children:"qiskit_ibm@algorithmiq.fi"})]}),"\n",(0,s.jsx)(i.p,{children:"Be sure to include the following information:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Qiskit Function Job ID (",(0,s.jsx)(i.code,{children:"qiskit-ibm-catalog"}),"), ",(0,s.jsx)(i.code,{children:"job.job_id"})]}),"\n",(0,s.jsx)(i.li,{children:"A detailed description of the issue"}),"\n",(0,s.jsx)(i.li,{children:"Any relevant error messages or codes"}),"\n",(0,s.jsx)(i.li,{children:"Steps to reproduce the issue"}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(n,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://quantum.cloud.ibm.com/functions?id=algorithmiq-tem",children:"Request access to Algorithmiq Tensor-network error mitigation"})}),"\n",(0,s.jsxs)(i.li,{children:["Review ",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2307.11740",children:"Filippov, S., et al. (2023). Scalable tensor-network error mitigation for near-term quantum computing. arXiv preprint arXiv:2307.11740."})]}),"\n",(0,s.jsxs)(i.li,{children:["Review ",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2403.13542",children:"Filippov, S., et al. (2024). Scalability of quantum error mitigation techniques: from utility to advantage. arXiv preprint arXiv:2403.13542."})]}),"\n",(0,s.jsxs)(i.li,{children:["Review ",(0,s.jsx)(i.a,{href:"https://arxiv.org/abs/2411.00765",children:"Fischer, E. F., et al. (2024). Dynamical simulations of many-body quantum chaos on a quantum computer. arXiv preprint arXiv:2411.00765."})]}),"\n"]})})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}function u(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},14836(e,i,t){t.d(i,{A:()=>n});const n=t.p+"assets/images/tem_scheme-3b0ce8de48d658c8be50eca1107670ae.svg"},28453(e,i,t){t.d(i,{R:()=>o,x:()=>a});var n=t(96540);const s={},r=n.createContext(s);function o(e){const i=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:i},e.children)}}}]);