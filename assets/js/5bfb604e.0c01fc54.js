"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[6625],{20980(e,i,n){n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"guides/DAG-representation","title":"Work with DAGs in transpiler passes","description":"How to use Directed Acyclic Graphs (DAGs) to analyze and transform quantum circuits in Qiskit transpiler passes","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/DAG-representation.mdx","sourceDirName":"guides","slug":"/guides/DAG-representation","permalink":"/guides/DAG-representation","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/DAG-representation.mdx","tags":[],"version":"current","frontMatter":{"title":"Work with DAGs in transpiler passes","sidebar_label":"Work with DAGs in transpiler passes","description":"How to use Directed Acyclic Graphs (DAGs) to analyze and transform quantum circuits in Qiskit transpiler passes","notebook_path":"docs/guides/DAG-representation.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Create a transpiler plugin","permalink":"/guides/create-transpiler-plugin"},"next":{"title":"Compare transpiler settings","permalink":"/guides/circuit-transpilation-settings"}}');var s=n(74848),a=n(28453);const r={title:"Work with DAGs in transpiler passes",sidebar_label:"Work with DAGs in transpiler passes",description:"How to use Directed Acyclic Graphs (DAGs) to analyze and transform quantum circuits in Qiskit transpiler passes",notebook_path:"docs/guides/DAG-representation.ipynb"},c=void 0,o={},d=[{value:"Build a circuit and examine its DAG",id:"build-a-circuit-and-examine-its-dag",level:2},{value:"Basic DAG operations",id:"basic-dag-operations",level:2},{value:"Get all operation nodes in the DAG",id:"get-all-operation-nodes-in-the-dag",level:2},{value:"Add an operation to the back",id:"add-an-operation-to-the-back",level:2},{value:"Add an Operation to the Front",id:"add-an-operation-to-the-front",level:2},{value:"Substitute a node with a subcircuit",id:"substitute-a-node-with-a-subcircuit",level:2},{value:"Implement a BasicMapper pass",id:"implement-a-basicmapper-pass",level:2},{value:"Next steps",id:"next-steps",level:2}];function l(e){const i={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mrow:"mrow",msub:"msub",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:t,Details:r,OpenInLabBanner:c}=i;return t||u("Admonition",!0),r||u("Details",!0),c||u("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(c,{notebookPath:"docs/guides/DAG-representation.ipynb"}),"\n","\n",(0,s.jsxs)(i.p,{children:['In Qiskit, within the transpilation stages, circuits are represented using a DAG. In general, a DAG is composed of vertices (also known as "nodes") and directed edges that connect pairs of vertices in a particular orientation. This representation is stored using ',(0,s.jsx)(i.code,{children:"qiskit.dagcircuit.DAGCircuit"})," objects that are composed of individual ",(0,s.jsx)(i.code,{children:"DagNode"})," objects. The advantage of this representation over a pure list of gates (that is, a netlist) is that the flow of information between operations is explicit, making it easier to make transformation decisions."]}),"\n",(0,s.jsxs)(i.p,{children:["This guide demonstrates how to work with DAGs and use them to write custom transpiler passes. It will start with building a simple circuit and examining its DAG representation, then explores basic DAG operations and implements a custom ",(0,s.jsx)(i.code,{children:"BasicMapper"})," pass."]}),"\n",(0,s.jsx)(i.h2,{id:"build-a-circuit-and-examine-its-dag",children:"Build a circuit and examine its DAG"}),"\n",(0,s.jsxs)(i.p,{children:["The code snippet below illustrates the DAG by creating a simple circuit that prepares a Bell state and applies an ",(0,s.jsxs)(i.span,{className:"katex",children:[(0,s.jsx)(i.span,{className:"katex-mathml",children:(0,s.jsx)(i.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(i.semantics,{children:[(0,s.jsx)(i.mrow,{children:(0,s.jsxs)(i.msub,{children:[(0,s.jsx)(i.mi,{children:"R"}),(0,s.jsx)(i.mi,{children:"Z"})]})}),(0,s.jsx)(i.annotation,{encoding:"application/x-tex",children:"R_Z"})]})})}),(0,s.jsx)(i.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(i.span,{className:"base",children:[(0,s.jsx)(i.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,s.jsxs)(i.span,{className:"mord",children:[(0,s.jsx)(i.span,{className:"mord mathnormal",style:{marginRight:"0.00773em"},children:"R"}),(0,s.jsx)(i.span,{className:"msupsub",children:(0,s.jsxs)(i.span,{className:"vlist-t vlist-t2",children:[(0,s.jsxs)(i.span,{className:"vlist-r",children:[(0,s.jsx)(i.span,{className:"vlist",style:{height:"0.3283em"},children:(0,s.jsxs)(i.span,{style:{top:"-2.55em",marginLeft:"-0.0077em",marginRight:"0.05em"},children:[(0,s.jsx)(i.span,{className:"pstrut",style:{height:"2.7em"}}),(0,s.jsx)(i.span,{className:"sizing reset-size6 size3 mtight",children:(0,s.jsx)(i.span,{className:"mord mathnormal mtight",style:{marginRight:"0.07153em"},children:"Z"})})]})}),(0,s.jsx)(i.span,{className:"vlist-s",children:"\u200b"})]}),(0,s.jsx)(i.span,{className:"vlist-r",children:(0,s.jsx)(i.span,{className:"vlist",style:{height:"0.15em"},children:(0,s.jsx)(i.span,{})})})]})})]})]})})]})," rotation, depending on the measurement outcome."]}),"\n","\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:(0,s.jsx)("b",{children:"Package versions"})}),(0,s.jsx)(i.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{children:"qiskit[all]~=2.3.0\n"})})]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.converters import circuit_to_dag\nfrom qiskit.visualization import circuit_drawer\nfrom qiskit.visualization.dag_visualization import dag_drawer\n\n# Create circuit\nq = QuantumRegister(3, "q")\nc = ClassicalRegister(3, "c")\ncirc = QuantumCircuit(q, c)\ncirc.h(q[0])\ncirc.cx(q[0], q[1])\ncirc.measure(q[0], c[0])\n\n# Qiskit 2.0 uses if_test instead of c_if\nwith circ.if_test((c, 2)):\n    circ.rz(0.5, q[1])\n\ncircuit_drawer(circ, output="mpl")\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(80415).A+"",width:"417",height:"291"})}),"\n",(0,s.jsxs)(i.p,{children:["In the DAG, there are three kinds of graph nodes: qubit/clbit input nodes (green), operation nodes (blue), and output nodes (red). Each edge indicates data flow (or dependency) between two nodes. Use the qiskit.tools.visualization.dag_drawer() function to view this circuit's DAG. (Install the ",(0,s.jsx)(i.a,{href:"https://graphviz.org/download/",children:"Graphviz library"})," to run this.)"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"# Convert to DAG\ndag = circuit_to_dag(circ)\ndag_drawer(dag)\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(74958).A+"",width:"331",height:"466"})}),"\n",(0,s.jsx)(i.h2,{id:"basic-dag-operations",children:"Basic DAG operations"}),"\n",(0,s.jsx)(i.p,{children:"The code examples below demonstrate common operations with DAGs, including accessing nodes, adding operations, and substituting subcircuits. These operations form the foundation for building transpiler passes."}),"\n",(0,s.jsx)(i.h2,{id:"get-all-operation-nodes-in-the-dag",children:"Get all operation nodes in the DAG"}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.code,{children:"op_nodes()"})," method returns an iterable list of ",(0,s.jsx)(i.code,{children:"DAGOpNode"})," objects in the circuit:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"dag.op_nodes()\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:'[DAGOpNode(op=Instruction(name=\'h\', num_qubits=1, num_clbits=0, params=[]), qargs=(<Qubit register=(3, "q"), index=0>,), cargs=()),\n DAGOpNode(op=Instruction(name=\'cx\', num_qubits=2, num_clbits=0, params=[]), qargs=(<Qubit register=(3, "q"), index=0>, <Qubit register=(3, "q"), index=1>), cargs=()),\n DAGOpNode(op=Instruction(name=\'measure\', num_qubits=1, num_clbits=1, params=[]), qargs=(<Qubit register=(3, "q"), index=0>,), cargs=(<Clbit register=(3, "c"), index=0>,)),\n DAGOpNode(op=Instruction(name=\'if_else\', num_qubits=1, num_clbits=3, params=[<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f912f47db10>, None]), qargs=(<Qubit register=(3, "q"), index=1>,), cargs=(<Clbit register=(3, "c"), index=0>, <Clbit register=(3, "c"), index=1>, <Clbit register=(3, "c"), index=2>))]\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Each node is an instance of the ",(0,s.jsx)(i.code,{children:"DAGOpNode"})," class:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'node = dag.op_nodes()[3]\nprint("node name:", node.name)\nprint("op:", node.op)\nprint("qargs:", node.qargs)\nprint("cargs:", node.cargs)\nprint("condition:", node.op.condition)\n'})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-text",children:'node name: if_else\nop: Instruction(name=\'if_else\', num_qubits=1, num_clbits=3, params=[<qiskit.circuit.quantumcircuit.QuantumCircuit object at 0x7f912f4ceed0>, None])\nqargs: (<Qubit register=(3, "q"), index=1>,)\ncargs: (<Clbit register=(3, "c"), index=0>, <Clbit register=(3, "c"), index=1>, <Clbit register=(3, "c"), index=2>)\ncondition: (ClassicalRegister(3, \'c\'), 2)\n'})}),"\n",(0,s.jsx)(i.h2,{id:"add-an-operation-to-the-back",children:"Add an operation to the back"}),"\n",(0,s.jsxs)(i.p,{children:["An operation is added to the end of the DAGCircuit using the ",(0,s.jsx)(i.code,{children:"apply_operation_back()"})," method. This appends the specified gate to act on the given qubits after all existing operations in the circuit."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit.circuit.library import HGate\n\ndag.apply_operation_back(HGate(), qargs=[q[0]])\ndag_drawer(dag)\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(99737).A+"",width:"388",height:"466"})}),"\n",(0,s.jsx)(i.h2,{id:"add-an-operation-to-the-front",children:"Add an Operation to the Front"}),"\n",(0,s.jsxs)(i.p,{children:["An operation is added to the beginning of the DAGCircuit using the ",(0,s.jsx)(i.code,{children:"apply_operation_front()"})," method. This inserts the specified gate before all existing operations in the circuit, effectively making it the first operation executed."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:"from qiskit.circuit.library import CCXGate\n\ndag.apply_operation_front(CCXGate(), qargs=[q[0], q[1], q[2]])\ndag_drawer(dag)\n"})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(69266).A+"",width:"388",height:"550"})}),"\n",(0,s.jsx)(i.h2,{id:"substitute-a-node-with-a-subcircuit",children:"Substitute a node with a subcircuit"}),"\n",(0,s.jsxs)(i.p,{children:["A node representing a specific operation in the DAGCircuit is replaced with a subcircuit. First, a new sub-DAG is constructed with the desired sequence of gates, then the target node is substituted by this sub-DAG using ",(0,s.jsx)(i.code,{children:"substitute_node_with_dag()"}),", preserving the connections to the rest of the circuit."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit.dagcircuit import DAGCircuit\nfrom qiskit.circuit.library import CHGate, U2Gate, CXGate\n\n# Build sub-DAG\nmini_dag = DAGCircuit()\np = QuantumRegister(2, "p")\nmini_dag.add_qreg(p)\nmini_dag.apply_operation_back(CHGate(), qargs=[p[1], p[0]])\nmini_dag.apply_operation_back(U2Gate(0.1, 0.2), qargs=[p[1]])\n\n# Replace CX with mini_dag\ncx_node = dag.op_nodes(op=CXGate).pop()\ndag.substitute_node_with_dag(cx_node, mini_dag, wires=[p[0], p[1]])\ndag_drawer(dag)\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(13345).A+"",width:"391",height:"550"})}),"\n",(0,s.jsxs)(i.p,{children:["After all transformations are completed, the DAG can be converted back into a regular ",(0,s.jsx)(i.code,{children:"QuantumCircuit"})," object. This is how the transpiler pipeline operates. A circuit is taken, processed in DAG form, and a transformed circuit is produced as output."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit.converters import dag_to_circuit\n\nnew_circ = dag_to_circuit(dag)\ncircuit_drawer(new_circ, output="mpl")\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(85932).A+"",width:"603",height:"291"})}),"\n",(0,s.jsx)(i.h2,{id:"implement-a-basicmapper-pass",children:"Implement a BasicMapper pass"}),"\n",(0,s.jsxs)(i.p,{children:["The DAG structure can be leveraged for writing transpiler passes. In the example below, a ",(0,s.jsx)(i.code,{children:"BasicMapper"})," pass is implemented to map an arbitrary circuit onto a device with restricted qubit connectivity. For additional guidance, refer to the guide on ",(0,s.jsx)(i.a,{href:"/guides/custom-transpiler-pass",children:"writing custom transpiler passes"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["The pass is defined as a ",(0,s.jsx)(i.code,{children:"TransformationPass"}),", meaning that it modifies the circuit. It does so by traversing the DAG layer-by-layer, checking whether each instruction satisfies the constraints imposed by the device's coupling map. If a violation is detected, a swap path is determined and the necessary SWAP gates are inserted accordingly."]}),"\n",(0,s.jsxs)(i.p,{children:["When creating a transpiler pass, the first decision involves selecting whether the pass should inherit from ",(0,s.jsx)(i.code,{children:"TransformationPass"})," or ",(0,s.jsx)(i.code,{children:"AnalysisPass"}),". Transformation passes are designed to modify the circuit, whereas analysis passes are intended only to extract information for use by subsequent passes. The main functionality is then implemented in the ",(0,s.jsx)(i.code,{children:"run(dag)"})," method. Finally, the pass should be registered within the ",(0,s.jsx)(i.code,{children:"qiskit.transpiler.passes"})," module."]}),"\n",(0,s.jsx)(i.p,{children:"In this specific pass, the DAG is traversed layer-by-layer (where each layer contains operations that act on disjoint sets of qubits and can thus be executed independently). For each operation, if the coupling map constraints are not met, a suitable swap path is identified, and the required swaps are inserted to bring the involved qubits into adjacency."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit.transpiler.basepasses import TransformationPass\nfrom qiskit.transpiler import Layout\nfrom qiskit.circuit.library import SwapGate\n\nclass BasicSwap(TransformationPass):\n    def __init__(self, coupling_map, initial_layout=None):\n        super().__init__()\n        self.coupling_map = coupling_map\n        self.initial_layout = initial_layout\n\n    def run(self, dag):\n        new_dag = DAGCircuit()\n        for qreg in dag.qregs.values():\n            new_dag.add_qreg(qreg)\n        for creg in dag.cregs.values():\n            new_dag.add_creg(creg)\n\n        if self.initial_layout is None:\n            self.initial_layout = Layout.generate_trivial_layout(\n                *dag.qregs.values()\n            )\n\n        current_layout = self.initial_layout.copy()\n\n        for layer in dag.serial_layers():\n            subdag = layer["graph"]\n            for gate in subdag.two_qubit_ops():\n                q0, q1 = gate.qargs\n                p0 = current_layout[q0]\n                p1 = current_layout[q1]\n\n                if self.coupling_map.distance(p0, p1) != 1:\n                    path = self.coupling_map.shortest_undirected_path(p0, p1)\n                    for i in range(len(path) - 2):\n                        wire1, wire2 = path[i], path[i + 1]\n                        qubit1 = current_layout[wire1]\n                        qubit2 = current_layout[wire2]\n                        new_dag.apply_operation_back(\n                            SwapGate(), qargs=[qubit1, qubit2]\n                        )\n                        current_layout.swap(wire1, wire2)\n\n            new_dag.compose(\n                subdag, qubits=current_layout.reorder_bits(new_dag.qubits)\n            )\n\n        return new_dag\n'})}),"\n",(0,s.jsx)(i.p,{children:"The pass can now be tested on a small example circuit. A pass manager is constructed with the newly defined pass included. The example circuit is then provided to this pass manager, and a new, transformed circuit is obtained as the output."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-python",children:'from qiskit.transpiler import CouplingMap, PassManager\nfrom qiskit import QuantumRegister, QuantumCircuit\n\nq = QuantumRegister(7, "q")\nin_circ = QuantumCircuit(q)\nin_circ.h(q[0])\nin_circ.cx(q[0], q[4])\nin_circ.cx(q[2], q[3])\nin_circ.cx(q[6], q[1])\nin_circ.cx(q[5], q[0])\nin_circ.rz(0.1, q[2])\nin_circ.cx(q[5], q[0])\n\ncoupling = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\ncoupling_map = CouplingMap(couplinglist=coupling)\n\npm = PassManager()\npm.append(BasicSwap(coupling_map))\n\nout_circ = pm.run(in_circ)\n\nin_circ.draw(output="mpl")\nout_circ.draw(output="mpl")\n'})}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Output of the previous code cell",src:n(75080).A+"",width:"912",height:"477"})}),"\n",(0,s.jsx)(i.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,s.jsx)(t,{type:"tip",title:"Recommendations",children:(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Review the guide on creating a ",(0,s.jsx)(i.a,{href:"./custom-transpiler-pass",children:"custom transpiler pass"})]}),"\n",(0,s.jsxs)(i.li,{children:["Learn how to ",(0,s.jsx)(i.a,{href:"./custom-backend",children:"Create and transpile against custom backends"})]}),"\n",(0,s.jsxs)(i.li,{children:["Try the ",(0,s.jsx)(i.a,{href:"/guides/circuit-transpilation-settings",children:"Compare transpiler settings"})," guide."]}),"\n",(0,s.jsxs)(i.li,{children:["Review the ",(0,s.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit/dagcircuit",children:"DAG Circuit API documentation."})]}),"\n"]})})]})}function p(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}function u(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},80415(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/1d16892a-0-4667135439c638e01e380648198a5e03.svg"},75080(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/2f35375f-0-890673ef303e4f4906336328c56fde8e.svg"},99737(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/3c144b49-0-2c1284d4408213bf353829e06d742eb0.avif"},85932(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/786571f7-0-625cf3634cd3314ba0bd65edc93070dc.svg"},74958(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/e498faa3-0-25117ca485e79be9397824740b0545a2.avif"},69266(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/ed80a69f-0-0d32da55c436dfcc70977d8b1fbc9810.avif"},13345(e,i,n){n.d(i,{A:()=>t});const t=n.p+"assets/images/fdb3dd70-0-f20235347133c8df346a79f4d215ebc3.avif"},28453(e,i,n){n.d(i,{R:()=>r,x:()=>c});var t=n(96540);const s={},a=t.createContext(s);function r(e){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);