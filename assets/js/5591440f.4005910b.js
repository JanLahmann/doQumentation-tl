"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[4053],{96372(e,s,t){t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"guides/qiskit-addons-aqc","title":"Approximate quantum compilation with tensor networks","description":"Overview of the addon for approximate quantum compilation using tensor networks","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/qiskit-addons-aqc.mdx","sourceDirName":"guides","slug":"/guides/qiskit-addons-aqc","permalink":"/guides/qiskit-addons-aqc","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/qiskit-addons-aqc.mdx","tags":[],"version":"current","frontMatter":{"title":"Approximate quantum compilation with tensor networks","description":"Overview of the addon for approximate quantum compilation using tensor networks"},"sidebar":"tutorialsSidebar","previous":{"title":"Getting started with SQD","permalink":"/guides/qiskit-addons-sqd-get-started"},"next":{"title":"Get started with AQC-Tensor","permalink":"/guides/qiskit-addons-aqc-get-started"}}');var i=t(74848),n=t(28453);const r={title:"Approximate quantum compilation with tensor networks",description:"Overview of the addon for approximate quantum compilation using tensor networks"},o="Approximate quantum compilation with tensor networks (AQC-Tensor)",l={},c=[{value:"Install the AQC-Tensor package",id:"install-the-aqc-tensor-package",level:2},{value:"Install from PyPI",id:"install-from-pypi",level:3},{value:"Install from source",id:"install-from-source",level:3},{value:"Theoretical Background",id:"theoretical-background",level:2},{value:"Ansatz generation",id:"ansatz-generation",level:3},{value:"Tensor-network simulation",id:"tensor-network-simulation",level:3},{value:"Next steps",id:"next-steps",level:2},{value:"References",id:"references",level:2}];function h(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",msup:"msup",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,n.R)(),...e.components},{Admonition:a,Details:r}=s;return a||d("Admonition",!0),r||d("Details",!0),(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,i.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"approximate-quantum-compilation-with-tensor-networks-aqc-tensor",children:"Approximate quantum compilation with tensor networks (AQC-Tensor)"})}),"\n",(0,i.jsxs)(s.p,{children:["The Approximate quantum compilation with tensor networks (AQC-Tensor) Qiskit addon enables users to compile the ",(0,i.jsx)(s.em,{children:"initial portion"})," of a circuit into a nearly equivalent approximation of that circuit, but with much fewer layers. This is accomplished using tensor networks using the method described in ",(0,i.jsx)(s.a,{href:"#references",children:"[1]"}),". Its primary utility is in circuits which simulate time evolution, but may be applicable to any class of circuits which has access to:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"A great intermediate state, known as the \u201ctarget state,\u201d that can be achieved by tensor-network simulation; and,"}),"\n",(0,i.jsx)(s.li,{children:"A good circuit that prepares an approximation to the target state, but with fewer layers when compiled to the target hardware device."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The technique generates an ansatz circuit based on a larger target circuit which a user ultimately wants to execute on a QPU. This is accomplished by first simulating some portion of the target circuit by tensor network methods and obtaining an accurate description of an intermediate state which the ansatz circuit will approximate. Once this intermediate state is found, it is used as a cost function in order to optimize the ansatz circuit's parameters. After the optimization is complete, the remaining portion of the target circuit is appended to the ansatz and then executed on quantum hardware."}),"\n",(0,i.jsx)(s.h2,{id:"install-the-aqc-tensor-package",children:"Install the AQC-Tensor package"}),"\n",(0,i.jsxs)(s.p,{children:["There are two ways to install the AQC-Tensor package: PyPI and building from source. It is recommended to install these packages in a ",(0,i.jsx)(s.a,{href:"https://docs.python.org/3.10/tutorial/venv.html",children:"virtual environment"})," to ensure separation between package dependencies."]}),"\n",(0,i.jsx)(s.h3,{id:"install-from-pypi",children:"Install from PyPI"}),"\n",(0,i.jsxs)(s.p,{children:["The most straightforward way to install the AQC-Tensor package is via PyPI. In order to use the package, you must also install at least one tensor network backend. The following code snippet will install the addon, along with ",(0,i.jsx)(s.code,{children:"quimb"})," (for tensor network support) and ",(0,i.jsx)(s.code,{children:"jax"})," (for automatic differentiation). If you are interested, check out the package on ",(0,i.jsx)(s.a,{href:"https://github.com/Qiskit/qiskit-addon-aqc-tensor",children:"GitHub"})]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"pip install 'qiskit-addon-aqc-tensor[quimb-jax]'\n"})}),"\n",(0,i.jsx)(s.h3,{id:"install-from-source",children:"Install from source"}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)(s.p,{children:"Click here to read how to install this package manually."})}),(0,i.jsx)(s.p,{children:"If you wish to contribute to this package or want to install it manually, first clone the repository:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"git clone git clone git@github.com:Qiskit/qiskit-addon-aqc-tensor.git\n"})}),(0,i.jsxs)(s.p,{children:["and install the package via ",(0,i.jsx)(s.code,{children:"pip"}),". If you plan on running the tutorials found in the package repository, install the notebook dependencies as well. If you plan on developing in the repository, you may also want to install the ",(0,i.jsx)(s.code,{children:"dev"})," dependencies."]}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-bash",children:"pip install tox jupyterlab -e '.[notebook-dependencies,dev]'\n"})})]}),"\n",(0,i.jsx)(s.h2,{id:"theoretical-background",children:"Theoretical Background"}),"\n",(0,i.jsxs)(s.p,{children:["The AQC-Tensor procedure is explained in detail in ",(0,i.jsx)(s.a,{href:"#references",children:"[1]"}),". This section provides an overview of the technique."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{alt:"Diagram depicting the approximate quantum compilation procedure",src:t(93812).A+"",width:"2346",height:"1330"})}),"\n",(0,i.jsx)(s.p,{children:"In general, AQC-Tensor requires three things as input:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["A description of the ",(0,i.jsx)(s.strong,{children:"target state"})," in the form of a tensor network. This can be generated by simulating a circuit on a tensor network simulator, or it could be generated in some other way (for example, by performing time evolution on a matrix-product state using the time-dependent variational principle)."]}),"\n",(0,i.jsxs)(s.li,{children:["A parametrized ",(0,i.jsx)(s.strong,{children:"ansatz circuit"}),". Ideally one which contains hardware-efficient connectivity, such that it will have a reasonable depth on the target hardware."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Initial parameters"})," to plug into the ansatz circuit, such that the resulting state is already a ",(0,i.jsx)(s.em,{children:"good"})," approximation of the target state. (This is not, in principle, required for AQC, but it helps to give the optimizer a sensible starting point.)"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"The technique is to then iteratively optimize the parameters of the ansatz circuit, such that the state it generates is as close to the target state as possible."}),"\n",(0,i.jsx)(s.h3,{id:"ansatz-generation",children:"Ansatz generation"}),"\n",(0,i.jsxs)(s.p,{children:["To generate (2) and (3) from the above list, the ",(0,i.jsx)(s.code,{children:"qiskit-addon-aqc"})," package possesses a function, ",(0,i.jsx)(s.code,{children:"generated_ansatz_from_circuit()"})," which will take an input circuit and outputs a parameterized ansatz and initial set of parameters. The parameters returned by the function are such that, when plugged into the ansatz, will generate a state that is exactly equivalent to the input circuit, up to a global phase."]}),"\n",(0,i.jsxs)(s.p,{children:["The ansatz which is generated by this function uses 9 parameters per two-qubit block and is based on the KAK decomposition, which parametrizes any two-qubit gate in terms of three parameters, up to single-qubit rotations. The single-qubit rotations are then decomposed as ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"Z"}),(0,i.jsx)(s.mi,{children:"X"}),(0,i.jsx)(s.mi,{children:"Z"})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"ZXZ"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"ZXZ"})]})})]}),", each of which has three parameters. This results in the ansatz circuit containing 3 parameters for each two-qubit block of the original circuit, plus 3 parameters for an outgoing single-qubit rotation on each of the two qubits (for a total of 9 parameters). After adding these blocks, the ansatz is completed by adding a layer of single-qubit rotations to each active qubit at the start of the circuit."]}),"\n",(0,i.jsx)(s.h3,{id:"tensor-network-simulation",children:"Tensor-network simulation"}),"\n",(0,i.jsx)(s.p,{children:"To obtain a description of the target state which is desired, this addon uses a matrix product state (the simplest form of a tensor network) and supports the following tensor-network simulators:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"MPS simulator found in Qiskit Aer"}),"\n",(0,i.jsxs)(s.li,{children:["Quimb's ",(0,i.jsx)(s.a,{href:"https://quimb.readthedocs.io/en/latest/tensor/tensor-circuit-mps.html",children:"eager"})," ",(0,i.jsx)(s.a,{href:"https://quimb.readthedocs.io/en/latest/autoapi/quimb/tensor/index.html#quimb.tensor.CircuitMPS",children:(0,i.jsx)(s.code,{children:"CircuitMPS"})})," simulator"]}),"\n",(0,i.jsxs)(s.li,{children:["Quimb's ",(0,i.jsx)(s.a,{href:"https://quimb.readthedocs.io/en/latest/tensor/tensor-circuit.html",children:"lazy"})," ",(0,i.jsx)(s.a,{href:"https://quimb.readthedocs.io/en/latest/autoapi/quimb/tensor/index.html#quimb.tensor.Circuit",children:(0,i.jsx)(s.code,{children:"Circuit"})})," simulator"]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["The most important parameter of a tensor network is its maximum bond dimension, ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"\u03c7"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\chi"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"\u03c7"})]})})]}),". This parameter limits how much entanglement can be represented with a tensor network, and thus to what depth a given circuit can be faithfully simulated."]}),"\n",(0,i.jsxs)(s.p,{children:["Given a circuit with ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsx)(s.mrow,{children:(0,i.jsx)(s.mi,{children:"L"})}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"L"})]})})}),(0,i.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"L"})]})})]})," qubits, a matrix-product state needs at most a bond dimension of ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsxs)(s.msub,{children:[(0,i.jsx)(s.mi,{children:"\u03c7"}),(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"e"}),(0,i.jsx)(s.mi,{children:"x"}),(0,i.jsx)(s.mi,{children:"a"}),(0,i.jsx)(s.mi,{children:"c"}),(0,i.jsx)(s.mi,{children:"t"})]})]}),(0,i.jsx)(s.mo,{children:"="}),(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mn,{children:"2"}),(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"L"}),(0,i.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,i.jsx)(s.mn,{children:"2"})]})]})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\chi_{exact} = 2^{L/2}"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord mathnormal",children:"\u03c7"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(s.span,{className:"vlist-r",children:[(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.2806em"},children:(0,i.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(s.span,{className:"mord mtight",children:[(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"e"}),(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"x"}),(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"a"}),(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"c"}),(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"t"})]})})]})}),(0,i.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(s.span,{})})})]})})]}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"="}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.888em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord",children:"2"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.888em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(s.span,{className:"mord mtight",children:[(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"L"}),(0,i.jsx)(s.span,{className:"mord mtight",children:"/2"})]})})]})})})})})]})]})]})]})," in order to exactly simulate the circuit to ",(0,i.jsx)(s.em,{children:"any"})," depth. This is out of reach for general utility-scale circuits acting on 100+ qubits. For this reason, if you are attempting to experiment with this addon for a toy-problem with few qubits, it is important to ensure that ",(0,i.jsxs)(s.span,{className:"katex",children:[(0,i.jsx)(s.span,{className:"katex-mathml",children:(0,i.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(s.semantics,{children:[(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"\u03c7"}),(0,i.jsx)(s.mo,{children:"<"}),(0,i.jsxs)(s.msup,{children:[(0,i.jsx)(s.mn,{children:"2"}),(0,i.jsxs)(s.mrow,{children:[(0,i.jsx)(s.mi,{children:"L"}),(0,i.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,i.jsx)(s.mn,{children:"2"})]})]})]}),(0,i.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\chi < 2^{L/2}"})]})})}),(0,i.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.7335em",verticalAlign:"-0.1944em"}}),(0,i.jsx)(s.span,{className:"mord mathnormal",children:"\u03c7"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.jsx)(s.span,{className:"mrel",children:"<"}),(0,i.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,i.jsxs)(s.span,{className:"base",children:[(0,i.jsx)(s.span,{className:"strut",style:{height:"0.888em"}}),(0,i.jsxs)(s.span,{className:"mord",children:[(0,i.jsx)(s.span,{className:"mord",children:"2"}),(0,i.jsx)(s.span,{className:"msupsub",children:(0,i.jsx)(s.span,{className:"vlist-t",children:(0,i.jsx)(s.span,{className:"vlist-r",children:(0,i.jsx)(s.span,{className:"vlist",style:{height:"0.888em"},children:(0,i.jsxs)(s.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(s.span,{className:"mord mtight",children:[(0,i.jsx)(s.span,{className:"mord mathnormal mtight",children:"L"}),(0,i.jsx)(s.span,{className:"mord mtight",children:"/2"})]})})]})})})})})]})]})]})]}),". This way, when you scale the problem to a larger circuit, the target state remains classically simulable."]}),"\n",(0,i.jsx)(s.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsx)(a,{type:"tip",title:"Recommendations",children:(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Read through the page on ",(0,i.jsx)(s.a,{href:"/guides/qiskit-addons-aqc-get-started",children:"getting started with AQC-Tensor"})]}),"\n",(0,i.jsxs)(s.li,{children:["Read the tutorial on using AQC to ",(0,i.jsx)(s.a,{href:"/tutorials/approximate-quantum-compilation-for-time-evolution",children:"improve Trotterized time evolution."})]}),"\n"]})}),"\n",(0,i.jsx)(s.h2,{id:"references",children:"References"}),"\n",(0,i.jsxs)(s.p,{children:["[1] Robertson, Niall F., et al. ",(0,i.jsx)(s.a,{href:"https://arxiv.org/abs/2301.08609",children:'"Approximate Quantum Compiling for Quantum Simulation: A Tensor Network based approach"'})," arXiv preprint arXiv:2301.08609 (2023)."]})]})}function m(e={}){const{wrapper:s}={...(0,n.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}function d(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},93812(e,s,t){t.d(s,{A:()=>a});const a=t.p+"assets/images/aqc_diagram-4d4e93c792497747a328ccc48b1d550a.avif"},28453(e,s,t){t.d(s,{R:()=>r,x:()=>o});var a=t(96540);const i={},n=a.createContext(i);function r(e){const s=a.useContext(n);return a.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(n.Provider,{value:s},e.children)}}}]);