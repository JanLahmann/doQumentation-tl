"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[2369],{290(e,s,i){i.r(s),i.d(s,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"tutorials/error-mitigation-with-qiskit-functions","title":"Error mitigation with the IBM Circuit function","description":"Walk through an example of building and running a workflow using the IBM Circuit function.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/tutorials/error-mitigation-with-qiskit-functions.mdx","sourceDirName":"tutorials","slug":"/tutorials/error-mitigation-with-qiskit-functions","permalink":"/tutorials/error-mitigation-with-qiskit-functions","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/error-mitigation-with-qiskit-functions.mdx","tags":[],"version":"current","frontMatter":{"title":"Error mitigation with the IBM Circuit function","sidebar_label":"Error mitigation with the IBM Circuit function","description":"Walk through an example of building and running a workflow using the IBM Circuit function.","notebook_path":"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Quantum Portfolio Optimizer - A Qiskit Function by Global Data Quantum","permalink":"/tutorials/global-data-quantum-optimizer"},"next":{"title":"Higher-order binary optimization with Q-CTRL\'s Optimization Solver","permalink":"/tutorials/solve-higher-order-binary-optimization-problems-with-q-ctrls-optimization-solver"}}');var n=i(74848),a=i(28453);const r={title:"Error mitigation with the IBM Circuit function",sidebar_label:"Error mitigation with the IBM Circuit function",description:"Walk through an example of building and running a workflow using the IBM Circuit function.",notebook_path:"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"},l=void 0,c={},o=[{value:"Background",id:"background",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Step 1: Map classical inputs to a quantum problem",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Construct the circuit",id:"construct-the-circuit",level:4},{value:"Construct the observable",id:"construct-the-observable",level:4},{value:"Steps 2 and 3: Optimize problem for quantum hardware execution and execute with the IBM Circuit function",id:"steps-2-and-3-optimize-problem-for-quantum-hardware-execution-and-execute-with-the-ibm-circuit-function",level:2},{value:"Step 4: Post-process and return result in desired classical format",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"Compute the global magnetization",id:"compute-the-global-magnetization",level:4},{value:"Tutorial survey",id:"tutorial-survey",level:2}];function h(e){const s={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h2:"h2",h4:"h4",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mover:"mover",mrow:"mrow",msub:"msub",msubsup:"msubsup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:t,OpenInLabBanner:r}=s;return t||d("Admonition",!0),r||d("OpenInLabBanner",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(r,{notebookPath:"docs/tutorials/error-mitigation-with-qiskit-functions.ipynb"}),"\n",(0,n.jsx)(t,{type:"note",title:"Note",children:(0,n.jsx)(s.p,{children:"Qiskit Functions are an experimental feature available only to IBM Quantum\xae Premium Plan, Flex Plan, and On-Prem (via IBM Quantum Platform API) Plan users. They are in preview release status and subject to change."})}),"\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.em,{children:"Usage estimate: 26 minutes on an Eagle processor (NOTE: This is an estimate only. Your runtime might vary.)"}),"\nThis tutorial walks through an example of building and running a workflow using the IBM Circuit function. This function takes ",(0,n.jsx)(s.a,{href:"/guides/primitive-input-output",children:"Primitive Unified Blocs"})," (PUBs) as inputs and returns error-mitigated expectation values as outputs. It provides an automated and customized pipeline to optimize circuits and execute on quantum hardware so that researchers can focus on algorithm and application discovery."]}),"\n",(0,n.jsxs)(s.p,{children:["Visit the documentation for an ",(0,n.jsx)(s.a,{href:"/guides/functions",children:"introduction to Qiskit Functions"})," and learn how to get started with the ",(0,n.jsx)(s.a,{href:"/guides/ibm-circuit-function",children:"IBM Circuit function"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"background",children:"Background"}),"\n",(0,n.jsxs)(s.p,{children:["This tutorial considers a general hardware-efficient Trotterized time evolution circuit for the 2D transverse-field Ising model and computes the global magnetization. Such a circuit is useful in different application domains such as condensed matter physics, chemistry, and machine learning. For more information on the structure of this model, refer to ",(0,n.jsx)(s.a,{href:"https://www.nature.com/articles/s41586-023-06096-3",children:"Nature 618, 500\u2013505 (2023)"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"The IBM Circuit function combines capabilities from the Qiskit transpiler service and Qiskit Runtime Estimator to provide a simplified interface for running circuits. The function performs transpilation, error suppression, error mitigation, and circuit execution within a single managed service so that we can focus on mapping the problem to circuits rather than building out each step of the pattern ourselves."}),"\n",(0,n.jsx)(s.h2,{id:"requirements",children:"Requirements"}),"\n",(0,n.jsx)(s.p,{children:"Before starting this tutorial, be sure you have the following installed:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Qiskit SDK v1.2 or later (",(0,n.jsx)(s.code,{children:"pip install qiskit"}),")"]}),"\n",(0,n.jsxs)(s.li,{children:["Qiskit Runtime v0.28 or later (",(0,n.jsx)(s.code,{children:"pip install qiskit-ibm-runtime"}),")"]}),"\n",(0,n.jsxs)(s.li,{children:["IBM Qiskit Functions Catalog client v0.0.0 or later (",(0,n.jsx)(s.code,{children:"pip install qiskit-ibm-catalog"}),")"]}),"\n",(0,n.jsxs)(s.li,{children:["Qiskit Aer v0.15.0 or later (",(0,n.jsx)(s.code,{children:"pip install qiskit-aer"}),")"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"setup",children:"Setup"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"import rustworkx\nfrom collections import defaultdict\nfrom numpy import pi, mean\n\nfrom qiskit_ibm_runtime import QiskitRuntimeService\n\nfrom qiskit_ibm_catalog import QiskitFunctionsCatalog\n\nfrom qiskit.circuit import QuantumCircuit, Parameter\nfrom qiskit.quantum_info import SparsePauliOp\n"})}),"\n",(0,n.jsx)(s.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Map classical inputs to a quantum problem"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Parameters to create the quantum circuit"}),(0,n.jsx)("li",{children:"Output: Abstract circuit and observables"})]}),"\n",(0,n.jsx)(s.h4,{id:"construct-the-circuit",children:"Construct the circuit"}),"\n",(0,n.jsx)(s.p,{children:"The circuit we will create is a hardware-efficient, Trotterized time evolution circuit for the 2D transverse-field Ising model. We start with selecting a backend. Properties of this backend (that is, its coupling map) will be used to define the quantum problem and ensure it is hardware-efficient."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"service = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=127\n)\n"})}),"\n",(0,n.jsx)(s.p,{children:"Next, we get the coupling map from the backend."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"coupling_graph = backend.coupling_map.graph.to_undirected(multigraph=False)\nlayer_couplings = defaultdict(list)\n"})}),"\n",(0,n.jsx)(s.p,{children:"We want to be careful in how we design the layers of our circuit. We will do this by coloring the edges of the coupling map (that is, grouping the disjoint edges) and use that coloring to more efficiently place gates in the circuit. This will lead to a shallower circuit with layers of gates that can be executed simultaneously on the hardware."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"edge_coloring = rustworkx.graph_bipartite_edge_color(coupling_graph)\n\nfor edge_idx, color in edge_coloring.items():\n    layer_couplings[color].append(\n        coupling_graph.get_edge_endpoints_by_index(edge_idx)\n    )\nlayer_couplings = [\n    sorted(layer_couplings[i]) for i in sorted(layer_couplings.keys())\n]\n"})}),"\n",(0,n.jsx)(s.p,{children:"Next, we write a simple helper function that implements the hardware-efficient, Trotterized time evolution circuit for the 2D transverse-field Ising model using the edge coloring obtained above."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'def construct_trotter_circuit(\n    num_qubits: int,\n    num_trotter_steps: int,\n    layer_couplings: list,\n    barrier: bool = True,\n) -> QuantumCircuit:\n    theta, phi = Parameter("theta"), Parameter("phi")\n    circuit = QuantumCircuit(num_qubits)\n\n    for _ in range(num_trotter_steps):\n        circuit.rx(theta, range(num_qubits))\n        for layer in layer_couplings:\n            for edge in layer:\n                if edge[0] < num_qubits and edge[1] < num_qubits:\n                    circuit.rzz(phi, edge[0], edge[1])\n        if barrier:\n            circuit.barrier()\n\n    return circuit\n'})}),"\n",(0,n.jsx)(s.p,{children:"We will choose the number of qubits and trotter steps and then construct the circuit."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'num_qubits = 100\nnum_trotter_steps = 2\n\ncircuit = construct_trotter_circuit(\n    num_qubits, num_trotter_steps, layer_couplings\n)\ncircuit.draw("mpl", fold=-1)\n'})}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Output of the previous code cell",src:i(73273).A+"",width:"2959",height:"6483"})}),"\n",(0,n.jsxs)(s.p,{children:["In order to benchmark the quality of the execution, we need to compare it with the ideal outcome. The circuit of choice is beyond brute force classical simulation. So, we fix the parameters of all the ",(0,n.jsx)(s.code,{children:"Rx"})," gates in the circuit to ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mn,{children:"0"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"0"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"})]})})]}),", and that of all ",(0,n.jsx)(s.code,{children:"Rzz"})," gates to ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"\u03c0"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\pi"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"\u03c0"})]})})]}),". This makes the circuit Clifford, which makes it possible to perform the ideal simulation and obtain the ideal outcome for comparison. In this case, we know that outcome will be ",(0,n.jsx)(s.code,{children:"1.0"}),"."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"parameters = [0, pi]\n"})}),"\n",(0,n.jsx)(s.h4,{id:"construct-the-observable",children:"Construct the observable"}),"\n",(0,n.jsxs)(s.p,{children:["First, compute the global magnetization along ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.mover,{accent:"true",children:[(0,n.jsx)(s.mi,{children:"z"}),(0,n.jsx)(s.mo,{children:"^"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\hat{z}"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(s.span,{className:"mord accent",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsxs)(s.span,{className:"vlist",style:{height:"0.6944em"},children:[(0,n.jsxs)(s.span,{style:{top:"-3em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"})]}),(0,n.jsxs)(s.span,{style:{top:"-3em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"accent-body",style:{left:"-0.1944em"},children:(0,n.jsx)(s.span,{className:"mord",children:"^"})})]})]})})})})]})})]})," for the ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"N"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"N"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6833em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]}),"-qubit problem: ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"M"}),(0,n.jsx)(s.mi,{children:"z"})]}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsxs)(s.msubsup,{children:[(0,n.jsx)(s.mo,{children:"\u2211"}),(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"i"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mn,{children:"1"})]}),(0,n.jsx)(s.mi,{children:"N"})]}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e8"}),(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"Z"}),(0,n.jsx)(s.mi,{children:"i"})]}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e9"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"/"}),(0,n.jsx)(s.mi,{children:"N"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"M_z = \\sum_{i=1}^N \\langle Z_i \\rangle / N"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8333em",verticalAlign:"-0.15em"}}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"M"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.1514em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.109em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.04398em"},children:"z"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1.2809em",verticalAlign:"-0.2997em"}}),(0,n.jsxs)(s.span,{className:"mop",children:[(0,n.jsx)(s.span,{className:"mop op-symbol small-op",style:{position:"relative",top:"0em"},children:"\u2211"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsxs)(s.span,{className:"vlist",style:{height:"0.9812em"},children:[(0,n.jsxs)(s.span,{style:{top:"-2.4003em",marginLeft:"0em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsxs)(s.span,{className:"mord mtight",children:[(0,n.jsx)(s.span,{className:"mord mathnormal mtight",children:"i"}),(0,n.jsx)(s.span,{className:"mrel mtight",children:"="}),(0,n.jsx)(s.span,{className:"mord mtight",children:"1"})]})})]}),(0,n.jsxs)(s.span,{style:{top:"-3.2029em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",style:{marginRight:"0.10903em"},children:"N"})})]})]}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.2997em"},children:(0,n.jsx)(s.span,{})})})]})})]}),(0,n.jsx)(s.span,{className:"mopen",children:"\u27e8"}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3117em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]}),(0,n.jsx)(s.span,{className:"mclose",children:"\u27e9"}),(0,n.jsx)(s.span,{className:"mord",children:"/"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})]})]}),". This requires first computing the single-site magnetization ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e8"}),(0,n.jsxs)(s.msub,{children:[(0,n.jsx)(s.mi,{children:"Z"}),(0,n.jsx)(s.mi,{children:"i"})]}),(0,n.jsx)(s.mo,{stretchy:"false",children:"\u27e9"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\langle Z_i \\rangle"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"\u27e8"}),(0,n.jsxs)(s.span,{className:"mord",children:[(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"Z"}),(0,n.jsx)(s.span,{className:"msupsub",children:(0,n.jsxs)(s.span,{className:"vlist-t vlist-t2",children:[(0,n.jsxs)(s.span,{className:"vlist-r",children:[(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.3117em"},children:(0,n.jsxs)(s.span,{style:{top:"-2.55em",marginLeft:"-0.0715em",marginRight:"0.05em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"2.7em"}}),(0,n.jsx)(s.span,{className:"sizing reset-size6 size3 mtight",children:(0,n.jsx)(s.span,{className:"mord mathnormal mtight",children:"i"})})]})}),(0,n.jsx)(s.span,{className:"vlist-s",children:"\u200b"})]}),(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsx)(s.span,{className:"vlist",style:{height:"0.15em"},children:(0,n.jsx)(s.span,{})})})]})})]}),(0,n.jsx)(s.span,{className:"mclose",children:"\u27e9"})]})})]})," for each qubit ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"i"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6595em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"i"})]})})]}),", which is defined in the following code."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'observables = []\nfor i in range(num_qubits):\n    obs = "I" * (i) + "Z" + "I" * (num_qubits - i - 1)\n    observables.append(SparsePauliOp(obs))\n\nprint(observables[0])\n'})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"SparsePauliOp(['ZIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII'],\n              coeffs=[1.+0.j])\n"})}),"\n",(0,n.jsx)(s.h2,{id:"steps-2-and-3-optimize-problem-for-quantum-hardware-execution-and-execute-with-the-ibm-circuit-function",children:"Steps 2 and 3: Optimize problem for quantum hardware execution and execute with the IBM Circuit function"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Abstract circuit and observables"}),(0,n.jsx)("li",{children:"Output: Mitigated expectation values"})]}),"\n",(0,n.jsxs)(s.p,{children:["Now, we can pass the abstract circuit and observables to the IBM Circuit function. It will handle transpilation and execution on quantum hardware for us and return mitigated expectation values. First, we load the function from the ",(0,n.jsx)(s.a,{href:"/guides/functions",children:"IBM Qiskit Functions Catalog"}),"."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'catalog = QiskitFunctionsCatalog(\n    token="<YOUR_API_KEY>"\n)  # Use the 44-character API_KEY you created and saved from the IBM Quantum Platform Home dashboard\nfunction = catalog.load("ibm/circuit-function")\n'})}),"\n",(0,n.jsxs)(s.p,{children:["The IBM Circuit function takes ",(0,n.jsx)(s.code,{children:"pubs"}),", ",(0,n.jsx)(s.code,{children:"backend_name"}),", as well as optional inputs for configuring transpilation, error mitigation, and so on. We create the ",(0,n.jsx)(s.code,{children:"pub"})," from the abstract circuit, observables, and circuit paramters. The name of the backend should be specified as a string."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"pubs = [(circuit, observables, parameters)]\nbackend_name = backend.name\n"})}),"\n",(0,n.jsxs)(s.p,{children:["We can also configure the ",(0,n.jsx)(s.code,{children:"options"})," for transpilation, error suppression, and error mitigation. Default settings will be used if we don't wish to specify these. The IBM Circuit function comes with commonly used options for ",(0,n.jsx)(s.code,{children:"optimization_level"}),", which controls how much circuit optimization to perform, and ",(0,n.jsx)(s.code,{children:"mitigation_level"}),", which specifies how much error suppression and mitigation to apply. Note that the ",(0,n.jsx)(s.code,{children:"mitigation_level"})," of the IBM Circuit function is distinct from the ",(0,n.jsx)(s.code,{children:"resilience_level"})," used in the ",(0,n.jsx)(s.a,{href:"/guides/configure-error-mitigation",children:"Qiskit Runtime Estimator"}),". For a detailed description of these commonly used options as well as other advanced options, visit the ",(0,n.jsx)(s.a,{href:"/guides/ibm-circuit-function",children:"documentation for the IBM Circuit function"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["In this tutorial, we will set the ",(0,n.jsx)(s.code,{children:"default_precision"}),", ",(0,n.jsx)(s.code,{children:"optimization_level: 3"})," and ",(0,n.jsx)(s.code,{children:"mitigation_level: 3"}),", which will turn on gate twirling and Zero Noise Extrapolation (ZNE) via Probabilistic Error Amplification (PEA) on top of the default level 1 settings."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'options = {\n    "default_precision": 0.011,\n    "optimization_level": 3,\n    "mitigation_level": 3,\n}\n'})}),"\n",(0,n.jsx)(s.p,{children:"With the inputs specified, we submit the job to the IBM Circuit function for optimization and execution."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"job = function.run(backend_name=backend_name, pubs=pubs, options=options)\n"})}),"\n",(0,n.jsx)(s.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-process and return result in desired classical format"}),"\n",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Input: Results from the IBM Circuit function"}),(0,n.jsx)("li",{children:"Output: Global magnetization"})]}),"\n",(0,n.jsx)(s.h4,{id:"compute-the-global-magnetization",children:"Compute the global magnetization"}),"\n",(0,n.jsxs)(s.p,{children:["The result from running the function has the same format as the ",(0,n.jsx)(s.a,{href:"/guides/primitive-input-output#estimator-output",children:"Estimator"}),"."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"result = job.result()[0]\n"})}),"\n",(0,n.jsxs)(s.p,{children:["We obtain the mitigated and non-mitigated expectation values from this result. These expectation values represent the single-site magnetization along the ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsxs)(s.mover,{accent:"true",children:[(0,n.jsx)(s.mi,{children:"z"}),(0,n.jsx)(s.mo,{children:"^"})]})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"\\hat{z}"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6944em"}}),(0,n.jsx)(s.span,{className:"mord accent",children:(0,n.jsx)(s.span,{className:"vlist-t",children:(0,n.jsx)(s.span,{className:"vlist-r",children:(0,n.jsxs)(s.span,{className:"vlist",style:{height:"0.6944em"},children:[(0,n.jsxs)(s.span,{style:{top:"-3em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.04398em"},children:"z"})]}),(0,n.jsxs)(s.span,{style:{top:"-3em"},children:[(0,n.jsx)(s.span,{className:"pstrut",style:{height:"3em"}}),(0,n.jsx)(s.span,{className:"accent-body",style:{left:"-0.1944em"},children:(0,n.jsx)(s.span,{className:"mord",children:"^"})})]})]})})})})]})})]})," direction. We average these to arrive at the global magnetization and compare against the ideal value of ",(0,n.jsx)(s.code,{children:"1.0"})," for this problem instance."]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'mitigated_expvals = result.data.evs\nmagnetization_mitigated = mean(mitigated_expvals)\n\nprint("mitigated:", magnetization_mitigated)\n\nunmitigated_expvals = [\n    result.data.evs_extrapolated[i][0][1] for i in range(num_qubits)\n]\nmagnetization_unmitigated = mean(unmitigated_expvals)\n\nprint("unmitigated:", magnetization_unmitigated)\n'})}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-text",children:"mitigated: 0.9749883476088692\nunmitigated: 0.7832977198447583\n"})}),"\n",(0,n.jsx)(s.h2,{id:"tutorial-survey",children:"Tutorial survey"}),"\n",(0,n.jsx)(s.p,{children:"Please take this short survey to provide feedback on this tutorial. Your insights will help us improve our content offerings and user experience."}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_cCNiGkGX5xZMzoG",children:"Link to survey"})})]})}function m(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}function d(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},73273(e,s,i){i.d(s,{A:()=>t});const t=i.p+"assets/images/18eefa99-f1c4-41b5-90b8-7fd8723cac84-0-1ab0aeb23493a71fed970b92e2f80d86.avif"},28453(e,s,i){i.d(s,{R:()=>r,x:()=>l});var t=i(96540);const n={},a=t.createContext(n);function r(e){const s=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);