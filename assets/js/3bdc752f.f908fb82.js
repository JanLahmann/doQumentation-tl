"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5671],{34151(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/c-extension-for-python","title":"Extend Qiskit in Python with C","description":"How to build a C extension for your Qiskit workflow in Python","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/c-extension-for-python.mdx","sourceDirName":"guides","slug":"/guides/c-extension-for-python","permalink":"/guides/c-extension-for-python","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/c-extension-for-python.mdx","tags":[],"version":"current","frontMatter":{"title":"Extend Qiskit in Python with C","description":"How to build a C extension for your Qiskit workflow in Python"},"sidebar":"tutorialsSidebar","previous":{"title":"Install the Qiskit C API","permalink":"/guides/install-c-api"},"next":{"title":"Development workflow","permalink":"/guides/intro-to-patterns"}}');var s=i(74848),o=i(28453);const r={title:"Extend Qiskit in Python with C",description:"How to build a C extension for your Qiskit workflow in Python"},l="Extend Qiskit in Python with C",a={},c=[{value:"Requirements",id:"requirements",level:2},{value:"Define the C extension",id:"define-the-c-extension",level:2},{value:"Build",id:"build",level:2},{value:"Link",id:"link",level:3},{value:"Manual C extension",id:"manual-c-extension",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components},{Admonition:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Admonition",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(n.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(n.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"extend-qiskit-in-python-with-c",children:"Extend Qiskit in Python with C"})}),"\n",(0,s.jsxs)(n.p,{children:["To accelerate your Qiskit Python programs with C, you can use the Qiskit C extension for Python.\nThis requires additional steps to the standalone C usage; for more details, see the ",(0,s.jsx)(n.a,{href:"/guides/install-c-api",children:"Install the Qiskit C API guide"}),"."]}),"\n",(0,s.jsx)(i,{type:"warning",children:(0,s.jsx)(n.p,{children:"The Qiskit C API is still experimental, and has not yet committed to a fully stable programming or\nbinary interface.  Extension modules built against Qiskit are only guaranteed to work against\nthe version of Qiskit used in the build."})}),"\n",(0,s.jsx)(i,{type:"note",children:(0,s.jsx)(n.p,{children:"These instructions have only been tested on UNIX-like systems. Windows instructions are in progress."})}),"\n",(0,s.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsxs)(n.p,{children:["Start by ensuring you have installed the ",(0,s.jsx)(n.a,{href:"/guides/install-c-api",children:"Qiskit C API"}),". Next, install the Qiskit Python interface, as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pip install -r requirements.txt -c constraints.txt\npip install .\n"})}),"\n",(0,s.jsx)(n.h2,{id:"define-the-c-extension",children:"Define the C extension"}),"\n",(0,s.jsxs)(n.p,{children:["There are various options to write a C extension for Python. For simplicity, this guide starts with an approach that uses Python's built-in ",(0,s.jsx)(n.a,{href:"https://docs.python.org/3/library/ctypes.html",children:(0,s.jsx)(n.code,{children:"ctypes"})})," module.  In the next section, the ",(0,s.jsx)(n.a,{href:"#manual-c-extension",children:"the Manual C extension"})," section provides an example of building the C extension using Python's C API to reduce runtime overhead."]}),"\n",(0,s.jsxs)(n.p,{children:["As an example, assume you write a C function to build an observable and would like to return\nit to Python. You can convert a C-side ",(0,s.jsx)(n.code,{children:"QkObs*"})," to a Python-side ",(0,s.jsx)(n.code,{children:"SparseObservable"})," object, using the provided converter\n",(0,s.jsx)(n.code,{children:"qk_obs_to_python"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:"// file: extension.c\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>  // include Python header for access to PyObject\n#define QISKIT_C_PYTHON_INTERFACE  // enable C->Python conversion functions\n#include <qiskit.h>\n\nPyObject *build_observable(void) {\n    QkObs *obs = qk_obs_zero(100);\n    // build the observable ...\n    PyObject *pyobj = qk_obs_to_python(obs); // convert to Qiskit's Python ``SparseObservable``\n    qk_obs_free(obs);\n    return pyobj;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following demonstrates how to compile this into a shared library - for example, ",(0,s.jsx)(n.code,{children:"qiskit_cextension.so"}),".\nOnce this is done, you can call the C program from Python:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# file: main.py\nimport qiskit\nimport ctypes\n\n# Load the extension, ensuring the global interpreter lock (GIL) is acquired for function calls,\n# which you need for the C->Python object conversion.\nlib = ctypes.PyDLL("/path/to/qiskit_cextension.so")\nlib.build_observable.argtypes = None  # set argument types to the function\nlib.build_observable.restype = ctypes.py_object  # set return type\n\n# now you can directly call the function\nobs = lib.build_observable()\nprint("SparseObservable instance?", isinstance(obs, qiskit.quantum_info.SparseObservable))\nprint(obs)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"build",children:"Build"}),"\n",(0,s.jsx)(n.p,{children:"First, you have to build the Qiskit Python extension. This includes the C symbols so you can access both interfaces via the same shared library. This is important to ensure data can be passed\ncorrectly across C and Python."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"python setup.py build_rust --inplace --release\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The shared library is called ",(0,s.jsx)(n.code,{children:"_accelerate.<platform-specific-part>"}),". Find its location and name as follows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'QKLIB=$(python -c "import os; import qiskit; print(os.path.dirname(qiskit._accelerate.__file__))")\nQKNAME=$(python -c "import os; import qiskit; print(os.path.basename(qiskit._accelerate.__file__))")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You will need to know the location of the environments Python includes (",(0,s.jsx)(n.code,{children:"Python.h"}),") and libraries (",(0,s.jsx)(n.code,{children:"libpython.<suffix>"}),").\nThese can, for example, be identified with"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'PYINCLUDE=$(python -c "import sysconfig; print(sysconfig.get_path(\'include\'))")\nPYLIB=$(python -c "import sysconfig; print(sysconfig.get_config_var(\'LIBDIR\'))")\nPYNAME=$(find $PYLIB -maxdepth 1 -name "libpython*" | grep -oE "[^/]+$" | grep -oE "python[0-9]+\\.[0-9]+" || echo "python")\n'})}),"\n",(0,s.jsx)(n.p,{children:"(If you already know these locations and names, you can also just set them directly.)"}),"\n",(0,s.jsx)(n.h3,{id:"link",children:"Link"}),"\n",(0,s.jsxs)(n.p,{children:["Linking can differ among platforms and linkers. The following describes a solution for linkers\nsupporting libraries with arbitrary names, using the ",(0,s.jsx)(n.code,{children:"-l:"})," flag (such as GNU's ",(0,s.jsx)(n.code,{children:"ld"})," linker).\nSee below if your linker requires the library to be called ",(0,s.jsx)(n.code,{children:"lib<something>"})," (such as the ",(0,s.jsx)(n.code,{children:"ldd"}),"\nlinker common on MacOS)."]}),"\n",(0,s.jsxs)(n.p,{children:["You can build the extension specifying the full name of the ",(0,s.jsx)(n.code,{children:"_accelerate"})," library:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"gcc extension.c -fpic -shared -o cextension.so \\\n  -I/path/to/dist/c/include -L$QKLIB -l:$QKNAME \\\n  -I$PYINCLUDE -L$PYLIB -l$PYNAME\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then,  simply enter ",(0,s.jsx)(n.code,{children:"python main.py"})," to run the Python program."]}),"\n",(0,s.jsxs)(n.p,{children:["An alternative to using the exact library name with ",(0,s.jsx)(n.code,{children:"-l:"})," is to symlink the ",(0,s.jsx)(n.code,{children:"_accelerate"})," library\nto the desired name.\nTo include the ",(0,s.jsx)(n.code,{children:"_accelerate"})," shared library, symlink it to the linker's expected format of ",(0,s.jsx)(n.code,{children:"lib<library name>.<suffix>"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ln -s $QKLIB/$QKNAME $QKLIB/libqiskit.<suffix>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["where ",(0,s.jsx)(n.code,{children:"<suffix>"})," is e.g. ",(0,s.jsx)(n.code,{children:"so"})," on Linux or ",(0,s.jsx)(n.code,{children:"dylib"})," on MacOS. This allows to use ",(0,s.jsx)(n.code,{children:"qiskit"})," as library name:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"gcc extension.c -fpic -shared -o qiskit_cextension.so \\\n  -I/path/to/dist/c/include -L$QKLIB -lqiskit \\\n  -I$PYINCLUDE -L$PYLIB -l$PYNAME\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then, simply enter ",(0,s.jsx)(n.code,{children:"python main.py"})," to run the Python program."]}),"\n",(0,s.jsx)(n.h2,{id:"manual-c-extension",children:"Manual C extension"}),"\n",(0,s.jsxs)(n.p,{children:["Instead of using ",(0,s.jsx)(n.code,{children:"ctypes"}),", it is possible to manually build an extension for Python using ",(0,s.jsx)(n.a,{href:"https://docs.python.org/3/c-api/intro.html",children:"Python's\nC API"})," directly. This has the potential to be\nfaster than using ",(0,s.jsx)(n.code,{children:"ctypes"}),", though it requires more effort to implement.\nThe following code is a brief example on how to achieve this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'// file: extension.c\n#define PY_SSIZE_T_CLEAN\n#include <Python.h>\n\n#include <stdio.h>\n#define QISKIT_C_PYTHON_INTERFACE\n#include <qiskit.h>\n\nQkObs *build_observable() {\n    // build a 100-qubit empty observable\n    u_int32_t num_qubits = 100;\n    QkObs *obs = qk_obs_zero(num_qubits);\n\n    // add the term 2 * (X0 Y1 Z2) to the observable\n    complex double coeff = 2;  // the coefficient\n    QkBitTerm bit_terms[3] = {QkBitTerm_X, QkBitTerm_Y, QkBitTerm_Z};  // bit terms: X Y Z\n    uint32_t indices[3] = {0, 1, 2};  // indices: 0 1 2\n    QkObsTerm term = {coeff, 3, bit_terms, indices, num_qubits};\n    qk_obs_add_term(obs, &term);  // append the term\n\n    return obs;\n}\n\n/// Define the Python function, which will internally build the QkObs using the\n/// C function defined above, and then convert the C object to the Python equivalent:\n/// a SparseObservable, handled as PyObject.\nstatic PyObject *cextension_build_observable(PyObject *self, PyObject *args) {\n    // At this point, ``args`` could be parsed for arguments. See PyArg_ParseTuple for details.\n    QkObs *obs = build_observable();  // call the C function to build the observable\n    PyObject *py_obs = qk_obs_to_python(obs);  // convert QkObs to the Python-equivalent\n    return py_obs;\n}\n\n/// Define the module methods.\nstatic PyMethodDef CExtMethods[] = {\n    {"build_observable", cextension_build_observable, METH_VARARGS, "Build an observable."},\n    {NULL, NULL, 0, NULL}, // sentinel\n};\n\n/// Define the module, which here is called ``cextension``.\nstatic struct PyModuleDef cextension = {\n    PyModuleDef_HEAD_INIT,\n    "cextension", // module name\n    NULL,         // docs\n    -1,           // keep the module state in global variables\n    CExtMethods,\n};\n\nPyMODINIT_FUNC PyInit_cextension(void) { return PyModule_Create(&cextension); }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To compile a shared library, link both the Python and Qiskit libraries, as described in\nthe ",(0,s.jsx)(n.a,{href:"#build",children:"Build"})," section above. The Python script then does not need ",(0,s.jsx)(n.code,{children:"ctypes"}),"\nbut can directly import ",(0,s.jsx)(n.code,{children:"cextension"})," module (ensure it is on your Python path):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# file: main.py\nimport qiskit\nimport cextension\n\n# directly call the function\nobs = cextension.build_observable()\nprint("SparseObservable instance?", isinstance(obs, qiskit.quantum_info.SparseObservable))\nprint(obs)\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453(e,n,i){i.d(n,{R:()=>r,x:()=>l});var t=i(96540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);