"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[9680],{53794(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"guides/execution-modes-faq","title":"Execution modes FAQs","description":"Answers to commonly-asked questions about Qiskit Runtime execution modes","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/execution-modes-faq.mdx","sourceDirName":"guides","slug":"/guides/execution-modes-faq","permalink":"/guides/execution-modes-faq","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/execution-modes-faq.mdx","tags":[],"version":"current","frontMatter":{"title":"Execution modes FAQs","description":"Answers to commonly-asked questions about Qiskit Runtime execution modes"},"sidebar":"tutorialsSidebar","previous":{"title":"Execution modes using REST API","permalink":"/guides/execution-modes-rest-api"},"next":{"title":"Monitor or cancel a job","permalink":"/guides/monitor-job"}}');var t=n(74848),o=n(28453);const a={title:"Execution modes FAQs",description:"Answers to commonly-asked questions about Qiskit Runtime execution modes"},r="Qiskit Runtime execution modes FAQs",c={},l=[{value:"Sessions",id:"sessions",level:2},{value:"Batch",id:"batch",level:2}];function h(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Details:n}=s;return n||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:["\n",(0,t.jsx)(s.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,t.jsx)(s.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"qiskit-runtime-execution-modes-faqs",children:"Qiskit Runtime execution modes FAQs"})}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Does Qiskit Runtime local testing mode support different execution modes?"})}),(0,t.jsx)(s.p,{children:"Local testing mode supports the syntax for the different execution modes, but because there is no scheduling involved when testing locally, the modes are ignored."})]}),"\n",(0,t.jsx)("span",{id:"parallel"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"How many jobs can run in parallel for a specific backend?"})}),(0,t.jsx)(s.p,{children:"The number of jobs running in parallel is based on the degree of parallelism configured for the backend, which is five for most backends today."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"How is usage reported for failed or canceled jobs?"})}),(0,t.jsxs)(s.p,{children:["See the ",(0,t.jsx)(s.a,{href:"/guides/estimate-job-run-time#failed-job",children:"Failed and canceled jobs"})," section on the Execution modes page."]})]}),"\n",(0,t.jsx)(s.h2,{id:"sessions",children:"Sessions"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"What happens to my jobs if a session is closed?"})}),(0,t.jsxs)(s.p,{children:["If you are using the ",(0,t.jsx)(s.code,{children:"Session"})," class in ",(0,t.jsx)(s.code,{children:"qiskit-ibm-runtime"}),":"]}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Session.close()"})," means the session no longer accepts new jobs, but existing jobs run to completion."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Session.cancel()"})," cancels all pending session jobs."]}),"\n"]}),(0,t.jsx)(s.p,{children:"If you are using the REST API directly:"}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"PATCH /sessions/{id}"})," with ",(0,t.jsx)(s.code,{children:"accepting_jobs=False"})," means the session no longer accepts new jobs, but existing jobs run to completion."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"DELETE /sessions/{id}/close"})," cancels all pending session jobs."]}),"\n"]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"If I am using session mode and expect my experiment to take many hours, is there a way to ask for calibrations to happen?"})}),(0,t.jsx)(s.p,{children:"No. On-demand calibration is not available."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Is there an interactive timeout (interactive TTL) with session mode?"})}),(0,t.jsx)(s.p,{children:"Yes. This reduces unwanted cost if a user forgets to close their session."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Can I change the interactive TTL or the maximum TTL of a session?"})}),(0,t.jsxs)(s.p,{children:["You cannot change the interactive TTL value. You can change the maximum TTL value of a session (see ",(0,t.jsx)(s.a,{href:"/guides/run-jobs-session#specify-length",children:"Specify the session length"}),"), but it must be less than the system-defined maximum. Ask your administrator to contact IBM support if you need a different interactive TTL or system maximum TTL."]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"How does session usage impact IBM Quantum Network members who are not billed by usage?"})}),(0,t.jsx)(s.p,{children:"IBM Quantum Network members gain reserved capacity on IBM Quantum\xae QPUs. Usage is deducted from this capacity and instances with lower capacity have longer queueing time."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Do I get the same parallelism in session mode that I get with batch mode?"})}),(0,t.jsx)(s.p,{children:"Yes. If you submit multiple jobs simultaneously in a session, these jobs will run in parallel."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Can sessions be interrupted by QPU upgrades or calibrations?"})}),(0,t.jsx)(s.p,{children:"No.  Sessions run in dedicated mode, which means that the user has total access to the backend.  Sessions are never interrupted by calibrations or software upgrades."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Is compilation time counted as usage in session mode?"})}),(0,t.jsxs)(s.p,{children:["Yes.  In session mode, usage is the wall clock time the QPU is ",(0,t.jsx)(s.strong,{children:"committed to the session"}),". It starts when the first session job starts and ends when the session goes inactive, is closed, or when the last job completes, whichever happens ",(0,t.jsx)(s.strong,{children:"last"}),". Thus, usage continues to accumulate after a session ends if the QPU is still running a job. Additionally, time after a job completes while the QPU waits for another session job (the interactive TTL) counts as usage. This is why you should ensure the session is closed as soon as you are done submitting jobs to it."]})]}),"\n",(0,t.jsx)(s.h2,{id:"batch",children:"Batch"}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"How many jobs run in parallel in batch mode?"})}),(0,t.jsx)(s.p,{children:"The number of jobs running in parallel is based on the degree of parallelism configured for the backend, which is five for most backends. However, the number of concurrent jobs in an active batch could be lower because there could be other jobs already running when the batch becomes active."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsxs)(s.p,{children:["How is running ",(0,t.jsx)(s.em,{children:"N"})," PUBs in job mode different from running ",(0,t.jsx)(s.em,{children:"N"})," single-PUB jobs in batch mode?"]})}),(0,t.jsx)(s.p,{children:"The main difference is the time and cost tradeoff:"}),(0,t.jsx)(s.p,{children:"Batch mode:"}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The total run time is less because the classical processing might run in parallel."}),"\n",(0,t.jsx)(s.li,{children:"There is a slight overhead for running each job, so you end up paying a little more for batched jobs. This overhead correlates to the size of the job. For example, the total usage of two jobs, each containing 40 100x100 circuits, is six seconds more than a single job containing 80 circuits."}),"\n",(0,t.jsx)(s.li,{children:"Because batch mode doesn't give you exclusive access to a backend, jobs inside a batch might run with other users' jobs or calibration jobs."}),"\n",(0,t.jsx)(s.li,{children:"If some jobs fail, you still get results from the completed jobs."}),"\n",(0,t.jsx)(s.li,{children:"You can take action in the middle of a batch workload based on the results of completed jobs. For example, you can cancel the rest of the jobs if the initial results look incorrect."}),"\n"]}),(0,t.jsx)(s.p,{children:"Job mode:"}),(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"The total run time is likely to be higher because there is no parallelism."}),"\n",(0,t.jsx)(s.li,{children:"You don't pay for the extra per-job overhead associated with batch workloads."}),"\n",(0,t.jsx)(s.li,{children:"All of your circuits will run together."}),"\n",(0,t.jsx)(s.li,{children:"If this single job fails, you don't get partial results."}),"\n",(0,t.jsx)(s.li,{children:"Your job might hit the limit if it contains too many circuits or if the circuits are too large."}),"\n"]}),(0,t.jsx)(s.p,{children:"In general, if your each of your jobs consumes less than a minute of QPU time, consider combining them into a larger job (this applies to all execution modes)."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"How many jobs I can submit in a batch?"})}),(0,t.jsxs)(s.p,{children:["While there are no limits to the number of jobs you can submit in a batch, there is a maximum time associated with a batch. That is, when a batch's wall clock time (which starts when the first batch job starts running) exceeds the system-defined maximum time, the batch will not accept any new jobs, and any jobs queued but not running are canceled. Additionally, there are limits on how much usage your jobs can consume based on your plan. To determine the maximum time associated with a batch, use the ",(0,t.jsxs)(s.a,{href:"/guides/run-jobs-batch#batch-details",children:[(0,t.jsx)(s.code,{children:"batch.details()"}),"  method"]})," and look for the ",(0,t.jsx)(s.code,{children:"max_time"})," value."]})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"When would my batch mode jobs run in parallel with other users' jobs?"})}),(0,t.jsx)(s.p,{children:"The degree of parallelism configured for a backend is also called \"execution lanes\". If there are one or more execution lanes available, and your batch jobs are next in line to be run, the scheduler starts enough jobs to fill the lanes. Similarly, if your batch doesn't have enough jobs to fill the lanes, the scheduler starts other users' jobs."}),(0,t.jsx)(s.p,{children:"Example: The backend you choose has five execution lanes, and two of them are currently occupied by other users' jobs. Your batch of six jobs is next in line to be run."}),(0,t.jsx)(s.p,{children:"Because there are three available lanes, the scheduler starts three of your six batch jobs. It continues to start jobs in your batch as jobs finish and execution lanes become available. If a lane becomes available and there are no more jobs in your batch, the scheduler starts the next job in line."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Do all of my batch jobs need to wait in the queue?"})}),(0,t.jsx)(s.p,{children:"Because QPUs are limited and shared resources, all jobs need to wait in the queue. However, when the first job in your batch starts running, all the other jobs in that batch essentially jump to the front of the queue and are prioritized by the scheduler."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Does a batch end automatically when the last associated job ends?"})}),(0,t.jsx)(s.p,{children:"Yes. However, there is a slight overhead associated with this auto-detection, so you should always close your batch and session."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Can batches be interrupted by calibrations or software upgrades"})}),(0,t.jsx)(s.p,{children:"Yes.  Batch workloads might be interrupted by calibrations or software upgrades."})]}),"\n",(0,t.jsxs)(n,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)(s.p,{children:"Is compilation time counted as usage in batch mode?"})}),(0,t.jsx)(s.p,{children:"No.  In batch mode, only time spent on the quantum hardware counts as usage."})]})]})}function d(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453(e,s,n){n.d(s,{R:()=>a,x:()=>r});var i=n(96540);const t={},o=i.createContext(t);function a(e){const s=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(o.Provider,{value:s},e.children)}}}]);