"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[7006],{44138(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"tutorials/ai-transpiler-introduction","title":"Qiskit AI-powered transpiler service introduction","description":"In this notebook, we will explore the key benefits of Qiskit AI-powered transpiler service and how it compares to traditional methods.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/tutorials/ai-transpiler-introduction.mdx","sourceDirName":"tutorials","slug":"/tutorials/ai-transpiler-introduction","permalink":"/tutorials/ai-transpiler-introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/tutorials/ai-transpiler-introduction.mdx","tags":[],"version":"current","frontMatter":{"title":"Qiskit AI-powered transpiler service introduction","sidebar_label":"Qiskit AI-powered transpiler service introduction","description":"In this notebook, we will explore the key benefits of Qiskit AI-powered transpiler service and how it compares to traditional methods.","notebook_path":"docs/tutorials/ai-transpiler-introduction.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Introduction to fractional gates","permalink":"/tutorials/fractional-gates"},"next":{"title":"Transpilation optimizations with SABRE","permalink":"/tutorials/transpilation-optimizations-with-sabre"}}');var s=n(74848),a=n(28453);const r={title:"Qiskit AI-powered transpiler service introduction",sidebar_label:"Qiskit AI-powered transpiler service introduction",description:"In this notebook, we will explore the key benefits of Qiskit AI-powered transpiler service and how it compares to traditional methods.",notebook_path:"docs/tutorials/ai-transpiler-introduction.ipynb"},o=void 0,c={},l=[{value:"Background",id:"background",level:2},{value:"Key features of AI passes",id:"key-features-of-ai-passes",level:3},{value:"Why use AI for quantum circuit transpilation?",id:"why-use-ai-for-quantum-circuit-transpilation",level:3},{value:"Brief benchmarking results",id:"brief-benchmarking-results",level:3},{value:"Requirements",id:"requirements",level:2},{value:"Setup",id:"setup",level:2},{value:"Step 1: Map classical inputs to a quantum problem",id:"step-1-map-classical-inputs-to-a-quantum-problem",level:2},{value:"Step 2: Optimize problem for quantum hardware execution",id:"step-2-optimize-problem-for-quantum-hardware-execution",level:2},{value:"Choose a backend",id:"choose-a-backend",level:3},{value:"Create AI and traditional pass managers",id:"create-ai-and-traditional-pass-managers",level:3},{value:"Step 3: Execute using Qiskit primitives",id:"step-3-execute-using-qiskit-primitives",level:2},{value:"Step 4: Post-process and return result in desired classical format",id:"step-4-post-process-and-return-result-in-desired-classical-format",level:2},{value:"When should users choose AI-powered transpilation?",id:"when-should-users-choose-ai-powered-transpilation",level:2},{value:"Step 1: Map classical inputs to a quantum problem",id:"step-1-map-classical-inputs-to-a-quantum-problem-1",level:2},{value:"Step 2: Optimize problem for quantum hardware execution",id:"step-2-optimize-problem-for-quantum-hardware-execution-1",level:2},{value:"Step 3: Execute using Qiskit primitives",id:"step-3-execute-using-qiskit-primitives-1",level:2},{value:"Step 4: Post-process and return result in desired classical format",id:"step-4-post-process-and-return-result-in-desired-classical-format-1",level:2},{value:"Tutorial survey",id:"tutorial-survey",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components},{OpenInLabBanner:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("OpenInLabBanner",!0),(0,s.jsxs)(s.Fragment,{children:["\n",(0,s.jsx)(t.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,s.jsx)(t.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,s.jsx)(i,{notebookPath:"docs/tutorials/ai-transpiler-introduction.ipynb"}),"\n","\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.em,{children:"Estimated QPU usage: None (NOTE: This tutorial does not execute jobs because it is focused on transpilation)"})}),"\n",(0,s.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"Qiskit AI-powered transpiler service (QTS)"})," introduces machine learning-based optimizations in both routing and synthesis passes. These AI modes have been designed to tackle the limitations of traditional transpilation, particularly for large-scale circuits and complex hardware topologies."]}),"\n",(0,s.jsxs)(t.p,{children:["As of ",(0,s.jsx)(t.strong,{children:"July 2025"}),", the ",(0,s.jsx)(t.strong,{children:"Transpiler Service"})," has been migrated to the new IBM Quantum\xae Platform and is no longer available. For the latest updates about the status of the Transpiler Service, please refer to the ",(0,s.jsx)(t.a,{href:"/guides/qiskit-transpiler-service",children:"transpiler service documentation"}),". You can still use the AI transpiler locally, similar to standard Qiskit transpilation. Simply replace ",(0,s.jsx)(t.code,{children:"generate_preset_pass_manager()"})," with ",(0,s.jsx)(t.code,{children:"generate_ai_pass_manager()"}),". This function constructs a pass manager that integrates the AI-powered routing and synthesis passes directly into your local transpilation workflow."]}),"\n",(0,s.jsx)(t.h3,{id:"key-features-of-ai-passes",children:"Key features of AI passes"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Routing passes: AI-powered routing can dynamically adjust qubit paths based on the specific circuit and backend, reducing the need for excessive SWAP gates."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"AIRouting"}),": Layout selection and circuit routing"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Synthesis passes: AI techniques optimize the decomposition of multi-qubit gates, minimizing the number of two-qubit gates, which are typically more error-prone."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"AICliffordSynthesis"}),": Clifford gate synthesis"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"AILinearFunctionSynthesis"}),": Linear function circuit synthesis"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"AIPermutationSynthesis"}),": Permutation circuit synthesis"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"AIPauliNetworkSynthesis"}),": Pauli Network circuit synthesis (only available in the Qiskit Transpiler Service, not in local environment)"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Comparison with traditional transpilation: The standard Qiskit transpiler is a robust tool that can handle a broad spectrum of quantum circuits effectively. However, when circuits grow larger in scale or hardware configurations become more complex, AI passes can deliver additional optimization gains. By using learned models for routing and synthesis, QTS further refines circuit layouts and reduces overhead for challenging or large-scale quantum tasks."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"This tutorial evaluates the AI modes using both routing and synthesis passes, comparing the results to traditional transpilation to highlight where AI offers performance gains."}),"\n",(0,s.jsxs)(t.p,{children:["For more details on the available AI passes, see the ",(0,s.jsx)(t.a,{href:"/guides/ai-transpiler-passes",children:"AI passes documentation"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"why-use-ai-for-quantum-circuit-transpilation",children:"Why use AI for quantum circuit transpilation?"}),"\n",(0,s.jsx)(t.p,{children:"As quantum circuits grow in size and complexity, traditional transpilation methods struggle to optimize layouts and reduce gate counts efficiently. Larger circuits, particularly those involving hundreds of qubits, impose significant challenges on routing and synthesis due to device constraints, limited connectivity, and qubit error rates."}),"\n",(0,s.jsx)(t.p,{children:"This is where AI-powered transpilation offers a potential solution. By leveraging machine learning techniques, the AI-powered transpiler in Qiskit can make smarter decisions about qubit routing and gate synthesis, leading to better optimization of large-scale quantum circuits."}),"\n",(0,s.jsx)(t.h3,{id:"brief-benchmarking-results",children:"Brief benchmarking results"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Graph showing AI transpiler performance against Qiskit",src:n(21504).A+"",width:"956",height:"738"})}),"\n",(0,s.jsxs)(t.p,{children:["In benchmarking tests, the AI transpiler consistently produced shallower, higher-quality circuits compared to the standard Qiskit transpiler. For these tests, we used Qiskit\u2019s default pass manager strategy, configured with [",(0,s.jsx)(t.code,{children:"generate_preset_passmanager"}),"]. While this default strategy is often effective, it can struggle with larger or more complex circuits. By contrast, AI-powered passes achieved an average 24% reduction in two-qubit gate counts and a 36% reduction in circuit depth for large circuits (100+ qubits) when transpiling to the heavy-hex topology of IBM Quantum hardware. For more information on these benchmarks, refer to this ",(0,s.jsx)(t.a,{href:"https://www.ibm.com/quantum/blog/qiskit-performance",children:"blog."})]}),"\n",(0,s.jsx)(t.p,{children:"This tutorial explores the key benefits of AI passes and how it compares to traditional methods."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-ibm-transpiler\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# This cell is hidden from users;\n# it just disables a linting rule.\n# ruff: noqa: F811\n"})}),"\n",(0,s.jsx)(t.h2,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsx)(t.p,{children:"Before starting this tutorial, ensure that you have the following installed:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Qiskit SDK v1.0 or later, with ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/visualization",children:"visualization"})," support"]}),"\n",(0,s.jsxs)(t.li,{children:["Qiskit Runtime (",(0,s.jsx)(t.code,{children:"pip install qiskit-ibm-runtime"}),") v0.22 or later"]}),"\n",(0,s.jsxs)(t.li,{children:["Qiskit IBM\xae Transpiler with AI local mode(",(0,s.jsx)(t.code,{children:"pip install 'qiskit-ibm-transpiler[ai-local-mode]'"}),")"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from qiskit import QuantumCircuit\nfrom qiskit.circuit.library import efficient_su2, PermutationGate\nfrom qiskit.synthesis.qft import synth_qft_full\nfrom qiskit.circuit.random import random_circuit, random_clifford_circuit\nfrom qiskit.transpiler import generate_preset_pass_manager, CouplingMap\nfrom qiskit_ibm_runtime import QiskitRuntimeService\nfrom qiskit_ibm_transpiler import generate_ai_pass_manager\nfrom qiskit.synthesis.permutation import (\n    synth_permutation_depth_lnn_kms,\n    synth_permutation_basic,\n)\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport time\nimport logging\n\nseed = 42\n\n# Used for generating permutation circuits in part two for comparison\ndef generate_permutation_circuit(width, pattern):\n    circuit = QuantumCircuit(width)\n    circuit.append(\n        PermutationGate(pattern=pattern),\n        qargs=range(width),\n    )\n    return circuit\n\n# Creates a Bernstein-Vazirani circuit given the number of qubits\ndef create_bv_circuit(num_qubits):\n    qc = QuantumCircuit(num_qubits, num_qubits - 1)\n    qc.x(num_qubits - 1)\n    qc.h(qc.qubits)\n    for i in range(num_qubits - 1):\n        qc.cx(i, num_qubits - 1)\n    qc.h(qc.qubits[:-1])\n    return qc\n\n# Transpile a circuit with a given pass manager and return metrics\ndef transpile_with_metrics(pass_manager, circuit):\n    start = time.time()\n    qc_out = pass_manager.run(circuit)\n    elapsed = time.time() - start\n\n    depth_2q = qc_out.depth(lambda x: x.operation.num_qubits == 2)\n    gate_count = qc_out.size()\n\n    return qc_out, {\n        "depth_2q": depth_2q,\n        "gate_count": gate_count,\n        "time_s": elapsed,\n    }\n\n# Used for collecting metrics for part 3 of synthesis methods\ndef synth_transpile_with_metrics(qc, pm, pattern_id, method):\n    start = time.time()\n    qc = pm.run(qc)\n    elapsed = time.time() - start\n\n    return {\n        "Pattern": pattern_id,\n        "Method": method,\n        "Depth (2Q)": qc.depth(lambda x: x.operation.num_qubits == 2),\n        "Gates": qc.size(),\n        "Time (s)": elapsed,\n    }\n\n# Ignore logs like "INFO:qiskit_ibm_transpiler.wrappers.ai_local_synthesis:Running Linear Functions AI synthesis on local mode"\n\nlogging.getLogger(\n    "qiskit_ibm_transpiler.wrappers.ai_local_synthesis"\n).setLevel(logging.WARNING)\n'})}),"\n",(0,s.jsx)(t.h1,{id:"part-i-qiskit-patterns",children:"Part I. Qiskit patterns"}),"\n",(0,s.jsxs)(t.p,{children:["Let's now see how to use the AI transpiler service with a simple quantum circuit, using Qiskit patterns. The key is creating a ",(0,s.jsx)(t.code,{children:"PassManager"})," with ",(0,s.jsx)(t.code,{children:"generate_ai_pass_manager()"})," instead of the standard ",(0,s.jsx)(t.code,{children:"generate_preset_pass_manager()"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem",children:"Step 1: Map classical inputs to a quantum problem"}),"\n",(0,s.jsxs)(t.p,{children:["In this section, we will test the AI transpiler on the ",(0,s.jsx)(t.code,{children:"efficient_su2"})," circuit, a widely used hardware-efficient ansatz. This circuit is particularly relevant for variational quantum algorithms (for example, VQE) and quantum machine-learning tasks, making it an ideal test case for assessing transpilation performance."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"efficient_su2"})," circuit consists of alternating layers of single-qubit rotations and entangling gates like CNOTs. These layers enable flexible exploration of the quantum state space while keeping the gate depth manageable. By optimizing this circuit, we aim to reduce gate count, improve fidelity, and minimize noise. This makes it a strong candidate for testing the AI transpiler\u2019s efficiency."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# For our transpilation, we will use a large circuit of 101 qubits\nqc = efficient_su2(90, entanglement="circular", reps=1).decompose()\n\n# Draw a smaller version of the circuit to get a visual representation\nqc_small = efficient_su2(5, entanglement="circular", reps=1).decompose()\nqc_small.draw(output="mpl")\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(90654).A+"",width:"874",height:"378"})}),"\n",(0,s.jsx)(t.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution",children:"Step 2: Optimize problem for quantum hardware execution"}),"\n",(0,s.jsx)(t.h3,{id:"choose-a-backend",children:"Choose a backend"}),"\n",(0,s.jsx)(t.p,{children:"For this example, we select the least busy operational IBM Quantum backend that is not a simulator and has at least 100 qubits:"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Note:"})," Since the least-busy backend can change over time, different devices might be selected for different runs. Device-specific properties, such as coupling maps, can lead to differences in the transpiled circuits."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'service = QiskitRuntimeService()\nbackend = service.least_busy(\n    operational=True, simulator=False, min_num_qubits=100\n)\ncm = backend.coupling_map\nprint(f"Using backend: {backend.name}")\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Using backend: ibm_torino\n"})}),"\n",(0,s.jsx)(t.h3,{id:"create-ai-and-traditional-pass-managers",children:"Create AI and traditional pass managers"}),"\n",(0,s.jsx)(t.p,{children:"To evaluate the effectiveness of the AI transpiler, we will perform two transpilation runs. First, we will transpile the circuit using the AI transpiler. Then, we will run a comparison by transpiling the same circuit without the AI transpiler, using traditional methods. Both transpilation processes will use the same coupling map from the chosen backend and the optimization level set to 3 for a fair comparison."}),"\n",(0,s.jsxs)(t.p,{children:["Both of these methods reflect the standard approach to create ",(0,s.jsx)(t.code,{children:"PassManager"})," instances to transpile circuits in Qiskit."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"pm_ai = generate_ai_pass_manager(\n    optimization_level=3,\n    ai_optimization_level=3,\n    coupling_map=cm,\n    include_ai_synthesis=True,  # used for part 3 when comparing synthesis methods\n)\n\npm_no_ai = generate_preset_pass_manager(\n    optimization_level=3,\n    coupling_map=cm,\n    seed_transpiler=seed,  # note that the AI pass manager does not currently support seeding\n)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Transpile the circuits and record the times."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"# Transpile using standard (non-AI) pass manager\n_, metrics_no_ai = transpile_with_metrics(pm_no_ai, qc)\nprint(\n    f\"Standard transpilation: Depth (2q) {metrics_no_ai['depth_2q']}, \"\n    f\"Gate count {metrics_no_ai['gate_count']}, Time {metrics_no_ai['time_s']}\"\n)\n\n# Transpile using AI pass manager\n_, metrics_ai = transpile_with_metrics(pm_ai, qc)\nprint(\n    f\"AI transpilation      : Depth (2q) {metrics_ai['depth_2q']}, \"\n    f\"Gate count {metrics_ai['gate_count']}, Time {metrics_ai['time_s']}\"\n)\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Standard transpilation: Depth (2q) 95, Gate count 458, Time 0.04650712013244629\nAI transpilation      : Depth (2q) 90, Gate count 456, Time 0.9342479705810547\n"})}),"\n",(0,s.jsx)(t.p,{children:"In this test, we compare the performance of the AI transpiler and the standard transpilation method on the efficient_su2 circuit. The AI transpiler achieves a noticeably shallower circuit depth while maintaining a similar gate count."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Circuit depth:"})," The AI transpiler produces a circuit with lower two-qubit depth. This is expected, as the AI passes are trained to optimize depth by learning qubit interaction patterns and exploiting hardware connectivity more effectively than rule-based heuristics."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Gate count:"})," The total gate count remains similar between the two methods. This aligns with expectations since the standard SABRE-based transpilation explicitly minimizes swap count, which dominates gate overhead. The AI transpiler instead prioritizes overall depth and may occasionally trade off a few additional gates for a shorter execution path."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Transpilation time:"})," The AI transpiler takes longer to run than the standard method. This is due to the added computational cost of invoking learned models during routing and synthesis. In contrast, the SABRE-based transpiler is now significantly faster after being rewritten and optimized in Rust, providing highly efficient heuristic routing at scale."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["It is important to note that these results are based on just one circuit. To obtain a comprehensive understanding of how the AI transpiler compares to traditional methods, it is necessary to test a variety of circuits. The performance of QTS can vary greatly depending on the type of circuit being optimized. For a broader comparison, refer to the benchmarks above or visit the ",(0,s.jsx)(t.a,{href:"https://www.ibm.com/quantum/blog/qiskit-performance",children:"blog."})]}),"\n",(0,s.jsx)(t.h2,{id:"step-3-execute-using-qiskit-primitives",children:"Step 3: Execute using Qiskit primitives"}),"\n",(0,s.jsx)(t.p,{children:"As this tutorial focuses on transpilation, no experiments will be executed on the quantum device. The goal is to leverage the optimizations from Step 2 to obtain a transpiled circuit with reduced depth or gate count."}),"\n",(0,s.jsx)(t.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format",children:"Step 4: Post-process and return result in desired classical format"}),"\n",(0,s.jsx)(t.p,{children:"Since there is no execution for this notebook, there are no results to post-process."}),"\n",(0,s.jsx)(t.h1,{id:"part-ii-analyze-and-benchmark-the-transpiled-circuits",children:"Part II. Analyze and benchmark the transpiled circuits"}),"\n",(0,s.jsx)(t.p,{children:"In this section, we will demonstrate how to analyze the transpiled circuit and benchmark it against the original version in more detail. We will focus on metrics such as circuit depth, gate count, and transpilation time to assess the effectiveness of the optimization. Additionally, we will discuss how the results may differ across various circuit types, offering insights into the broader performance of the transpiler across different scenarios."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Circuits to benchmark\nseed = 42\ncircuits = [\n    {\n        "name": "Random",\n        "qc": random_circuit(num_qubits=30, depth=10, seed=seed),\n    },\n    {\n        "name": "Clifford",\n        "qc": random_clifford_circuit(\n            num_qubits=40, num_gates=200, seed=seed\n        ),\n    },\n    {\n        "name": "QFT",\n        "qc": synth_qft_full(num_qubits=20, do_swaps=False).decompose(),\n    },\n    {\n        "name": "BV",\n        "qc": create_bv_circuit(40),\n    },\n]\n\nresults = []\n\n# Run the transpilation for each circuit and store the results\nfor circuit in circuits:\n    qc_no_ai, metrics_no_ai = transpile_with_metrics(pm_no_ai, circuit["qc"])\n    qc_ai, metrics_ai = transpile_with_metrics(pm_ai, circuit["qc"])\n\n    print("Completed transpilation for", circuit["name"])\n\n    results.append(\n        {\n            "Circuit": circuit["name"],\n            "Depth 2Q (No AI)": metrics_no_ai["depth_2q"],\n            "Gate Count (No AI)": metrics_no_ai["gate_count"],\n            "Time (No AI)": metrics_no_ai["time_s"],\n            "Depth 2Q (AI)": metrics_ai["depth_2q"],\n            "Gate Count (AI)": metrics_ai["gate_count"],\n            "Time (AI)": metrics_ai["time_s"],\n        }\n    )\n\ndf = pd.DataFrame(results)\ndf\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Completed transpilation for Random\nCompleted transpilation for Clifford\nCompleted transpilation for QFT\nCompleted transpilation for BV\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Circuit  Depth 2Q (No AI)  Gate Count (No AI)  Time (No AI)  \\\n0    Random                37                 221      0.039347   \n1  Clifford                36                 232      0.036633   \n2       QFT               165                 924      0.077458   \n3        BV                65                 155      0.024993   \n\n   Depth 2Q (AI)  Gate Count (AI)  Time (AI)  \n0             24              181   0.773718  \n1             43              267   1.097431  \n2            130              913   3.660771  \n3             70              155   0.345522\n"})}),"\n",(0,s.jsx)(t.p,{children:"Average percentage reduction for each metric. Positive are improvements, negative are degradations."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Average reduction from non-AI to AI transpilation as a percentage\navg_reduction_depth = (\n    (df["Depth 2Q (No AI)"] - df["Depth 2Q (AI)"]).mean()\n    / df["Depth 2Q (No AI)"].mean()\n    * 100\n)\navg_reduction_gates = (\n    (df["Gate Count (No AI)"] - df["Gate Count (AI)"]).mean()\n    / df["Gate Count (No AI)"].mean()\n    * 100\n)\navg_reduction_time = (\n    (df["Time (No AI)"] - df["Time (AI)"]).mean()\n    / df["Time (No AI)"].mean()\n    * 100\n)\n\nprint(f"Average reduction in depth: {avg_reduction_depth:.2f}%")\nprint(f"Average reduction in gate count: {avg_reduction_gates:.2f}%")\nprint(f"Average reduction in transpilation time: {avg_reduction_time:.2f}%")\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Average reduction in depth: 11.88%\nAverage reduction in gate count: 1.04%\nAverage reduction in transpilation time: -3193.95%\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'fig, axs = plt.subplots(1, 3, figsize=(21, 6))\ndf.plot(\n    x="Circuit",\n    y=["Depth 2Q (No AI)", "Depth 2Q (AI)"],\n    kind="bar",\n    ax=axs[0],\n)\naxs[0].set_title("Circuit Depth Comparison")\naxs[0].set_ylabel("Depth")\naxs[0].set_xlabel("Circuit")\naxs[0].tick_params(axis="x", rotation=45)\ndf.plot(\n    x="Circuit",\n    y=["Gate Count (No AI)", "Gate Count (AI)"],\n    kind="bar",\n    ax=axs[1],\n)\naxs[1].set_title("Gate Count Comparison")\naxs[1].set_ylabel("Gate Count")\naxs[1].set_xlabel("Circuit")\naxs[1].tick_params(axis="x", rotation=45)\ndf.plot(x="Circuit", y=["Time (No AI)", "Time (AI)"], kind="bar", ax=axs[2])\naxs[2].set_title("Time Comparison")\naxs[2].set_ylabel("Time (seconds)")\naxs[2].set_xlabel("Circuit")\naxs[2].tick_params(axis="x", rotation=45)\nfig.suptitle(\n    "Benchmarking AI transpilation vs Non-AI transpilation for various circuits"\n)\n\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(69619).A+"",width:"2090",height:"593"})}),"\n",(0,s.jsx)(t.p,{children:"The AI transpiler's performance varies significantly based on the type of circuit being optimized. In some cases, it achieves notable reductions in circuit depth and gate count compared to the standard transpiler. However, these improvements often come with a substantial increase in runtime."}),"\n",(0,s.jsx)(t.p,{children:"For certain types of circuits, the AI transpiler may yield slightly better results in terms of circuit depth but may also lead to an increase in gate count and a significant runtime penalty. These observations suggest that the AI transpiler's benefits are not uniform across all circuit types. Instead, its effectiveness depends on the specific characteristics of the circuit, making it more suitable for some use cases than others."}),"\n",(0,s.jsx)(t.h2,{id:"when-should-users-choose-ai-powered-transpilation",children:"When should users choose AI-powered transpilation?"}),"\n",(0,s.jsx)(t.p,{children:"The AI-powered transpiler in Qiskit excels in scenarios where traditional transpilation methods struggle, particularly with large-scale and complex quantum circuits. For circuits involving hundreds of qubits or those targeting hardware with intricate coupling maps, the AI transpiler offers superior optimization in terms of circuit depth, gate count, and runtime efficiency. In benchmarking tests, it has consistently outperformed traditional methods, delivering significantly shallower circuits and reducing gate counts, which are critical for enhancing performance and mitigating noise on real quantum hardware."}),"\n",(0,s.jsx)(t.p,{children:"Users should consider AI-powered transpilation when working with:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Large circuits where traditional methods fail to efficiently handle the scale."}),"\n",(0,s.jsx)(t.li,{children:"Complex hardware topologies where device connectivity and routing challenges arise."}),"\n",(0,s.jsx)(t.li,{children:"Performance-sensitive applications where reducing circuit depth and improving fidelity are paramount."}),"\n"]}),"\n",(0,s.jsx)(t.h1,{id:"part-iii-explore-ai-powered-permutation-network-synthesis",children:"Part III. Explore AI-powered permutation network synthesis"}),"\n",(0,s.jsx)(t.p,{children:"Permutation networks are foundational in quantum computing, particularly for systems constrained by restricted topologies. These networks facilitate long-range interactions by dynamically swapping qubits to mimic all-to-all connectivity on hardware with limited connectivity. Such transformations are essential for implementing complex quantum algorithms on near-term devices, where interactions often span beyond nearest neighbors."}),"\n",(0,s.jsxs)(t.p,{children:["In this section, we highlight the synthesis of permutation networks as a compelling use case for the AI-powered transpiler in Qiskit. Specifically, the ",(0,s.jsx)(t.code,{children:"AIPermutationSynthesis"})," pass leverages AI-driven optimization to generate efficient circuits for qubit permutation tasks. By contrast, generic synthesis approaches often struggle to balance gate count and circuit depth, especially in scenarios with dense qubit interactions or when attempting to achieve full connectivity."]}),"\n",(0,s.jsxs)(t.p,{children:["We will walk through a Qiskit patterns example showcasing the synthesis of a permutation network to achieve all-to-all connectivity for a set of qubits. We will compare the performance of ",(0,s.jsx)(t.code,{children:"AIPermutationSynthesis"})," against the standard synthesis methods in Qiskit. This example will demonstrate how the AI transpiler optimizes for lower circuit depth and gate count, highlighting its advantages in practical quantum workflows. To activate the AI synthesis pass, we will use the ",(0,s.jsx)(t.code,{children:"generate_ai_pass_manager()"})," function with the ",(0,s.jsx)(t.code,{children:"include_ai_synthesis"})," parameter set to ",(0,s.jsx)(t.code,{children:"True"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"step-1-map-classical-inputs-to-a-quantum-problem-1",children:"Step 1: Map classical inputs to a quantum problem"}),"\n",(0,s.jsx)(t.p,{children:"To represent a classical permutation problem on a quantum computer, we start by defining the structure of the quantum circuits. For this example:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Quantum circuit initialization:\nWe allocate 27 qubits to match the backend we will use, which has 27 qubits."}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["Apply permutations:\nWe generate ten random permutation patterns (",(0,s.jsx)(t.code,{children:"pattern_1"})," through ",(0,s.jsx)(t.code,{children:"pattern_10"}),") using a fixed seed for reproducibility. Each permutation pattern is applied to a separate quantum circuit (",(0,s.jsx)(t.code,{children:"qc_1"})," through ",(0,s.jsx)(t.code,{children:"qc_10"}),")."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsx)(t.p,{children:"Circuit decomposition:\nEach permutation operation is decomposed into native gate sets compatible with the target quantum hardware. We analyze the depth and the number of two-qubit gates (nonlocal gates) for each decomposed circuit."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The results provide insight into the complexity of representing classical permutation problems on a quantum device, demonstrating the resource requirements for different permutation patterns."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Parameters\nwidth = 27\nnum_circuits = 10\n\n# Set random seed\nnp.random.seed(seed)\n\n# Generate random patterns and circuits\npatterns = [\n    np.random.permutation(width).tolist() for _ in range(num_circuits)\n]\ncircuits = {\n    f"qc_{i}": generate_permutation_circuit(width, pattern)\n    for i, pattern in enumerate(patterns, start=1)\n}\n\n# Display one of the circuits\ncircuits["qc_1"].decompose(reps=3).draw(output="mpl", fold=-1)\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(40641).A+"",width:"2895",height:"1784"})}),"\n",(0,s.jsx)(t.h2,{id:"step-2-optimize-problem-for-quantum-hardware-execution-1",children:"Step 2: Optimize problem for quantum hardware execution"}),"\n",(0,s.jsx)(t.p,{children:"In this step, we proceed with optimization using the AI synthesis passes."}),"\n",(0,s.jsxs)(t.p,{children:["For the AI synthesis passes, the ",(0,s.jsx)(t.code,{children:"PassManager"})," requires only the coupling map of the backend. However, it is important to note that not all coupling maps are compatible; only those that the ",(0,s.jsx)(t.code,{children:"AIPermutationSynthesis"})," pass has been trained on will work. Currently, the ",(0,s.jsx)(t.code,{children:"AIPermutationSynthesis"})," pass supports blocks of sizes 65, 33, and 27 qubits. For this example we use a 27-qubit QPU."]}),"\n",(0,s.jsx)(t.p,{children:"For comparison, we will evaluate the performance of AI synthesis against generic permutation synthesis methods in Qiskit, including:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"synth_permutation_depth_lnn_kms"}),": This method synthesizes a permutation circuit for a linear nearest-neighbor (LNN) architecture using the Kutin, Moulton, and Smithline (KMS) algorithm. It guarantees a circuit with a depth of at most ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"n"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," and a size of at most ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsxs)(t.mrow,{children:[(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{stretchy:"false",children:"("}),(0,s.jsx)(t.mi,{children:"n"}),(0,s.jsx)(t.mo,{children:"\u2212"}),(0,s.jsx)(t.mn,{children:"1"}),(0,s.jsx)(t.mo,{stretchy:"false",children:")"}),(0,s.jsx)(t.mi,{mathvariant:"normal",children:"/"}),(0,s.jsx)(t.mn,{children:"2"})]}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"n(n-1)/2"})]})})}),(0,s.jsxs)(t.span,{className:"katex-html","aria-hidden":"true",children:[(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mopen",children:"("}),(0,s.jsx)(t.span,{className:"mord mathnormal",children:"n"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,s.jsx)(t.span,{className:"mbin",children:"\u2212"}),(0,s.jsx)(t.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.jsx)(t.span,{className:"mord",children:"1"}),(0,s.jsx)(t.span,{className:"mclose",children:")"}),(0,s.jsx)(t.span,{className:"mord",children:"/2"})]})]})]}),", where both depth and size are measured in terms of SWAP gates."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"synth_permutation_basic"}),": This is a straightforward implementation that synthesizes permutation circuits without imposing constraints on connectivity or optimization for specific architectures. It serves as a baseline for comparing performance with more advanced methods."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Each of these methods represents a distinct approach to synthesizing permutation networks, providing a comprehensive benchmark against the AI-powered methods."}),"\n",(0,s.jsxs)(t.p,{children:["For more details about synthesis methods in Qiskit, refer to the ",(0,s.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit/synthesis",children:"Qiskit API documentation"}),".\nDefine the coupling map representing the 27-qubit QPU."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:"coupling_map = [\n    [1, 0],\n    [2, 1],\n    [3, 2],\n    [3, 5],\n    [4, 1],\n    [6, 7],\n    [7, 4],\n    [7, 10],\n    [8, 5],\n    [8, 9],\n    [8, 11],\n    [11, 14],\n    [12, 10],\n    [12, 13],\n    [12, 15],\n    [13, 14],\n    [16, 14],\n    [17, 18],\n    [18, 15],\n    [18, 21],\n    [19, 16],\n    [19, 22],\n    [20, 19],\n    [21, 23],\n    [23, 24],\n    [25, 22],\n    [25, 24],\n    [26, 25],\n]\nCouplingMap(coupling_map).draw()\n"})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(92167).A+"",width:"741",height:"1063"})}),"\n",(0,s.jsx)(t.p,{children:"Transpile each of the permutation circuits using the AI synthesis passes and generic synthesis methods."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'results = []\npm_no_ai_synth = generate_preset_pass_manager(\n    coupling_map=cm,\n    optimization_level=1,  # set to 1 since we are using the synthesis methods\n)\n\n# Transpile and analyze all circuits\nfor i, (qc_name, qc) in enumerate(circuits.items(), start=1):\n    pattern = patterns[i - 1]  # Get the corresponding pattern\n\n    qc_depth_lnn_kms = synth_permutation_depth_lnn_kms(pattern)\n    qc_basic = synth_permutation_basic(pattern)\n\n    # AI synthesis\n    results.append(\n        synth_transpile_with_metrics(\n            qc.decompose(reps=3),\n            pm_ai,\n            qc_name,\n            "AI",\n        )\n    )\n\n    # Depth-LNN-KMS Method\n    results.append(\n        synth_transpile_with_metrics(\n            qc_depth_lnn_kms.decompose(reps=3),\n            pm_no_ai_synth,\n            qc_name,\n            "Depth-LNN-KMS",\n        )\n    )\n\n    # Basic Method\n    results.append(\n        synth_transpile_with_metrics(\n            qc_basic.decompose(reps=3),\n            pm_no_ai_synth,\n            qc_name,\n            "Basic",\n        )\n    )\n\nresults_df = pd.DataFrame(results)\n'})}),"\n",(0,s.jsx)(t.p,{children:"Record the metrics (depth, gate count, time) for each circuit after transpilation."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'# Calculate averages for each metric\naverage_metrics = results_df.groupby("Method")[\n    ["Depth (2Q)", "Gates", "Time (s)"]\n].mean()\naverage_metrics = average_metrics.round(3)  # Round to two decimal places\nprint("\\n=== Average Metrics ===")\nprint(average_metrics)\n\n# Identify the best non-AI method based on least average depth\nnon_ai_methods = [\n    method for method in results_df["Method"].unique() if method != "AI"\n]\nbest_non_ai_method = average_metrics.loc[non_ai_methods][\n    "Depth (2Q)"\n].idxmin()\nprint(\n    f"\\nBest Non-AI Method (based on least average depth): {best_non_ai_method}"\n)\n\n# Compare AI to the best non-AI method\nai_metrics = average_metrics.loc["AI"]\nbest_non_ai_metrics = average_metrics.loc[best_non_ai_method]\n\ncomparison = {\n    "Metric": ["Depth (2Q)", "Gates", "Time (s)"],\n    "AI": [\n        ai_metrics["Depth (2Q)"],\n        ai_metrics["Gates"],\n        ai_metrics["Time (s)"],\n    ],\n    best_non_ai_method: [\n        best_non_ai_metrics["Depth (2Q)"],\n        best_non_ai_metrics["Gates"],\n        best_non_ai_metrics["Time (s)"],\n    ],\n    "Improvement (AI vs Best Non-AI)": [\n        ai_metrics["Depth (2Q)"] - best_non_ai_metrics["Depth (2Q)"],\n        ai_metrics["Gates"] - best_non_ai_metrics["Gates"],\n        ai_metrics["Time (s)"] - best_non_ai_metrics["Time (s)"],\n    ],\n}\n\ncomparison_df = pd.DataFrame(comparison)\nprint("\\n=== Comparison of AI vs Best Non-AI Method ===")\ncomparison_df\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"=== Average Metrics ===\n               Depth (2Q)  Gates  Time (s)\nMethod                                    \nAI                   23.9   82.8     0.248\nBasic                29.8   91.0     0.012\nDepth-LNN-KMS        70.8  531.6     0.017\n\nBest Non-AI Method (based on least average depth): Basic\n\n=== Comparison of AI vs Best Non-AI Method ===\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-text",children:"Metric      AI   Basic  Improvement (AI vs Best Non-AI)\n0  Depth (2Q)  23.900  29.800                           -5.900\n1       Gates  82.800  91.000                           -8.200\n2    Time (s)   0.248   0.012                            0.236\n"})}),"\n",(0,s.jsx)(t.p,{children:"The results demonstrate that the AI transpiler outperforms all other Qiskit synthesis methods for this set of random permutation circuits. Key findings include:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Depth: The AI transpiler achieves the lowest average depth, indicating superior optimization of circuit layouts."}),"\n",(0,s.jsx)(t.li,{children:"Gate count: It significantly reduces the number of gates compared to other methods, improving execution fidelity and efficiency."}),"\n",(0,s.jsx)(t.li,{children:"Transpilation time: All methods run very quickly at this scale, making them practical for use. However, the AI transpiler does has a notable runtime increase compared to traditional methods due to the complexity of the AI models used."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"These results establish the AI transpiler as the most effective approach for this benchmark, particularly for depth and gate count optimization.\nPlot the results to compare the performance of the AI synthesis passes against the generic synthesis methods."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'methods = results_df["Method"].unique()\n\nfig, axs = plt.subplots(1, 3, figsize=(18, 5))\n\n# Pivot the DataFrame and reorder columns to ensure AI is first\npivot_depth = results_df.pivot(\n    index="Pattern", columns="Method", values="Depth (2Q)"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\npivot_gates = results_df.pivot(\n    index="Pattern", columns="Method", values="Gates"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\npivot_time = results_df.pivot(\n    index="Pattern", columns="Method", values="Time (s)"\n)[["AI", "Depth-LNN-KMS", "Basic"]]\n\npivot_depth.plot(kind="bar", ax=axs[0], legend=False)\naxs[0].set_title("Circuit Depth Comparison")\naxs[0].set_ylabel("Depth")\naxs[0].set_xlabel("Pattern")\naxs[0].tick_params(axis="x", rotation=45)\npivot_gates.plot(kind="bar", ax=axs[1], legend=False)\naxs[1].set_title("2Q Gate Count Comparison")\naxs[1].set_ylabel("Number of 2Q Gates")\naxs[1].set_xlabel("Pattern")\naxs[1].tick_params(axis="x", rotation=45)\npivot_time.plot(\n    kind="bar", ax=axs[2], legend=True, title="Legend"\n)  # Show legend on the last plot\naxs[2].set_title("Time Comparison")\naxs[2].set_ylabel("Time (seconds)")\naxs[2].set_xlabel("Pattern")\naxs[2].tick_params(axis="x", rotation=45)\nfig.suptitle(\n    "Benchmarking AI Synthesis Methods vs Non-AI Synthesis Methods For Random Permutations Circuits",\n    fontsize=16,\n    y=1,\n)\n\nplt.tight_layout()\nplt.show()\n'})}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Output of the previous code cell",src:n(9020).A+"",width:"1790",height:"505"})}),"\n",(0,s.jsxs)(t.p,{children:["This graph highlights the individual results for each circuit (",(0,s.jsx)(t.code,{children:"qc_1"})," to ",(0,s.jsx)(t.code,{children:"qc_10"}),") across different synthesis methods:"]}),"\n",(0,s.jsx)(t.p,{children:"While these results underscore the AI transpiler\u2019s effectiveness for permutation circuits, it is important to note its limitations. The AI synthesis method is currently only available for certain coupling maps, which may restrict its broader applicability. This constraint should be considered when evaluating its usage in different scenarios."}),"\n",(0,s.jsx)(t.p,{children:"Overall, the AI transpiler demonstrates promising improvements in depth and gate count optimization for these specific circuits while maintaining comparable transpilation times."}),"\n",(0,s.jsx)(t.h2,{id:"step-3-execute-using-qiskit-primitives-1",children:"Step 3: Execute using Qiskit primitives"}),"\n",(0,s.jsx)(t.p,{children:"As this tutorial focuses on transpilation, no experiments will be executed on the quantum device. The goal is to leverage the optimizations from Step 2 to obtain a transpiled circuit with reduced depth or gate count."}),"\n",(0,s.jsx)(t.h2,{id:"step-4-post-process-and-return-result-in-desired-classical-format-1",children:"Step 4: Post-process and return result in desired classical format"}),"\n",(0,s.jsx)(t.p,{children:"Since there is no execution for this notebook, there are no results to post-process."}),"\n",(0,s.jsx)(t.h2,{id:"tutorial-survey",children:"Tutorial survey"}),"\n",(0,s.jsx)(t.p,{children:"Please take this short survey to provide feedback on this tutorial. Your insights will help us improve our content offerings and user experience."}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.a,{href:"https://your.feedback.ibm.com/jfe/form/SV_0igXMtMCQfApgDI",children:"Link to survey"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},21504(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/ai-transpiler-benchmarks-5dfaa6123e5b1fc808af7c936ed6f3ba.avif"},40641(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/76a3e847-0808-4413-bd0c-c760cd2df3f4-0-0d3034cfa9815f5f2b9fd1f420c7787c.avif"},69619(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/79b8d5d9-0f9d-42ca-9583-8bec17430014-0-d31e14763e64049ac4420180296979b8.avif"},92167(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/84dff2c2-a496-4828-bb8e-08d373816a36-0-7f6cdedf900501e41bf594e30d1992a7.avif"},9020(e,t,n){n.d(t,{A:()=>i});const i=n.p+"assets/images/a326f268-0115-442c-8563-968676b66670-0-fcfe131dcc0450bf01804ee4bbd3492a.avif"},90654(e,t,n){n.d(t,{A:()=>i});const i="data:image/avif;base64,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"},28453(e,t,n){n.d(t,{R:()=>r,x:()=>o});var i=n(96540);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);