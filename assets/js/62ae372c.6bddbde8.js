"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[5714],{81905(e,i,r){r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"guides/local-simulators","title":"Migrate to local simulators","description":"Migrate from using the IBM Quantum cloud simulators to using Qiskit Runtime local testing mode.","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/local-simulators.mdx","sourceDirName":"guides","slug":"/guides/local-simulators","permalink":"/guides/local-simulators","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/local-simulators.mdx","tags":[],"version":"current","frontMatter":{"title":"Migrate to local simulators","description":"Migrate from using the IBM Quantum cloud simulators to using Qiskit Runtime local testing mode."},"sidebar":"tutorialsSidebar","previous":{"title":"Migrate to the V2 primitives","permalink":"/guides/v2-primitives"},"next":{"title":"Open source","permalink":"/guides/open-source"}}');var n=r(74848),t=r(28453);const a={title:"Migrate to local simulators",description:"Migrate from using the IBM Quantum cloud simulators to using Qiskit Runtime local testing mode."},o="Migrate from cloud simulators to local simulators",l={},u=[{value:"Why are the cloud simulators being retired?",id:"why-are-the-cloud-simulators-being-retired",level:2},{value:"When should simulators be used?",id:"when-should-simulators-be-used",level:2},{value:"Migrate to local simulators",id:"migrate-to-local-simulators",level:2},{value:"Guidance for choosing a simulator",id:"guidance-for-choosing-a-simulator",level:3},{value:"Fake backends",id:"fake-backends",level:3},{value:"AerSimulator",id:"aersimulator",level:3},{value:"Clifford simulation",id:"clifford-simulation",level:3}];function c(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components},{Admonition:r,Details:s}=i;return r||d("Admonition",!0),s||d("Details",!0),(0,n.jsxs)(n.Fragment,{children:["\n",(0,n.jsx)(i.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,n.jsx)(i.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"migrate-from-cloud-simulators-to-local-simulators",children:"Migrate from cloud simulators to local simulators"})}),"\n",(0,n.jsxs)(i.p,{children:["In quantum computing, the choice between using simulators and quantum hardware is crucial for making progress in the field. While simulators are useful for testing and debugging, in this era of quantum utility, quantum development and industry advancement requires actual hardware. As part of the move to quantum utility, IBM Quantum\xae cloud simulators were retired on 15 May 2024. This guide explains the retirement in more detail, and how to migrate from cloud-based simulators, such as ",(0,n.jsx)(i.code,{children:"ibmq_qasm_simulator"}),", to local simulators."]}),"\n",(0,n.jsx)(i.h2,{id:"why-are-the-cloud-simulators-being-retired",children:"Why are the cloud simulators being retired?"}),"\n",(0,n.jsx)(i.p,{children:"The cloud simulators are being retired for several reasons:"}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:(0,n.jsx)("a",{children:"Simulators have limitations"})}),(0,n.jsx)(i.p,{children:"Simulators can be useful, but they are too limited to use for research or experimentation:"}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsxs)(i.p,{children:["Simulators are valuable for understanding small-scale QPUs (quantum processing units), but their usefulness maxes out at around 50 qubits, even with access to high-performance supercomputers. This ceiling comes from the exponential growth in computational resources required to simulate larger quantum computers (review ",(0,n.jsx)(i.a,{href:"https://arxiv.org/abs/1805.04708",children:"Massively parallel quantum computer simulator, eleven years later"})," for the full explanation).  Exploring quantum computers of 100 qubits and more requires hardware."]}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"While some simulators offer noise models, it is a very hard problem to capture the entire dynamics of a real QPU. Quantum hardware offers the potential for researchers to confront the challenges inherent in quantum computers, such as noise, errors, and decoherence in a realistic testing environment."}),"\n"]}),"\n"]})]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:(0,n.jsx)("a",{children:"Using quantum hardware builds unique skills"})}),(0,n.jsx)(i.p,{children:"Interacting with quantum hardware grows skills and experience unattainable by only using simulators:"}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Direct interaction with quantum hardware builds skills because you must implement or use error mitigation or suppression techniques, for reliable computation."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Hands-on experience with quantum hardware develops a deeper understanding of quantum phenomena and how to tailor algorithms to the characteristics of quantum processors."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Engaging with quantum hardware results in practical insights into the challenges and opportunities of quantum computing, enhancing developers' ability to drive innovation in the field."}),"\n"]}),"\n"]})]}),"\n",(0,n.jsxs)(s,{children:[(0,n.jsx)("summary",{children:(0,n.jsx)("a",{children:"Algorithms should be adapted for quantum hardware"})}),(0,n.jsx)(i.p,{children:"Successful quantum algorithms must be adapted to exploit the capabilities of quantum hardware, optimizing performance and efficiency."}),(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Quantum hardware provides a more accurate representation of real-world QPUs than simulators."}),"\n"]}),"\n",(0,n.jsxs)(i.li,{children:["\n",(0,n.jsx)(i.p,{children:"Fine-tuning algorithms for quantum hardware involves adjusting ansatz, circuit implementations, parameters, and configuration to maximize performance.  This process is best achieved through direct experimentation with quantum hardware."}),"\n"]}),"\n"]})]}),"\n",(0,n.jsx)(i.h2,{id:"when-should-simulators-be-used",children:"When should simulators be used?"}),"\n",(0,n.jsx)(i.p,{children:"Quantum simulators should be used to help develop and test programs before fine-tuning them and sending them to quantum hardware. Local simulators can do this with good performance and efficiency.  Clifford circuits can be simulated very efficiently, and results can be verified, which is a useful way to gain confidence in an experiment."}),"\n",(0,n.jsx)(r,{type:"note",children:(0,n.jsxs)(i.p,{children:["Local testing mode does not have built-in error suppression or mitigation.  Instead, you must specify those options explicitly. See ",(0,n.jsx)(i.a,{href:"/guides/configure-error-mitigation",children:"Configure error mitigation for Qiskit Runtime"})," for details."]})}),"\n",(0,n.jsx)(i.h2,{id:"migrate-to-local-simulators",children:"Migrate to local simulators"}),"\n",(0,n.jsxs)(i.p,{children:["With ",(0,n.jsx)(i.code,{children:"qiskit-ibm-runtime"})," 0.22.0 or later, you can use local testing mode to replace cloud simulators. Depending on your needs, there are several ways to use local testing mode.  To begin, specify one of the fake backends in ",(0,n.jsx)(i.code,{children:"qiskit_ibm_runtime.fake_provider"})," or specify a Qiskit Aer backend when instantiating a primitive or a session."]}),"\n",(0,n.jsx)(i.h3,{id:"guidance-for-choosing-a-simulator",children:"Guidance for choosing a simulator"}),"\n",(0,n.jsx)(i.p,{children:"Use the following table to help choose a simulator."}),"\n",(0,n.jsxs)(i.table,{children:[(0,n.jsx)(i.thead,{children:(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.th,{children:"Simulator"}),(0,n.jsx)(i.th,{children:"Fake Backends"}),(0,n.jsx)(i.th,{children:"AerSimulator"}),(0,n.jsx)(i.th,{children:"Clifford Simulation"})]})}),(0,n.jsxs)(i.tbody,{children:[(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.strong,{children:"Purpose"})}),(0,n.jsx)(i.td,{children:"Mimics specific IBM\xae QPUs by using snapshots"}),(0,n.jsx)(i.td,{children:"General-purpose, high-performance simulation"}),(0,n.jsx)(i.td,{children:"Efficient simulation for Clifford circuits"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.strong,{children:"Noise model"})}),(0,n.jsx)(i.td,{children:"Automatically applies noise model from QPU snapshots"}),(0,n.jsx)(i.td,{children:"Custom or based on real QPU calibration data"}),(0,n.jsx)(i.td,{children:"Ideal for noise-free simulations"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.strong,{children:"Circuit size"})}),(0,n.jsx)(i.td,{children:"Limited to the capabilities of the mimicked QPU"}),(0,n.jsx)(i.td,{children:"Can handle larger circuits"}),(0,n.jsx)(i.td,{children:"Suitable for very large circuits (hundreds of qubits)"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.strong,{children:"Results"})}),(0,n.jsx)(i.td,{children:"Moderate runtime for QPU-specific tests"}),(0,n.jsx)(i.td,{children:"Shorter runtime for a wide range of simulations"}),(0,n.jsx)(i.td,{children:"Extremely fast, suitable for stabilizer circuits"})]}),(0,n.jsxs)(i.tr,{children:[(0,n.jsx)(i.td,{children:(0,n.jsx)(i.strong,{children:"Use case"})}),(0,n.jsx)(i.td,{children:"Testing transpiler and QPU-specific behavior"}),(0,n.jsx)(i.td,{children:"General development, custom noise models"}),(0,n.jsx)(i.td,{children:"Large stabilizer circuits, error correction"})]})]})]}),"\n",(0,n.jsx)(r,{type:"note",children:(0,n.jsxs)(i.p,{children:["For most users, ",(0,n.jsx)(i.code,{children:"AerSimulator"})," is a good choice, due to its flexibility and performance. However, if your work targets a specific QPU, a fake backend might be a better choice."]})}),"\n",(0,n.jsx)(i.h3,{id:"fake-backends",children:"Fake backends"}),"\n",(0,n.jsxs)(i.p,{children:["The ",(0,n.jsx)(i.a,{href:"https://docs.quantum.ibm.com/api/qiskit-ibm-runtime/fake-provider",children:"fake backends"})," mimic the behaviors of IBM QPUs by using snapshots. The snapshots contain important information about the QPU, such as the coupling map, basis gates, and qubit properties, which are useful for testing the transpiler and performing noisy simulations of the QPU.  The noise model from the snapshot is automatically applied during simulation."]}),"\n",(0,n.jsx)(i.p,{children:"Example:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from qiskit.circuit.library import RealAmplitudes\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime.fake_provider import FakeManilaV2\nfrom qiskit_ibm_runtime import SamplerV2 as Sampler, QiskitRuntimeService\n\nservice = QiskitRuntimeService()\n\n# Bell Circuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all()\n\n# Run the sampler job locally using FakeManilaV2\nfake_manila = FakeManilaV2()\npm = generate_preset_pass_manager(backend=fake_manila, optimization_level=1)\nisa_qc = pm.run(qc)\n\n# You can use a fixed seed to get fixed results.\noptions = {"simulator": {"seed_simulator": 42}}\nsampler = Sampler(mode=fake_manila, options=options)\n\nresult = sampler.run([isa_qc]).result()\n'})}),"\n",(0,n.jsx)(i.h3,{id:"aersimulator",children:"AerSimulator"}),"\n",(0,n.jsxs)(i.p,{children:["You can use local testing mode with simulators from ",(0,n.jsx)(i.a,{href:"/guides/simulate-with-qiskit-aer",children:"Qiskit Aer"}),", which provides higher-performance simulation that can handle larger circuits and ",(0,n.jsx)(i.a,{href:"/guides/build-noise-models",children:"custom noise models"}),". It also supports Clifford simulation mode, which can efficiently simulate Clifford circuits with a large number of qubits."]}),"\n",(0,n.jsx)(i.p,{children:"Example with sessions, without noise:"}),"\n",(0,n.jsx)(r,{type:"caution",children:(0,n.jsxs)(i.p,{children:["The following code block will return an error for users on the Open Plan, because it uses sessions. Workloads on the Open Plan can run only in ",(0,n.jsx)(i.a,{href:"/guides/execution-modes#job-mode",children:"job mode"})," or ",(0,n.jsx)(i.a,{href:"/guides/execution-modes#batch-mode",children:"batch mode"}),"."]})}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:"from qiskit_aer import AerSimulator\nfrom qiskit.circuit.library import RealAmplitudes\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import Session, SamplerV2 as Sampler, QiskitRuntimeService\n\nservice = QiskitRuntimeService()\n\n# Bell Circuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all()\n\n# Run the sampler job locally using AerSimulator.\n# Session syntax is supported but ignored because local mode doesn't support sessions.\naer_sim = AerSimulator()\npm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)\nisa_qc = pm.run(qc)\nwith Session(backend=aer_sim) as session:\n    sampler = Sampler()\n    result = sampler.run([isa_qc]).result()\n"})}),"\n",(0,n.jsxs)(i.p,{children:["To simulate with noise, specify a QPU (quantum hardware) and submit it to Aer.  Aer builds a noise model based on the calibration data from that QPU and instantiates an Aer backend with that model.  If you prefer, you can ",(0,n.jsx)(i.a,{href:"/guides/build-noise-models",children:"build a noise model"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"Example with noise:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'from qiskit_aer import AerSimulator\nfrom qiskit.circuit.library import RealAmplitudes\nfrom qiskit.circuit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\n\nservice = QiskitRuntimeService()\n\n# Bell Circuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all()\n\n# Specify a QPU to use for the noise model\nreal_backend = service.backend("ibm_brisbane")\naer = AerSimulator.from_backend(real_backend)\n\n# Run the sampler job locally using AerSimulator.\npm = generate_preset_pass_manager(backend=aer, optimization_level=1)\nisa_qc = pm.run(qc)\nsampler = Sampler(mode=aer)\nresult = sampler.run([isa_qc]).result()\n'})}),"\n",(0,n.jsx)("span",{id:"clifford-sim"}),"\n",(0,n.jsx)(i.h3,{id:"clifford-simulation",children:"Clifford simulation"}),"\n",(0,n.jsxs)(i.p,{children:["Because Clifford circuits can be simulated efficiently with verifiable results, Clifford simulation is a very useful tool. For an in-depth example, see ",(0,n.jsx)(i.a,{href:"/guides/simulate-stabilizer-circuits",children:"Efficient simulation of stabilizer circuits with Qiskit Aer primitives"}),"."]}),"\n",(0,n.jsx)(i.p,{children:"Example:"}),"\n",(0,n.jsx)(i.pre,{children:(0,n.jsx)(i.code,{className:"language-python",children:'import numpy as np\nfrom qiskit.circuit.library import EfficientSU2\nfrom qiskit_ibm_runtime import QiskitRuntimeService, SamplerV2 as Sampler\n\nservice = QiskitRuntimeService()\n\nn_qubits = 500  # <---- note this uses 500 qubits!\ncircuit = EfficientSU2(n_qubits)\ncircuit.measure_all()\n\nrng = np.random.default_rng(1234)\nparams = rng.choice(\n    [0, np.pi / 2, np.pi, 3 * np.pi / 2],\n    size=circuit.num_parameters,\n)\n\n# Tell Aer to use the stabilizer (clifford) simulation method\naer_sim = AerSimulator(method="stabilizer")\n\npm = generate_preset_pass_manager(backend=aer_sim, optimization_level=1)\nisa_circuit = pm.run(circuit)\nsampler = Sampler(mode=aer_sim)\nresult = sampler.run([(isa_circuit, params)]).result()\n'})})]})}function m(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}function d(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},28453(e,i,r){r.d(i,{R:()=>a,x:()=>o});var s=r(96540);const n={},t=s.createContext(n);function a(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);