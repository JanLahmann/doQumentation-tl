"use strict";(globalThis.webpackChunkdoqumentation=globalThis.webpackChunkdoqumentation||[]).push([[9866],{33816(e,t,s){s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"guides/qiskit-addons-cutting-wires","title":"Get started with wire cuts","description":"A worked example of wire cutting using the circuit cutting addon to get started with the package","source":"@site/i18n/tl/docusaurus-plugin-content-docs/current/guides/qiskit-addons-cutting-wires.mdx","sourceDirName":"guides","slug":"/guides/qiskit-addons-cutting-wires","permalink":"/guides/qiskit-addons-cutting-wires","draft":false,"unlisted":false,"editUrl":"https://github.com/JanLahmann/doQumentation/tree/main/docs/guides/qiskit-addons-cutting-wires.mdx","tags":[],"version":"current","frontMatter":{"title":"Get started with wire cuts","sidebar_label":"Get started with wire cuts","description":"A worked example of wire cutting using the circuit cutting addon to get started with the package","notebook_path":"docs/guides/qiskit-addons-cutting-wires.ipynb"},"sidebar":"tutorialsSidebar","previous":{"title":"Get started with gate cutting","permalink":"/guides/qiskit-addons-cutting-gates"},"next":{"title":"Qiskit Code Assistant","permalink":"/guides/qiskit-code-assistant"}}');var i=s(74848),a=s(28453);const r={title:"Get started with wire cuts",sidebar_label:"Get started with wire cuts",description:"A worked example of wire cutting using the circuit cutting addon to get started with the package",notebook_path:"docs/guides/qiskit-addons-cutting-wires.ipynb"},c="Get started with circuit cutting using wire cuts",o={},l=[{value:"Cut wires using the high-level <code>CutWire</code> instruction",id:"cut-wires-using-the-high-level-cutwire-instruction",level:2},{value:"Partition the circuit and observable",id:"partition-the-circuit-and-observable",level:3},{value:"Generate subexperiments to execute and post-process results",id:"generate-subexperiments-to-execute-and-post-process-results",level:3},{value:"Cut wires using the low-level <code>Move</code> instruction",id:"cut-wires-using-the-low-level-move-instruction",level:2},{value:"Next steps",id:"next-steps",level:2}];function d(e){const t={a:"a",admonition:"admonition",annotation:"annotation",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",math:"math",mi:"mi",mn:"mn",mrow:"mrow",msub:"msub",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,a.R)(),...e.components},{Admonition:n,Details:r,OpenInLabBanner:c}=t;return n||u("Admonition",!0),r||u("Details",!0),c||u("OpenInLabBanner",!0),(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsx)(t.admonition,{title:"Hindi pa naisalin",type:"note",children:(0,i.jsx)(t.p,{children:"Ang pahinang ito ay hindi pa naisalin. Nakikita mo ang orihinal na bersyon sa Ingles."})}),"\n",(0,i.jsx)(c,{notebookPath:"docs/guides/qiskit-addons-cutting-wires.ipynb"}),"\n",(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"get-started-with-circuit-cutting-using-wire-cuts",children:"Get started with circuit cutting using wire cuts"})}),"\n","\n",(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:(0,i.jsx)("b",{children:"Package versions"})}),(0,i.jsx)(t.p,{children:"The code on this page was developed using the following requirements.\nWe recommend using these versions or newer."}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"qiskit[all]~=2.3.0\nqiskit-ibm-runtime~=0.43.1\nqiskit-aer~=0.17\nqiskit-addon-cutting~=0.10.0\n"})})]}),"\n",(0,i.jsxs)(t.p,{children:["This guide demonstrates a working example of wire cuts with the ",(0,i.jsx)(t.code,{children:"qiskit-addon-cutting"})," package. It covers reconstructing expectation values of a seven-qubit circuit using wire cutting."]}),"\n",(0,i.jsxs)(t.p,{children:["A wire cut is represented in this package as a two-qubit ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-move",children:(0,i.jsx)(t.code,{children:"Move"})})," instruction, which is defined as a reset of the second qubit the instruction acts on, followed by a swap of both qubits. This operation is equivalent to transferring the state of the first qubit to the second qubit, while simultaneously discarding the incoming state of the second qubit."]}),"\n",(0,i.jsxs)(t.p,{children:["The package is designed to be consistent with the way you must treat wire cuts when acting on physical qubits. For example, a wire cut might take the state of physical qubit ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsx)(t.mi,{children:"n"})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(t.span,{className:"mord mathnormal",children:"n"})]})})]})," and continue it as a physical qubit ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsx)(t.mi,{children:"m"})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"m"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.4306em"}}),(0,i.jsx)(t.span,{className:"mord mathnormal",children:"m"})]})})]}),' after the cut. You can think of "instruction cutting" as a unified framework for considering both wire and gate cuts within the same formalism (since a wire cut is just a cut ',(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-move",children:(0,i.jsx)(t.code,{children:"Move"})})," instruction). Using this framework for wire cutting also allows for qubit re-use, which is explained in the section on ",(0,i.jsx)(t.a,{href:"#cut-wires-using-the-low-level-move-instruction",children:"cutting wires manually"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The single-qubit ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-cut-wire",children:(0,i.jsx)(t.code,{children:"CutWire"})})," instruction acts as a more abstracted, simpler interface for working with wire cuts. It allows you to denote where in the circuit a wire should be cut at a high level and have the circuit cutting addon insert the appropriate ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-move",children:(0,i.jsx)(t.code,{children:"Move"})})," instructions for you."]}),"\n",(0,i.jsx)(t.p,{children:"The following example demonstrates expectation value reconstruction after wire cutting. You will create a circuit with several non-local gates and define observables to estimate."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Added by doQumentation \u2014 installs packages not in the Binder environment\n%pip install -q qiskit-addon-cutting\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'import numpy as np\nfrom qiskit import QuantumCircuit\nfrom qiskit.transpiler import generate_preset_pass_manager\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit_ibm_runtime.fake_provider import FakeManilaV2\nfrom qiskit_ibm_runtime import SamplerV2, Batch\nfrom qiskit_aer.primitives import EstimatorV2\n\nfrom qiskit_addon_cutting.instructions import Move, CutWire\nfrom qiskit_addon_cutting import (\n    partition_problem,\n    generate_cutting_experiments,\n    cut_wires,\n    expand_observables,\n    reconstruct_expectation_values,\n)\n\nqc_0 = QuantumCircuit(7)\nfor i in range(7):\n    qc_0.rx(np.pi / 4, i)\nqc_0.cx(0, 3)\nqc_0.cx(1, 3)\nqc_0.cx(2, 3)\nqc_0.cx(3, 4)\nqc_0.cx(3, 5)\nqc_0.cx(3, 6)\nqc_0.cx(0, 3)\nqc_0.cx(1, 3)\nqc_0.cx(2, 3)\n\n# Define observable\nobservable = SparsePauliOp(["ZIIIIII", "IIIZIII", "IIIIIIZ"])\n\n# Draw circuit\nqc_0.draw("mpl")\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(60311).A+"",width:"726",height:"477"})}),"\n",(0,i.jsxs)(t.h2,{id:"cut-wires-using-the-high-level-cutwire-instruction",children:["Cut wires using the high-level ",(0,i.jsx)(t.code,{children:"CutWire"})," instruction"]}),"\n",(0,i.jsxs)(t.p,{children:["Next, make wire cuts using the single-qubit ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-cut-wire",children:(0,i.jsx)(t.code,{children:"CutWire"})})," instruction on qubit ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsxs)(t.msub,{children:[(0,i.jsx)(t.mi,{children:"q"}),(0,i.jsx)(t.mn,{children:"3"})]})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"q_3"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.jsxs)(t.span,{className:"mord",children:[(0,i.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"q"}),(0,i.jsx)(t.span,{className:"msupsub",children:(0,i.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(t.span,{className:"vlist-r",children:[(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.3011em"},children:(0,i.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:"3"})})]})}),(0,i.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(t.span,{className:"vlist-r",children:(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(t.span,{})})})]})})]})]})})]}),". Once the subexperiments are prepared to be executed, use the ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#cut_wires",children:(0,i.jsx)(t.code,{children:"cut_wires()"})})," function to transform ",(0,i.jsx)(t.code,{children:"CutWire"})," to ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-move",children:(0,i.jsx)(t.code,{children:"Move"})})," instructions on newly allocated qubits."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'qc_1 = QuantumCircuit(7)\nfor i in range(7):\n    qc_1.rx(np.pi / 4, i)\nqc_1.cx(0, 3)\nqc_1.cx(1, 3)\nqc_1.cx(2, 3)\nqc_1.append(CutWire(), [3])\nqc_1.cx(3, 4)\nqc_1.cx(3, 5)\nqc_1.cx(3, 6)\nqc_1.append(CutWire(), [3])\nqc_1.cx(0, 3)\nqc_1.cx(1, 3)\nqc_1.cx(2, 3)\n\nqc_1.draw("mpl")\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(32955).A+"",width:"973",height:"477"})}),"\n",(0,i.jsxs)(n,{type:"info",title:"Note about expanding observables",children:[(0,i.jsxs)(t.p,{children:["When a circuit is expanded through one or more wire cuts, the observable needs to be updated to account for the extra qubits that are introduced. The ",(0,i.jsx)(t.code,{children:"qiskit-addon-cutting"})," package has a convenience function ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#expand_observables",children:(0,i.jsx)(t.code,{children:"expand_observables()"})}),", which takes ",(0,i.jsx)(t.code,{children:"PauliList"})," objects and the original and expanded circuits as arguments, and returns a new ",(0,i.jsx)(t.code,{children:"PauliList"}),"."]}),(0,i.jsxs)(t.p,{children:["This returned ",(0,i.jsx)(t.code,{children:"PauliList"})," will not contain any information about the original observable's coefficients, but these can be ignored until reconstruction of the final expectation value."]})]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'# Transform CutWire instructions to Move instructions\nqc_2 = cut_wires(qc_1)\n\n# Expand the observable to match the new circuit size\nexpanded_observable = expand_observables(observable.paulis, qc_0, qc_2)\nprint(f"Expanded Observable: {expanded_observable}")\nqc_2.draw("mpl")\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"Expanded Observable: ['ZIIIIIIII', 'IIIZIIIII', 'IIIIIIIIZ']\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(42172).A+"",width:"973",height:"600"})}),"\n",(0,i.jsx)(t.h3,{id:"partition-the-circuit-and-observable",children:"Partition the circuit and observable"}),"\n",(0,i.jsxs)(t.p,{children:["Now the problem can be separated into partitions. This is accomplished using the ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#partition_problem",children:(0,i.jsx)(t.code,{children:"partition_problem()"})})," function with an optional set of partition labels to specify how to separate the circuit. Qubits sharing a common partition label are grouped together, and any non-local gates spanning more than one partition are cut."]}),"\n",(0,i.jsxs)(t.p,{children:["If no partition labels are provided, then the partitioning will be automatically determined based on the connectivity of the circuit. Read the next section on ",(0,i.jsx)(t.a,{href:"#cut-wires-using-the-low-level-move-instruction",children:"cutting wires manually"})," for more information on including partition labels."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'partitioned_problem = partition_problem(\n    circuit=qc_2,\n    observables=expanded_observable,\n)\nsubcircuits = partitioned_problem.subcircuits\nsubobservables = partitioned_problem.subobservables\nbases = partitioned_problem.bases\n\nprint(f"Subobservables to measure: \\n{subobservables}\\n")\nprint(f"Sampling overhead: {np.prod([basis.overhead for basis in bases])}")\nsubcircuits[0].draw("mpl")\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"Subobservables to measure: \n{0: PauliList(['IIIII', 'ZIIII', 'IIIIZ']), 1: PauliList(['ZIII', 'IIII', 'IIII'])}\n\nSampling overhead: 256.0\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(80507).A+"",width:"739",height:"353"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'subcircuits[1].draw("mpl")\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(43855).A+"",width:"554",height:"291"})}),"\n",(0,i.jsxs)(t.p,{children:["In this partitioning scheme, you have cut two wires, resulting in a sampling overhead of ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsxs)(t.msup,{children:[(0,i.jsx)(t.mn,{children:"4"}),(0,i.jsx)(t.mn,{children:"4"})]})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"4^4"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.8141em"}}),(0,i.jsxs)(t.span,{className:"mord",children:[(0,i.jsx)(t.span,{className:"mord",children:"4"}),(0,i.jsx)(t.span,{className:"msupsub",children:(0,i.jsx)(t.span,{className:"vlist-t",children:(0,i.jsx)(t.span,{className:"vlist-r",children:(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(t.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:"4"})})]})})})})})]})]})})]}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"generate-subexperiments-to-execute-and-post-process-results",children:"Generate subexperiments to execute and post-process results"}),"\n",(0,i.jsxs)(t.p,{children:["To estimate the expectation value of the full-sized circuit, several subexperiments are generated from the decomposed gates' joint quasi-probability distribution and then executed on one (or more) QPUs. The ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#generate_cutting_experiments",children:(0,i.jsx)(t.code,{children:"generate_cutting_experiments"})})," method does this by ingesting arguments for the ",(0,i.jsx)(t.code,{children:"subcircuits"})," and ",(0,i.jsx)(t.code,{children:"subobservables"})," dictionaries you created above, as well as for the number of samples to take from the distribution."]}),"\n",(0,i.jsx)(n,{type:"note",title:"Note about the number of samples",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"num_samples"})," argument specifies how many samples to draw from the quasi-probability distribution and determines the accuracy of the coefficients used for the reconstruction. Passing infinity (",(0,i.jsx)(t.code,{children:"np.inf"}),") ensures all coefficients are calculated exactly. Read the API docs on ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qpd#generate_qpd_weights",children:"generating weights"})," and ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#generate_cutting_experiments",children:"generating cutting experiments"})," for more information."]})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"# Generate subexperiments\nsubexperiments, coefficients = generate_cutting_experiments(\n    circuits=subcircuits, observables=subobservables, num_samples=np.inf\n)\n\n# Set a backend to use and transpile the subexperiments\nbackend = FakeManilaV2()\npass_manager = generate_preset_pass_manager(\n    optimization_level=1, backend=backend\n)\nisa_subexperiments = {\n    label: pass_manager.run(partition_subexpts)\n    for label, partition_subexpts in subexperiments.items()\n}\n\n# Submit each partition's subexperiments to the Qiskit Runtime Sampler\n# primitive, in a single batch so that the jobs will run back-to-back.\nwith Batch(backend=backend) as batch:\n    sampler = SamplerV2(mode=batch)\n    jobs = {\n        label: sampler.run(subsystem_subexpts, shots=2**12)\n        for label, subsystem_subexpts in isa_subexperiments.items()\n    }\n    # Retrieve results\n    results = {label: job.result() for label, job in jobs.items()}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Lastly, the expectation value of the full circuit can be reconstructed using the ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/qiskit-addon-cutting#reconstruct_expectation_values",children:(0,i.jsx)(t.code,{children:"reconstruct_expectation_values()"})})," method."]}),"\n",(0,i.jsx)(t.p,{children:"The code block below reconstructs the results and compares them with the exact expectation value."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'reconstructed_expval_terms = reconstruct_expectation_values(\n    results,\n    coefficients,\n    subobservables,\n)\n# Apply the coefficients of the original observable\nreconstructed_expval = np.dot(reconstructed_expval_terms, observable.coeffs)\n\n# Compute the exact expectation value using the `qiskit_aer` package.\nestimator = EstimatorV2()\nexact_expval = estimator.run([(qc_0, observable)]).result()[0].data.evs\nprint(\n    f"Reconstructed expectation value: {np.real(np.round(reconstructed_expval, 8))}"\n)\nprint(f"Exact expectation value: {np.round(exact_expval, 8)}")\nprint(\n    f"Error in estimation: {np.real(np.round(reconstructed_expval-exact_expval, 8))}"\n)\nprint(\n    f"Relative error in estimation: {np.real(np.round((reconstructed_expval-exact_expval) / exact_expval, 8))}"\n)\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"Reconstructed expectation value: 1.45965266\nExact expectation value: 1.59099026\nError in estimation: -0.1313376\nRelative error in estimation: -0.08255085\n"})}),"\n",(0,i.jsxs)(n,{type:"caution",title:"Note about observable coefficients",children:[(0,i.jsxs)(t.p,{children:["To accurately reconstruct the expectation value, the coefficients of the original observable (which are different from the output of ",(0,i.jsx)(t.code,{children:"generate_cutting_experiments()"}),") must be applied to the output of the reconstruction, since this information was lost when the cutting experiments were generated or when the observable was expanded."]}),(0,i.jsxs)(t.p,{children:["Typically these coefficients can be applied through ",(0,i.jsx)(t.code,{children:"numpy.dot()"})," as shown previously."]})]}),"\n",(0,i.jsxs)(t.h2,{id:"cut-wires-using-the-low-level-move-instruction",children:["Cut wires using the low-level ",(0,i.jsx)(t.code,{children:"Move"})," instruction"]}),"\n",(0,i.jsxs)(t.p,{children:["One limitation of using the higher-level ",(0,i.jsx)(t.code,{children:"CutWire"})," instruction is that it does not allow for qubit re-use. If this is desired for a cutting experiment, you can instead manually place ",(0,i.jsx)(t.a,{href:"https://docs.quantum.ibm.com/api/qiskit-addon-cutting/instructions-move",children:(0,i.jsx)(t.code,{children:"Move"})})," instructions. However, because the ",(0,i.jsx)(t.code,{children:"Move"})," instruction discards the state of the destination qubit, it is important that this qubit does not share any entanglement with the remainder of the system. Otherwise, the reset operation will cause the state of the circuit to partially collapse after the wire cut."]}),"\n",(0,i.jsxs)(t.p,{children:["The code block below performs a wire cut on qubit ",(0,i.jsxs)(t.span,{className:"katex",children:[(0,i.jsx)(t.span,{className:"katex-mathml",children:(0,i.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(t.semantics,{children:[(0,i.jsx)(t.mrow,{children:(0,i.jsxs)(t.msub,{children:[(0,i.jsx)(t.mi,{children:"q"}),(0,i.jsx)(t.mn,{children:"3"})]})}),(0,i.jsx)(t.annotation,{encoding:"application/x-tex",children:"q_3"})]})})}),(0,i.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(t.span,{className:"base",children:[(0,i.jsx)(t.span,{className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.jsxs)(t.span,{className:"mord",children:[(0,i.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03588em"},children:"q"}),(0,i.jsx)(t.span,{className:"msupsub",children:(0,i.jsxs)(t.span,{className:"vlist-t vlist-t2",children:[(0,i.jsxs)(t.span,{className:"vlist-r",children:[(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.3011em"},children:(0,i.jsxs)(t.span,{style:{top:"-2.55em",marginLeft:"-0.0359em",marginRight:"0.05em"},children:[(0,i.jsx)(t.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(t.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsx)(t.span,{className:"mord mtight",children:"3"})})]})}),(0,i.jsx)(t.span,{className:"vlist-s",children:"\u200b"})]}),(0,i.jsx)(t.span,{className:"vlist-r",children:(0,i.jsx)(t.span,{className:"vlist",style:{height:"0.15em"},children:(0,i.jsx)(t.span,{})})})]})})]})]})})]})," for the same example circuit as previously shown. The difference here is that you can reuse a qubit by reversing the ",(0,i.jsx)(t.code,{children:"Move"})," operation where the second wire cut was made (however, this is not always possible and depends on the circuit being cut)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'qc_1 = QuantumCircuit(8)\nfor i in [*range(4), *range(5, 8)]:\n    qc_1.rx(np.pi / 4, i)\nqc_1.cx(0, 3)\nqc_1.cx(1, 3)\nqc_1.cx(2, 3)\nqc_1.append(Move(), [3, 4])\nqc_1.cx(4, 5)\nqc_1.cx(4, 6)\nqc_1.cx(4, 7)\nqc_1.append(Move(), [4, 3])\nqc_1.cx(0, 3)\nqc_1.cx(1, 3)\nqc_1.cx(2, 3)\n\n# Expand observable\nobservable_expanded = SparsePauliOp(["ZIIIIIII", "IIIIZIII", "IIIIIIIZ"])\nqc_1.draw("mpl")\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(6998).A+"",width:"973",height:"538"})}),"\n",(0,i.jsxs)(t.p,{children:["The circuit above can now be partitioned and cutting experiments generated. To explicitly specify how the circuit should be partitioned, you can add partition labels to the ",(0,i.jsx)(t.code,{children:"partition_problem()"})," function. Qubits that share a common partition label are grouped together, and any non-local gates spanning more than one partition are cut. The keys of the dictionary output by ",(0,i.jsx)(t.code,{children:"partition_problem()"})," will match those specified in the label string."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'partitioned_problem = partition_problem(\n    circuit=qc_1,\n    partition_labels="AAAABBBB",\n    observables=observable_expanded.paulis,\n)\nsubcircuits = partitioned_problem.subcircuits\nsubobservables = partitioned_problem.subobservables\nbases = partitioned_problem.bases\n\nprint(f"Subobservables to measure: \\n{subobservables}\\n")\nprint(f"Sampling overhead: {np.prod([basis.overhead for basis in bases])}")\nsubcircuits["A"].draw("mpl")\n'})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"Subobservables to measure: \n{'A': PauliList(['IIII', 'ZIII', 'IIIZ']), 'B': PauliList(['ZIII', 'IIII', 'IIII'])}\n\nSampling overhead: 256.0\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(9135).A+"",width:"802",height:"291"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'subcircuits["B"].draw("mpl")\n'})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Output of the previous code cell",src:s(59292).A+"",width:"554",height:"291"})}),"\n",(0,i.jsx)(t.p,{children:"Now the cutting experiments can be generated and the expectation value reconstructed in the same way as the previous section."}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next steps"}),"\n",(0,i.jsx)(n,{type:"tip",title:"Recommendations",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Read the ",(0,i.jsx)(t.a,{href:"/guides/qiskit-addons-cutting-gates",children:"Get started with circuit cutting using gate cuts"})," guide."]}),"\n",(0,i.jsxs)(t.li,{children:["Read the arXiv paper on ",(0,i.jsx)(t.a,{href:"https://arxiv.org/abs/2302.03366",children:"optimal wire cutting"})," to better understand the equivalence between wire cutting and gate cutting."]}),"\n"]})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function u(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},6998(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/15461a2c-85a9-4cb2-a632-b9597ccbc4bd-0-0c19e455274cf5b8df479fc5bfa10a0d.svg"},9135(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/2139745a-bdc3-40bd-bd6f-d26d2a5b5b14-1-da0a99936184e376497ec382929d052d.svg"},59292(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/4aeb3f1f-a55e-49c4-a7bd-837132429ee1-0-33d4cf92b7f412ee514a27fa2adf87d8.svg"},80507(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/5fb034f2-da8a-4f4d-ab9b-c990593e04fc-1-3157fc5d0860065c2d4fd31259ab0a05.svg"},32955(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/9bac1915-316b-49d0-a1a1-145047679530-0-7e188604cfff1d2791302ebb4cea74ce.svg"},60311(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/b481ef2d-3912-4eac-9755-335e8f5db886-0-be111ae190b7ff908edfcc1b4c9527a2.svg"},43855(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/d0e86f81-7c7e-4ccf-951c-9cd039135dc9-0-7e26c4b02d05e57f85bbb6443c4e3006.svg"},42172(e,t,s){s.d(t,{A:()=>n});const n=s.p+"assets/images/d398b397-0167-4db9-97ae-6ea502dc43e3-1-fe88f5c7f842f6ad5db76e4cea6b19f1.svg"},28453(e,t,s){s.d(t,{R:()=>r,x:()=>c});var n=s(96540);const i={},a=n.createContext(i);function r(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);